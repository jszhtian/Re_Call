
■ Siglus について

	Siglus（シグラス）は、スクリプト記述型のアドベンチャーゲーム（ＡＶＧ）開発環境です。
	Direct3D を使った３Ｄ演出、ネットワークを用いたオンラインゲームへも拡張予定です。

+ 動作環境（例）

<div class="table-container">
<table>
||必須環境|推奨環境|
|OS</td><td colspan="2"><font color="red">日本語版 Microsoft Windows 8 / 7 / Vista / XP</font>（※１）|
|CPU|Pentium4 2GHz 以上|Core 2 Duo 以上（※２）|
|メモリ|256MB 以上|512MB 以上|
|HDD|100MB 以上|4GB 以上|
|VRAM|128MB 以上|256MB 以上（2011/06/01 変更されました）|
|画面解像度</td><td colspan="2">1280×720 24bit Full Color 以上|
|グラフィック</td><td colspan="2"><font color="red">DirectX 9.0 に完全対応したビデオカード<br />（ピクセルシェーダ 2.0 に対応していること）</font>（※４）|
|サウンド</td><td colspan="2">DirectSound|
|DirectX</td><td colspan="2"><font color="red">DirectX 9.0 以上</font>（※５）|
|その他</td><td colspan="2">要ＤＶＤドライブ、マウス、キーボード|
</table>
</div>

	（※１）Windows 2000 には対応していません。

	（※２）必ず "Duo" をつけて下さい。デュアルコア以上が欲しいことを示しています。

	（※４）Siglus は ピクセルシェーダ 2.0 を使っています。
	ビデオカードが DirectX 9.0 に完全対応している必要があります。（9.0c 以上ではなく 9.0 以上です）
	目安として、2003年以降に発売されたマシンなら動くと思います。

	（※５）Siglus は DirectX 9.0 (SDK October 2004) を使っています。
	DirectX 9.0 以上がインストールされている必要があります。（9.0c 以上ではなく 9.0 以上です）

	（※４、※５）<font color="red">「グラフィック」と「DirectX」の項目は意味が異なります。必ず両方とも記載して下さい。</font>

<div class="table-container">
<table>
||非対応|対応|
|Intel|・Intel 8** 以前のオンボードチップ<br />・Intel 828** 以前のオンボードチップ|・Intel 829** 以降のオンボードチップ<br />・Intel 9** 以降のオンボードチップ<br />（Intel GMA、Intel HD Graphics など）|
|NVIDIA|・GeForce 4 以前|・GeForce FX（5000）シリーズ以降<br />・GeForce 100 シリーズ以降|
|ATI|・Radeon R200 以前（～9250）<br />・Radeon IGP？|・Radeon R300 以降<br />（9500-9800、X300-X1950～、HD2000代～）|
|その他|・Millenium シリーズ<br />・SiS Mirage 2 以前|・SiS Mirage 3 以降|
</table>
</div>

+ 動かなかった場合

	動かないマシンがあった場合、エラーメッセージを添えてお教えいただけると助かります。

	対応していないマシンでは、エラーメッセージを表示した後、速やかにアプリケーションを終了するように組んでいます。
	もし強制終了されてしまった場合は、バグになります。スペックが足りなかったから動かなかったーと放置するのではなく、
	開発者にご一報を頂けると非常にありがたいです。



■ サンプルの起動

	まずはサンプルを起動して下さい。

<pre class="exp">
◇Siglus\◇サンプル開発環境\exe\SiglusEngine.exe
</pre>

+ デバッグモードで起動する

	開発中は、デバッグモードで起動することをお勧めします。
	SiglusDebugger3.dll が必要です。

<pre class="exp">
◇Siglus\◇サンプル開発環境\work\SiglusDebugger3.dll
</pre>

<div class="chips">
SiglusEngine Ver.1.1.0.0 より、SiglusDebugger2.dll → SiglusDebugger3.dll に変更されました。
<br /><s>SiglusEngine Ver.1.0.4.2 より、SiglusDebugger.dll → SiglusDebugger2.dll に変更されました。</s>
</div>

	デバッグモードで起動するには、いくつかの方法があります。

<ul>
- exe フォルダに SiglusDebugger3.dll を入れる

	一番簡単な方法です。ただし、製品時に取り除く必要があります。忘れやすいのであまりお勧めしません。

- システムフォルダ（32bit版OSの場合は C:\Windows\System32、64bit版OSの場合は C:\Windows\SysWOW64）に SiglusDebugger3.dll を入れる

	常にデバッグモードで起動できます。逆にリリースモードで起動するために、コンパイラが必要になります。

- 作業フォルダに SiglusDebugger3.dll を入れる

	コンパイラの操作が必要になります。お勧めの方法です。
</ul>

<div class="chips">
SiglusEngine Ver.1.0.4.2 より、セキュリティ強化のため、コマンドラインからの起動はなくなりました。ご了承下さい。
</div>

++ コンパイラを使ってデバッグモードで起動する

<pre class="exp">
◇Siglus\◇サンプル開発環境\SiglusCompiler.exe
</pre>

	コンパイラを起動し、「新規」ボタンでプロジェクトを作成します。
	出てきた「プロジェクトを追加」ダイアログで、以下の設定をして下さい。

<div class="table-container">
<table>
|||例|
|プロジェクト名|好きな名前を設定してください。|サンプルゲーム|
|実行ファイル|exe フォルダ内の SiglusEngine.exe を指定してください。|C:\◇Siglus\◇サンプル開発環境\exe\SiglusEngine.exe|
|作業フォルダ|work フォルダを指定してください。|C:\◇Siglus\◇サンプル開発環境\work|
</table>
</div>

	<font color="red">ファイルやフォルダを、入力欄にドラッグ＆ドロップすることで、簡単に設定することができます。</font>
	多くのツールがこの方法に対応しています。

	[ ＯＫ：プロジェクトを【追加】する ] を押してください。

	ダイアログ左の「実行」ボタンを押すと、デバッグモードで起動できます。
	作業フォルダを指定した場合、セーブデータも作業フォルダに出力されます。
	製品版に間違って入れてしまうのを防ぐことができます。
	開発中はこの方法で起動することをお勧めします。

	デバッグモードで起動すると、ウィンドウ上部にデバッグメニューが表示されます。

<div align="center">
<img src="../img/デバッグメニュー.png" />
</div>

	基本操作の他、システムコマンドメニュー、デバッグメニューを１通り触ってみてください。


■ コマンドラインからの起動

	上級者向けの起動方法です。普通は使うことがないと思います。
	分かる方は、他のアプリと連携するときなどに使って下さい。

+ コマンドラインからコンパイル

	SiglusCompiler.exe に引数を送ることで、コマンドラインからコンパイルが出来ます。

	ただし、プロジェクトの設定などは GUI で行う必要があります。
	「あとはコンパイルするだけ」と言うところまで設定し、終了して下さい。
	その後、コマンドラインからコンパイルのみを行って下さい。

<div class="table-container">
<table>
|/cui|CUI モードで起動します。必須のオプションです。|
|/project_no=???|プロジェクト番号を指定します。GUI の左上のコンボボックスで選ぶやつです。省略すると、GUI で指定されているプロジェクトが使われます。|
|/full|指定するとフルコンパイルを行います。GUI の「全コンパイル」ボタンと同じ動作です。指定しない場合は更新分だけがコンパイルされます。GUI の「更新分をコンパイル」ボタンと同じ動作です。|
|/log="???"|ログファイルの出力ディレクトリを指定します。絶対パスもしくは相対パスが使えます。エラー詳細などを受け取るために必要です。省略するとログファイルが出力されません。<br />パスは &quot;&quot; で囲う必要があります。<b>文字列の指定とエスケープ文字</b>を参照して下さい。|
</table>
</div>

++ エラーログの取得

	コンパイルを行うと、/log で指定したフォルダに log.txt が作成されます。

	コンパイルにエラーがあった場合、/log で指定したフォルダに error.dat が作成されます（中身は空です）。
	エラーがなかった場合は自動的に削除されます。
	error.dat の有無で、エラーの有無を判定できます。

+ コマンドラインから起動

	SiglusEngine.exe に引数を送ることで、コマンドラインからゲームを起動できます。
	普通に起動するだけなら引数は必要ありません。（&gt;SiglusEngine.exe）

<div class="table-container">
<table>
|/start="???"|スタートシーン名を文字列で指定します。拡張子は必要ありません。|
|/z_no=???|スタートシーンのＺラベル番号を指定します。|
|/debug_off|強制的にデバッグモードをオフで起動します。|
|/work_dir="???"|作業フォルダを指定します。|
|/end_start|（★ｵｽｽﾒ）既に SiglusEngine.exe が起動している場合、終了してから改めて起動します。|
</table>
</div>

	デバッグモードをオンにする指定子はありません。
	SiglusDebugger2.dll を置くことでデバッグモードにして下さい。

+ 文字列の指定とエスケープ文字

	引数に文字列を指定するときは、必ずダブルコーテーション（&quot;&quot;）で囲って下さい。
	円記号（&yen;）はエスケープ文字になります。文字列の中で円記号を使うときは、円記号を２つ並べて下さい。（&yen;&yen;）

<pre class="exp">
// コンパイラにプロジェクト番号とログファイルを指定する
SiglusCompiler.exe /cui /project_no=0 /log_file="C:\\sample project\\log\\a.txt"
</pre>

	コマンドラインの慣例と少し異なりますが、今後の拡張のためです。ご了承下さい。



■代表的な起動エラー

<ul>
<li><a href="#no_directx">d3d9.dll が見つかりません。</a></li>
<li><a href="#dx9_not_supported">ビデオカードが DirectX 9.0 に対応していません。</a></li>
<li><a href="#ps2_not_supported">ビデオカードがピクセルシェーダ 2.0 に対応していません。</a></li>
</ul>

<a name="no_directx">
<h4>d3d9.dll が見つかりません。</h4>

<div align="center">
<img src="../img/Win98_no_dx9.png" />
<div>Windows 98 の場合</div>
<div><br /></div>
<img src="../img/Win2000_no_dx9.png" />
<div>Windows 2000 の場合</div>
</div>

	ご使用中のパソコンに DirectX 9.0 が入っていません。
	マイクロソフトのウェブサイトより、最新版の DirectX End-User Runtime をダウンロードして下さい。

<blockquote>■Microsoft DirectX<br /><a href="http://www.microsoft.com/japan/directx/default.mspx">http://www.microsoft.com/japan/directx/default.mspx</a></blockquote>

<a name="dx9_not_supported">
<h4>ビデオカードが DirectX 9.0 に対応していません。</h4>

<div align="center">
<img src="../img/WinXP_dx9_not_supported.png" />
<div>Windows XP の場合</div>
</div>

	ご使用のビデオカードが DirectX 9.0 に対応していないため、ゲームを起動することが出来ません。
	申し訳ございませんが、対応外のビデオカードとなります。

<a name="ps2_not_supported">
<h4>ビデオカードがピクセルシェーダ 2.0 に対応していません。</h4>

<div align="center">
<img src="../img/Win2000_ps2_not_supported.png" />
<div>Windows 2000 の場合</div>
</div>

	ご使用のビデオカードがピクセルシェーダ 2.0 に対応していないため、ゲームを起動することが出来ません。
	申し訳ございませんが、対応外のビデオカードとなります。


■ 操作方法

+ 操作方法

	左クリック、[Enter]、[X] : 決定、メッセージを進める

	右クリック、[ESC]、[Z] : キャンセル、システムコマンドメニューを開く（またはキャンセルシーンを呼ぶ）

	ホイール↑、[PageUp] : メッセージバックの開始、メッセージバックの巻き戻し

	ホイール↓、[PageDown] : メッセージを進める、メッセージバックの順送り

	[Space] : メッセージウィンドウを一時的に消去／解除

	[Alt + Enter] : フルスクリーン／標準ウィンドウの切り替え

	[Ctrl] : 早送り（未読文章も早送りします）

++ Ctrl キーによる早送り

	時間待ち、キー待ちなどの待ち命令をを無視してすっ飛ばします。
	アニメなどの動作は３２倍速で動きます。

+ デバッグモード時の操作方法

	[F1] : ゲームを最初からはじめる

	[F3] : ブレーク／ブレークの解除

	[F8] : エラーダイアログを開く

	['O'] : 実行中のシーンスクリプト（ss）を開く

	['P'] : 現在のメッセージをクリップボードにコピー

++ 一時的に動作を早くする／遅くする

	[ Insert ] : ４倍速

	[ Delete ] : ２倍速

	[ Home ] : １／４倍速

	[ End ] : １／８倍速

++ ブレーク

	ゲームを一時停止する機能です。
	ステップ実行を行うことで、スクリプト１行単位でゲームを実行できます。
	デバッグには必須の昨日ですので、有効に活用してください。

	['1'] : ステップ実行（ブレーク中のみ）





■ セーブデータについて

+ セーブデータについて

	ゲームを起動すると、自動的にセーブデータが作成されます。
	セーブデータは [exe] フォルダの [savedata] フォルダに作成されます。
	ただし、作業フォルダを指定している場合は作業フォルダに、
	セットアップされている場合はマイドキュメント（ドキュメント）に保存されます。

<div class="table-container">
<table>
|config.sav|環境設定データ|
|read.sav|既読データ|
|setting.ini|ウィンドウの設定|
|movie.ini|ムービーの設定|
|global.sav|グローバルデータ|
|????.sav（数字４桁）|ローカルデータ|
|????.bmp（数字４桁）|サムネイルデータ|
</table>
</div>

	以下のようなことをすると、セーブデータが使えなくなります。
	一度 savedata フォルダを消してから起動しなおしてください。

<ul>
- Gameexe.ini でエレメントの個数を変える（#FLAG.CNT、#OBJECT.CNT、等）
</ul>


■ Flag.ini

<div align="center">
<img src="Flag.ini.jpg">
</div>

	デバッグ中、よく使うフラグを登録しておくと、
	ゲーム実行中にフラグの変化をリアルタイムで見ることができます。
	また、<font color="red">ゲームを実行しながら、フラグの値を書き換えることもできます。</font>

	フラグは２０個のグループに分けて登録できます。
	例：グループ０は好感度、グループ１は分岐に関わる重要なフラグ、…。

	使いこなすと、デバッグが非常に楽になります。上手く使って下さい。

+ Flag.ini を作成する

	作業フォルダ（設定していない場合は SiglusEngine.exe のあるフォルダ）に、
	Flag.ini というテキストファイルを新規作成して下さい。

+ Flag.ini のサンプル

<pre class="source">
#TITLE_FLAG00 = サンプル０番

G[0000] : 0 : シーン回想中
G[0010] : 0 : シーン１を見た
G[0011] : 0 : シーン２を見た
G[0012] : 0 : シーン３を見た
G[0100] : 0 : ハイスコア

#TITLE_FLAG01 = サンプル１番

F[0000] : 1 : Ｆフラグ
L[0000] : 1 : Ｌフラグ
S[0000] : 1 : Ｓフラグ
F.bit[0000] : 1 : ビットフラグ
</pre>

+ グループのタイトル

	#TITLE_FLAG00 ～ #TITLE_FLAG19 まで設定できます。

	例：好感度、分岐フラグ、…。

+ フラグの登録

フラグ : グループ番号 : コメント

<ul>
- フラグ：フラグ名を設定します。
- グループ番号：グループ番号を設定します。
- コメント：任意で設定でき、ダイアログに表示されます。
</ul>

+ フラグの編集

	フラグの値の欄をダブルクリックして下さい。
	小さなエディットボックスが現れ、値を編集することができます。



■ ゲーム作成の流れ

+ プロジェクトを作る

	まずは、以下のようなフォルダ構成のプロジェクトを作って下さい。

<pre class="source">
<font color="red">SampleGame</font> // プロジェクト名（好きな名前を入れて下さい）
  +- <font color="red">exe</font>   // 実際のゲームデータが全て入ります。
  +- <font color="red">ss</font>    // スクリプトファイルなどが入ります。
  +- <font color="red">tmp</font>   // スクリプトファイルをコンパイルするための中間ファイルが入ります。
  +- <font color="red">work</font>  // 作業フォルダです。セーブデータなどが保存されます。
</pre>

	次に、以下のようにファイルを配置してください。

<pre class="source">
SampleGame
  +- exe
  |   +- <font color="red">SiglusEngine.exe</font>     // 実行ファイル本体です。サンプルからコピーして下さい。
  |
  +- ss
  |   +- <font color="red">_start.ss</font>            // スタートシーンのスクリプトファイル。新規作成して下さい。
  |   +- <font color="red">_menu.ss</font>             // メニューシーンのスクリプトファイル。新規作成して下さい。
  |
  +- tmp
  |
  +- work
  |   +- <font color="red">SiglusDebugger3.dll</font>   // デバッグを行うためのライブラリです。サンプルからコピーして下さい。
  |
  +- <font color="red">SiglusCompiler.exe</font>       // コンパイラです。サンプルからコピーして下さい。
</pre>

+ シーンファイル（*.ss）を作る

	ゲームのメインとなるシーンファイルを作ります。
	ゲームのシナリオや流れは、全てシーンファイルに書くことになります。
	非常に重要なファイルです。

	ss フォルダ内に新規作成してください。
	拡張子は ss です。ファイル名は自由に設定できます。
	各 ss のことをシーンと呼びます。各シーンにはスクリプトを記述します。ss はシーンスクリプトの略です。

	ゲームは、"_start" というシーンから始まります。
	まずは、"_start.ss" を作りましょう。
	"_start.ss" をテキストエディタで開き、以下のように書き込みます。

<pre class="source">
#z00

こんにちは。r

owari
</pre>

<div class="table-container">
<table>
<tr><td>#z00</td><td>スクリプトの最初に必ず記述します。RealLive にあった #IN、#OUT は必要なくなりました。</td></tr>
<tr><td>こんにちは。</td><td>シナリオです。ゲーム画面に表示されます。</td></tr>
<tr><td>r</td><td>キーが入力されるまで待つ<font color="red">コマンド</font>です。</td></tr>
<tr><td>owari</td><td>ウィンドウを閉じ、ゲームを終了する<font color="red">コマンド</font>。</td></tr>
</table>
</div>

	スクリプトでは、大文字と小文字は区別されません。
	owari と OWARI は同じ意味となります。

	スクリプトは、単語や "" の最中でない限り、好きな箇所で改行を行うことができます。

	スクリプトは、基本的に「シナリオ」と「コマンド」から成ります。
	これらを組み合わせることで、ゲームを作っていきます。
	全コマンドについては、[[エレメント一覧]] を参照して下さい。
	（エレメントについては後述します。）

+ コンパイルを行う

	SiglusCompiler.exe を起動し、「新規プロジェクト」から以下の設定をします。

<div class="table-container">
<table>
<tr><td></td><td></td><td>例</td></tr>
<tr><td>プロジェクト名</td><td>好きな名前を設定して下さい。</td><td>サンプルゲーム</td></tr>
<tr><td>ss フォルダ</td><td>作成した ss フォルダを指定して下さい。</td><td>C:\SampleGame\ss</td></tr>
<tr><td>tmp フォルダ</td><td>作成した tmp フォルダを指定して下さい。</td><td>C:\SampleGame\tmp</td></tr>
<tr><td>出力フォルダ</td><td>作成した exe フォルダを指定して下さい。</td><td>C:\SampleGame\exe</td></tr>
<tr><td>実行ファイル</td><td>exe フォルダ内の SiglusEngine.exe を指定してください。</td><td>C:\SampleGame\exe\SiglusEngine.exe</td></tr>
<tr><td>作業フォルダ</td><td>作業フォルダを指定して下さい。</td><td>C:\SampleGame\work</td></tr>
<tr><td>エディタ</td><td>テキスト編集用のプログラムを指定して下さい。</td><td>C:\Program Files\sakura\sakura.exe</td></tr>
</table>
</div>

	自動設定を使うと便利です。（★ここに～ の欄に C:\SampleGame をドラッグ＆ドロップ）

	設定が終わったら「OK」ボタンを押し、設定ウィンドウを閉じます。

	左下の 「ss」リストに、_start.ss が表示されています。
	（されていない場合は、「再検索」ボタンを押して下さい。）

	「自動選択」ボタンを押します。先ほど作った「_start.ss」が選択されます。
	次に、「コンパイル」を押します。「全ての処理が正常に成功しました。」と表示されればコンパイル成功です。
	エラーが出た場合は、スクリプトを見直して下さい。

	コンパイルに成功した場合、exe フォルダに Gameexe.dat、Scene.pck というファイルが出来上がります。

+ ゲームを起動する

	「実行」というボタンを押すとゲームが起動します。
	「こんにちは。」と表示され、キーを押すとゲームが終了します。


■設定ファイル

<p>
ウィンドウサイズなど、ゲームの各種設定を行うファイルです。
ファイル名は "Gameexe.ini" 固定です。
</p>

<h4>設定ファイルを作る</h4>

<p>
ss フォルダの中に新規作成してください。
</p>

<pre class="source">
SampleGame
  +- exe
  |   +- SiglusEngine.exe
  |
  +- ss
  |   +- _start.ss
  |   +- _menu.ss
  |   +- <font color="red">Gameexe.ini          // 設定ファイル。新規作成して下さい。</font>
  |
  +- tmp
  |
  +- work
  |   +- SiglusDebugger3.dll
  |
  +- SiglusCompiler.exe
</pre>

<p>
Gameexe.ini をテキストエディタで開き、
試しに、以下のように書き込んでみます。
</p>

<pre class="source">
#SCREEN_SIZE = 1280, 720           // スクリーンサイズ
</pre>

<p>
作り終えたら、もう一度コンパイルを行って下さい。
exe フォルダに Gameexe.dat というファイルが出来上がります。
ゲームを起動してみましょう。ウィンドウサイズが大きくなっています。
</p>

<p>
なお、SCREEN_SIZE が設定されていない場合は、デフォルト値として 800×600 が使われます。
</p>

<p>
その他の設定に関しては、サンプルの Gameexe.ini を参照して下さい。
コメントつきで、全ての設定が使われています。
</p>


■シーンファイル

<h4>シーンの分け方</h4>

	ゲーム内のシナリオは、全てシナリオファイルに書きます。
	シナリオは、複数のシーンファイルに分けて書くのが普通です。
	シーン名は自由ですが、分かりやすい名前にしておきましょう。

<div class="table-container">
<table>
<caption>シーンファイル名の例</caption>
<tr><td>_start.ss</td><td>スタートシーン</td></tr>
<tr><td>_menu.ss</td><td>メニューシーン</td></tr>
<tr><td>_cancel.ss</td><td>キャンセルメニュー</td></tr>
<tr><td>_config.ss</td><td>環境設定画面</td></tr>
<tr><td>５月１４日.ss</td><td>５月１４日</td></tr>
<tr><td>５月１５日.ss</td><td>５月１５日</td></tr>
<tr><td>...</td><td></td></tr>
</table>
</div>

<h4>スタートシーンとメニューシーン</h4>

	ゲームには、「スタートシーン」、「メニューシーン」の２つのシーンが必須になります。
	それぞれ、"_start.ss"、"_menu.ss" という名前になります。

	スタートシーンは、「ゲーム起動時に呼ばれるシーン」です。
	ブランドロゴを表示したり、プロテクトのチェックを行ったりなど、
	起動時に１回だけ行うべき処理を入れます。

	メニューシーンは、returnmenu コマンドや、ユーザーがシステムメニューの「メニューに戻る」を選んだ時など、
	メニューに戻った時に最初に呼ばれるシーンです。
	通常は、ゲームのタイトルメニューを表示し、「ゲームスタート」「鑑賞モード」などのボタンを配置します。

<h4>各シーンを作る</h4>

<h5>_start.ss</h5>

<pre class="source">
#z00

ブランドロゴを表示します。r

// メニューシーンに戻ります。
returnmenu
</pre>

	スタートシーンでは、ブランドロゴを表示した後、
	returnmenu コマンドでメニューに戻ります。

<h5>_menu.ss</h5>

<pre class="source">
#z00

// 選択肢を表示します。
a[0] = sel("ゲームを始める", "ゲームを終わる")

// 選択結果によって、処理を分岐します。
switch (a[0])   {
    case (0)  jump("５月１４日")  // ５月１４日.ss にジャンプします。
    case (1)  owari               // ゲームを終了します。
}
</pre>

	メニュー画面では、sel コマンドを使って選択肢を表示しています。
	選んだ結果によって、"５月１４日.ss" に飛ぶか、またはゲームを終了しています。

<h5>５月１４日.ss</h5>

<pre class="source">
#z00

５月１４日の朝です。r
ゲームを終了します。r

// メニューシーンに戻ります。
returnmenu
</pre>

	ゲーム本編です。
	ゲーム終了後、returnmenu コマンドでメニューに戻ります。


■ シナリオの例

<h4>シナリオの例</h4>

<h5>５月１４日.ss</h5>

<pre class="source">
#z00

// *************************************************************
// ５月１４日
// =============================================================

夢を見ていた。r
僕はその内容を思い出すまいと、窓の外に視線を向け、グラウンドで行われているサッカーの試合に見入った。r
いつものことだ。r
意識を失うようにして突然僕が寝入ってしまうことは。r
それは、幼い頃から僕が抱えている病気。r
ナルコレプシー…pp眠り病だ。r
教師からも黙認されている。r
この病気に対する理解は学校側にもあるし、それで僕が成績を落とすようなこともないからだ。r
でも、今の状態には少し違和感があった。r
僕が昼に見る夢は決まって悪夢だ。r
だから絶対に思い出さないようにしている。r
だけど、今見ていた夢は思い出そうにも、思い出せない…そんな気がした。r
僕は…果たして夢を見ていたのだろうか？r

【真人】「どうした、暗い顔して」r
隣の真人が話しかけてくる。r
【理樹】「いや、べつになにも」r
【真人】「水くさい奴だな。筋肉の相談ならいつでも乗るぜ？」r
【理樹】「いや、それについては一生悩まないから」r
</pre>

	スクリプトで文字列を書くと、メッセージとして画面に表示されます。
	改行、インデント処理などは、プログラムが自動が行ってくれるので、意識する必要はありません。

	<font color="red">１つのメッセージは１行で書いて下さい。</font>
	複数行に分けてしまうと、声撮りツールが正常に動かなくなります。

	名前は【】で括って下さい。同じく声撮りツールに必須です。

	文末にある r は、キー待ちを行うための「コマンド」です。必ずつけて下さい。
	自動で r をつけるツールもあります。上手く使って下さい。

<pre class="exp">
◇開発環境ディスク\◇Siglus\ツール\◇シナリオ関係ツール\put_r.exe
</pre>


■ コメント

+ コメント

	シーン内にコメントを記述できます。
	コメントはゲームには影響しません。
	スクリプトを分かりやすくするために記述して下さい。

<div class="table-container">
<table>
|//|行コメント|
|/* ～ */|ブロックコメント|
</table>
</div>

+ コメントの例

<pre class="source">
ここはコメントではありません。 // ここはコメントです。
<span class="comment">/* 
ここはコメントです。
 */</span>
</pre>

	上のスクリプトで、緑色の部分はコメントとなり、無視されます。

<pre class="source">
<span class="comment">/*
ここはコメントではありません。 /* ここはコメントです。 */</span>
ここはコメントではありません。（コメントは入れ子にはできない）
 */
</pre>

	ブロックコメントは入れ子にはできません。
	上の例は、最後の */ の部分でコンパイルエラーになります。


■ 文章を表示する

<pre class="source">
夢を見ていた。r
僕はその内容を思い出すまいと、窓の外に視線を向け、グラウンドで行われているサッカーの試合に見入った。r
いつものことだ。r
</pre>

	全角で文章を書くと「メッセージ」になり、
	「メッセージウィンドウ」にそのまま表示されます。

	文章を書くときの注意事項が [[シナリオの例]] に書いてありますので、ご一読下さい。




■ 半角文字を表示する

	半角文字列は "" でくくります。

<pre class="source">
「<font color="red">&quot;Hello! Siglus&quot;</font>」r
</pre>

<pre class="result">
「<font color="red">Hello! Siglus</font>」
</pre>

<h4>半角の &quot; や &yen; を表示する</h4>

	&quot;&quot; の中で &yen; を表示するには「&yen;&yen;」、ダブルコーテーションを表示するには「&yen;&quot;」とします。

<pre class="source">
&quot;<font color="red">&yen;&quot;</font>medical herb<font color="red">&yen;&quot;</font> は <font color="red">&yen;&yen;</font>1,000 になります。&quot;r
</pre>

<pre class="result">
<font color="red">"</font>medical herb<font color="red">"</font> は <font color="red">&yen;</font>1,000 になります。
</pre>



■ 自動改行／禁則処理／インデント

<h4>自動改行</h4>

<pre class="source">
あいうえおかきくけこさしすせそたちつてとなにぬねのr
</pre>
<pre class="result">
あいうえおかきくけこさしすせそ
たちつてとなにぬねの
</pre>

	メッセージは、メッセージウィンドウの幅に合わせて自動的に改行されます。
	改行するためのコマンド（nl、nli）もありますが、これを利用して文章を整形する事はあまりお勧めしません。とても時間のかかる作業です。

<h4>禁則処理</h4>

<pre class="source">
あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほ…まみむめもr
</pre>

<pre class="result">
あいうえおかきくけこさしすせそ
たちつてとなにぬねのはひふへほ…　// ←禁則処理が働きました
まみむめも
</pre>

	メッセージは、メッセージウィンドウの幅に合わせて自動的に改行されますが、
	下記の「禁則文字」の場合、改行せず「１文字分だけ余分に表示する」ようになっています。
	この動作を禁則処理と言います。

<h5>禁則文字</h5>

<pre class="p">
。、！？：；」』）】｝］〉》”’〟
～ー…‥・．，゛゜
ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ
ﾞﾟ｡､!?:;｣)]>}'&quot;ｰ･.,ｧｨｩｪｫｯｬｭｮ
</pre>

	※半角は２文字禁則処理されます。（!!、?! など）

<h4>インデント</h4>

<pre class="source">
「あいうえおかきくけこさしすせそたちつてとなにぬねの」r
</pre>
<pre class="result">
「あいうえおかきくけこさしすせそ
□たちつてとなにぬねの」

// ↑１文字分のスペースが空きました
</pre>

	シナリオの台詞に、１文字分スペースを空けて、文頭をそろえられます。
	この処理をインデント処理と言います。

<h5>インデントされる文字</h5>

<pre class="p">
「『（
</pre>

<h4>インデント後の全角スペース</h4>

	インデント後の全角スペースは無視されます。

<pre class="source">
「あいうえお？　かきくけこ？　さしすせそ？　たちつてと？　なにぬねの？」r
</pre>
<pre class="result">
「あいうえお？　かきくけこ？　さしすせそ？
□たちつてと？　なにぬねの？」

// ↑全角スペースが無視されました。空いているのはインデントのスペースです。
</pre>


■ オーバーフロー

<pre class="source">
あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもがぎぐげござじずぜぞだぢづでどr
</pre>

<pre class="result">
あいうえおかきくけこさしすせそ
たちつてとなにぬねのはひふへほ
まみむめもがぎぐげござじずぜぞ　// ←ここでキー待ち

だぢづでど
</pre>

	メッセージが長すぎてメッセージウィンドウの縦幅をオーバーした場合、オーバーフローになります。
	オーバーフローした場合は、そこで文章を中断し、自動的にキー待ちを行います。その後、残りの文章を表示します。
	オーバーフローすると１つの文章が２つに分断されるので、格好悪いです。
	シナリオの文章を修正し、調整して下さい。



■ 名前を表示する

<h4>名前を表示する</h4>

	名前は【】で括ります。<font color="red">声撮りなどのために必須ですなので、必ず守ってください。</font>

<pre class="source">
【ちはや】「コマーシャルって…何ですか」r
【瑚太朗】「テレビなんかで番組の合間に宣伝流してるだろう。アレのことだ。そんなことも知らないのかちはやは」r
</pre>

<pre class="result">
ちはや
「コマーシャルって…何ですか」

瑚太朗
「テレビなんかで番組の合間に宣伝流してるだろう。アレのことだ。そんなことも知らないのかちはやは」
</pre>



■ 名前を伏せる

	【？？】など、本来とは違う名前をつける場合は注意が必要です。
	名前は、声撮りや「キャラクターごとにメッセージの色を変える」機能などに必要です。
	ところが、【？？】では、誰の声か分からず、これらの機能が上手く働きません。

	解決するためには、設定ファイルに名前を登録する必要があります。

++ 設定ファイル

<pre class="source">
// *************************************************************
// ■【名前】の登録
// =============================================================
#NAMAE = "？？＿小鳥", "？？"
#NAMAE = "？？＿朱音", "？？"
</pre>

++ シーンファイル

<pre class="source">
【？？＿小鳥】「あ、なんかわかった気がするよ」r
【？？＿朱音】「せっかくだから付き合ってあげなさい」r
</pre>

<pre class="result">
？？
「あ、なんかわかった気がするよ」

？？
「せっかくだから付き合ってあげなさい」
</pre>

	設定ファイルに &quot;？？＿小鳥&quot;、&quot;？？＿朱音&quot; を登録し、
	変換名を &quot;？？&quot; に設定します。

	どちらも「？？」と表示されますが、
	声撮りツールや「キャラクターごとにメッセージの色を変える」機能などが正常に働きます。

	名前の登録し忘れがあったら大変です。
	[[名前一覧を確認する]] で、使われている名前、登録されている名前が確認できます。
	有効に使って下さい。



■ 名前ごとにメッセージの色を変える

	【名前】を登録することで、名前ごとに自動でメッセージの色を変更することができます。

	詳しくは [[【名前】の設定]] を参照して下さい。



■ 名前一覧を確認する

	デバッグメニューの 「ｳｨﾝﾄﾞｳ」→「【名前】情報」から、使用されている名前一覧が確認できます。

	「★未登録」と表示された名前があった場合は要注意です。

<div align="center">
<img src="../../../img/namae_info_wnd.png">
</div>





■画像を表示する

<h4>オブジェクトを用いて画像を表示する</h4>

	画面に画像を表示するには、<font color="red">オブジェクト</font> を使います。
	オブジェクトは、デフォルトで 000～099 まで（合計 100 個）あります。（Gameexe.ini で設定できます。）

	番号の若いものほど奥に表示されます。（レイヤー値を変えることで変更できます。）
	例えば、オブジェクト１番はオブジェクト０番よりも前に表示されます。
	それを考慮して、あらかじめどのオブジェクトに何を割り当てるかを決めておくと便利です。

<div class="table-container">
<table>
<caption>オブジェクトの割り当て例</caption>
|object[00]|背景|
|object[10]|バストショット１|
|object[11]|バストショット２|
|object[12]|バストショット３|
|object[20]|汗、ため息などのエモーション１|
|object[21]|汗、ため息などのエモーション２|
|object[22]|汗、ため息などのエモーション３|
|object[30]|日付|
</table>
</div>

<pre class="source">
// オブジェクト０番に背景画像 "BG001" を読み込み、表示します。
front.object[00].create(BG001, 1)

背景を表示しました。r

// オブジェクト１０番にバストショット画像 "BS0101" を読み込み
// 画面左 (x, y) = (-300, 0) に表示します。
front.object[10].create(BS0101, 1, -300, 0)

バストショットを左に表示しました。r

// オブジェクト１０番にバストショット画像 "BS0201" を読み込み、表示します。
// 画面右 (x, y) = (300, 0) に表示します。
front.object[11].create(BS0201, 1, 300, 0)

バストショットを右に表示しました。r
</pre>

	オブジェクトに画像を読み込むには、create <font color="red">コマンド</font> を使います。
	オブジェクト０番に画像を読み込むには、front.object[0].create の用に指定します。

	"BG001" は読み込む画像のファイル名で、続く "1" は、「画像を表示する」ことを表します。
	コマンドの後ろに続く値を <font color="red">引数</font> と呼びます。


■ ワイプを行う

+ ワイプを行う

	「現在表示されている画面」を、<font color="red">フロントステージ</font> と言います。
	フロントステージは front で表します。
	前章では front.object に画像を読み込んでいたので、すぐに表示されていました。

	徐々に画面を切り替えるには、<font color="red">バックステージ</font> に画像を読み込み、ワイプを行う必要があります。
	バックステージは back で表します。

	ワイプを行うと、バックステージのデータはフロントステージにコピーされ、
	バックステージは初期化されます。

<pre class="source">
// バックステージに画像 BG001 を準備する
// ここではまだ画面には表示されません。
back.object[00].create(BG001, 1)

背景を準備しました。r

// 1000ﾐﾘ秒かけてワイプを行う
// ワイプの種類は０番（クロスフェード）
// オブジェクトはフロントステージにコピーされ、
// バックステージは初期化されます。
wipe(0, 1000)

ワイプを使って背景を表示しました。r

// バックステージに画像 BG001、BS0101 を準備する
back.object[00].create(BG001, 1)
back.object[10].create(BS0101, 1)

背景とバストショットを準備しました。r

// 1000ﾐﾘ秒かけてワイプを行う
// ワイプの種類は０番（クロスフェード）
wipe(0, 1000)

ワイプを使って背景とバストショットを表示しました。r
</pre>

	ワイプを行うには、wipe コマンドを使います。
	１つ目の引数にはワイプ番号を指定します。0 を指定すると「クロスフェード」になります。
	２つ目の引数にはワイプ時間をﾐﾘ秒で指定します。1000 を指定すると、1000ﾐﾘ秒 = 1秒 でワイプが行われます。

	ワイプ番号については、サンプルの「ワイプライブラリ」を参照して下さい。

++ ワイプ時間についての補足

	このサンプルでは、分かりやすくするためにワイプ時間を 1000ﾐﾘ秒 にしています。
	実際は、250ﾐﾘ秒 くらいが丁度いいと思います。




■ 音を再生する

+ ＢＧＭを再生する

	ＢＧＭを再生するには、設定ファイルにＢＧＭを登録する必要があります。
	登録方法については [[ＢＧＭの設定]] を参照して下さい。

	ＢＧＭを再生するには、bgm を使います。

<pre class="source">
bgm.play("朝")
</pre>

	bgm.play コマンドには、ファイル名ではなく「設定ファイルでの登録名」を指定することに注意して下さい。

+ 効果音を再生する

	効果音を再生するには、pcm を使います。

<pre class="source">
pcm.play(fanfare)
</pre>

	fanfare.wav を再生しています。

+ システムを音を再生する

	システム音は、スクリプトで再生するものではありません。
	選択肢を選んだときや、セーブを行ったときなどに、自動的に鳴る音です。

	システム音は、設定ファイルに登録します。
	登録方法については [[システム音の設定]] を参照して下さい。

	自力制御のメニューを作った場合などは、スクリプトでシステム音を再生することもあります。
	その場合は、se を使います。

<pre class="source">
se.play(0)
</pre>

	se.play コマンドには、ファイル名ではなく「設定ファイルでの登録番号」を指定することに注意して下さい。




■ マウスカーソルを設定する

	マウスカーソルは、通常の画像と同じように g00 で作成します。

+ マウスカーソルの設定

	[g00] フォルダに入れ、設定ファイルで登録して下さい。
	登録、設定については [[マウスカーソルの設定]] を参照して下さい。

<ul>
- マウスカーソルの大きさは 32×32 固定です。
- 半透明の画像に対応しました。アンチのかかったマウスカーソルも作れます。（2010/9/21 Ver.1.0.2.0）
- g00 画像の中心座標がホットスポットになります。ホットスポットとは、マウスカーソルの矢印の先端の座標です。
- g00 に複数のカットを入れると、カット順にマウスカーソルをアニメーションさせることもできます。
</ul>



■ ウィンドウアイコンを設定する

	Siglus では、32bitカラー、半透明、フリーサイズのアイコンを扱えるようになりました。
	また、マルチプルアイコン（１つのアイコンファイルに複数のアイコンが入ってる形式）にも対応しました。
	Vista や 7 と新しいＯＳに備えて、出来る限り多色多サイズのアイコン作成をお勧めします。

<h4>お勧めのアイコンの組み合わせ</h4>

	以下の４つの形式を含むアイコンがお勧めです。

<ul>
<li>[ ※推奨 ] 256×256、32bitカラー（Vista / 7 の最大サイズです）</li>
<li><font color="red">[ ※必須 ] </font>48×48、32bitカラー（Vista / 7 の標準サイズです）</li>
<li><font color="red">[ ※必須 ] </font>32×32、32bitカラー（XP の「大きいアイコン」です。7 のタスクバーにも表示されます）</li>
<li><font color="red">[ ※必須 ] </font>16×16、32bitカラー（XP の「小さいアイコン」です。ウィンドウの左上に表示されるのもこれです）</li>
</ul>

	マルチプルアイコンは、フリーソフトで作ることができます。私は「@icon変換」というフリーソフトを使っています。

	48×48 を入れ忘れないで下さい。XP を使っていると気づきにくいですが、Vista 以降だと非常に重要です。

	アイコンの並びは、小さいサイズのものから順に並べて下さい。

	異なる色数のアイコン（8bit と 32bit など）が混ざっていると、正常に表示されない場合があります。必ず 32bit で統一して下さい。

<h4>対応していないアイコン</h4>

<ul>
<li>ビットマップフォーマットのアイコン</li>
</ul>

	ビットマップの拡張子を .ico にしただけのファイルが、ビットマップフォーマットのアイコンです。
	バイナリエディタで開いた時に、先頭2バイトが 42 4D になっています。
	一方、通常のアイコンファイルは、先頭4バイトが 00 00 01 00 です。

	アイコンエディタで普通に作れば、正しいアイコンファイルが作られると思います。

<h4>アイコンの設定</h4>

	ファイル名は好きに設定できます。

	SiglusEngine.exe の隣に置いて下さい。自動的にアイコンが設定されます。

<pre class="source">
SampleGame
  +- exe
  |   +- SiglusEngine.exe
  |   +- <font color="red">SampleGame.ico        // 設定されるアイコンファイルです。ファイル名は好きに設定できます。</font>
  |
  +- ss
  |   +- _start.ss
  |   +- _menu.ss
  |   +- Gameexe.ini
  |
  +- tmp
  |
  +- work
  |   +- SiglusDebugger3.dll
  |
  +- SiglusCompiler.exe
</pre>



■ エンジンを暗号化する

+ エンジンを暗号化する

	製品として販売するタイトルは、必ず暗号化して下さい。
	コピープロテクトを施した製品に、プロテクトのかかっていない同じ暗号の SiglusEngine.exe をコピーすると、普通に動作してしまいます。
	また、製品版の修正パッチを出したとき、「体験版に」「製品版の修正パッチを当てる」ことで、無料で全てのシナリオが読めてしまうことがあります。
	（組み方にもよります。通常は、ファイルエラーなどが出まくるのでゲームにならないと思います。）

	暗号はタイトルごとに必ず変えて下さい。

	無料配布する体験版などは暗号化する必要はありません。しても問題はないですが、製品版とは異なる暗号にして下さい。

<div class="chips">
(2011/9/14) プロテクトをかけないタイトルについても、暗号化が必須になりました。
</div>

++ Scene.pck の暗号化

	ss フォルダに「暗号.dat」を作成してコンパイルすると、Scene.pck が暗号化されます。
	詳しくは、コンパイラの上部メニューから「暗号化」→「暗号化についての説明」を参照して下さい。

++ SiglusEngine.exe の暗号化

	コンパイラを使って暗号化できます。
	詳しくは、コンパイラの上部メニューから「暗号化」→「暗号化についての説明」を参照して下さい。

+ プロテクトをかける

	発売するタイトルにはプロテクトをかけることを推奨しています。
	詳しくは開発環境ディスクの「コピープロテクト導入の流れ」を参照して下さい。

<pre class="exp">
◇開発環境ディスク\コピープロテクト導入の流れ
</pre>


■ 素材について

	作らなければならない素材はいっぱいあります。

<ul>
- 画像
- ポリゴン（※実装中）
- ＢＧＭ、効果音、システム音
- 音声
- ムービー
- ウィンドウアイコン
- マウスカーソル
- HTMLマニュアル
- …
</ul>

	その他にも、色々なデータに対応しています。

<ul>
- トーンカーブ
- ＣＧテーブル
- …
</ul>


■ ファイル名について

+ ファイル名について

	半角英数字（"a" ～ "z"、"A" ～ "Z"、"0" ～ "9"）と "_" のみにして下さい。
	また、頭に数字のつくファイル名は使用しないで下さい。

++ ダメな例

<ul>
- $bg001.g00（使えない記号が入っている）
- 背景００１.g00（全角文字が入っている）
- 100win.g00（数字で始まっている）
</ul>

++ 良い例

<ul>
- ABC000.g00
- op_012.g00
- _10000.g00
- x0x0x0.g00
</ul>


■ 画像について

	[exe] フォルダ内に [g00] というフォルダを作り、その中に入れて下さい。

+ 画像サイズの制限について

	Siglus では、最大で2048×2048までの画像しか使うことができません。
	大きい画像を扱う場合は、上手く分割して下さい。

+ 対応形式

	g00、bmp、png、dds

	※jpg には対応していません。

	※pdt（旧AVG形式）には対応していません。

++ g00

	VisualArt's 独自の形式です。通常はこれを使ってください。
	フォトショップで作成した psd データを元に、G00Pack.exe でコンバートして作成します。
	また、G00Lib.exe で画像を確認できます。

	詳しくは、G00Pack.exe のマニュアルを参照して下さい。

++ bmp、png

	ペイントなどで手軽に作れますが、誰でも簡単に中身が見えてしまいます。
	また、種類によりサイズが大きい、読み込みが遅い、画質が劣化する、カットデータが使えない、などの欠点もあります。
	製品では極力使わないで下さい。

++ dds

	DirectX に特化した画像です。
	こちらも、DirectX に付属の専用のツールを使えば中身が見えるので、製品では使わないで下さい。


■ 音について

	Siglus では、「ＢＧＭ」、「音声」、「効果音」、「システム音」の４種類の音が扱えます。
	[exe] フォルダ内に [bgm] [koe] [wav] というフォルダを作り、その中に入れて下さい。

<div class="table-container">
<table>
<caption>音の種類と保存するフォルダ</caption>
<tr><td>ＢＧＭ</td><td>[bgm]</td></tr>
<tr><td>音声</td><td>[koe]</td></tr>
<tr><td>効果音、システム音</td><td>[wav]</td></tr>
</table>
</div>

	「効果音」は、爆発や足音など、ゲーム中の演出に使います。
	「システム音」は、ボタンの選択音や、セーブ音に使います。

+ 対応形式

	nwa、wav、ogg<br />ｽﾃﾚｵ/ﾓﾉﾗﾙ、22050/44010kHz、16bit

	※8bit、24bit には対応していません。<br />11025kHz、48000kHz には対応していません。

++ nwa

	独自形式です。通常はこれを使ってください。
	NWAPack.exe を使って、wav から作成できます。
	また、NWALib.exe を使って、音を確認できます。

++ wav、ogg

	手軽に作れますが、誰でも簡単に中身が聴けてしまいます。
	製品では使わないことをオススメしますが、
	Web 上で配布する体験版など、容量を小さくしたいときは ogg を使っても構いません。

	ogg 変換ツールは、フリーソフトがありますので、ウェブから入手して下さい。
	私の知っているものでは「oggdropXPd.exe」と言うものがあります。

+ DirectSound の音質について

	Siglus では、DirectSound を用いて音を再生しています。
	推奨は 44100kHz / 16bit です。その他のフォーマットも、44100kHz / 16bit に変換されて再生されます。

+ CD-DA について

	Siglus は CD-DA には対応していません。



■ 音声について

	声は基本的に、弊社の手順にのっとって作成する事になります。
	ss スクリプトから台本を作成し、その台本元に弊社の録音システムを使い録音します。

	録音された音声は全て wav ファイルになっています。
	録音が終わればまずは、音声加工用のツールで前後の無音部分のカッティングや音量調整などを行います。
	最終的にはツールでは取りきれないノイズの除去や音量の調整及び効果加工などを行います。
	その後、音声圧縮ツール (NWKpack.exe / OVKpack.exe) で圧縮し完成となります。

	声を再生するスクリプト命令も自動で挿入するツールが用意されております。
	独自の録音作業環境で録音する事も不可能ではありませんが、たいへんな労力となりますので、あまりお勧めできません。

	※実際には声優さんの手配やオーディション資料の作成、スケジュール調整などやらなければならない事はたくさんあります。

+ 対応形式

	ovk（nwk については未対応）


■ ムービーについて

	[exe] フォルダ内に [mov] というフォルダを作り、その中に入れてください。

	ムービーのサイズは自由ですが、ウィンドウサイズと違うサイズのムービーを再生した場合、
	ウィンドウサイズに引き伸ばされます。
	ゲーム画面と同じサイズで作成すると、綺麗に表示されます。

+ 対応状況

	avi、mpg、wmv に対応していますが、内部形式によってはコーデックが必要となってしまいます。
	独自形式はまだありません。

	mpg が最も安定していて、お勧めです。
	wmv にすると高品質に出来ますが、処理が重たくなってしまいます。
	特に 1280×720 などの高解像度にした場合、ノートＰＣなどで再生が追いつかないことがあります。
	実際に古いマシンで再生し、違いを見比べて下さい。

<div class="table-container">
<table>
<tr><td></td><td>映像コーデック</td><td>音声コーデック</td>
<tr><td>対応</td><td>

<ul class="td">
<li>mpeg-1</li>
<li>wmv9</li>
</ul>

</td><td>

<ul class="td">
<li>mpeg-1</li>
<li>wma9.1</li>

</td></tr>
<tr><td>未対応</td><td>

<ul class="td">
<li>Indeo Video</li>
<li>mpeg-2</li>
<li>wmv9 Advanced Profile</li>
<li>wmv10</li>
<li>wmv11</li>
</ul>

</td><td>

<ul class="td">
<li>Indeo Audio</li>
</ul>

</td></tr>
</table>
</div>




■ その他の素材について

+ ＣＧテーブル

	画像を表示した際、自動的に「見た／まだ見てない」のフラグを制御する為のテーブルデータ。

+ トーンカーブ

	画像を読み込んだ際、トーンカーブ補正する事で夕方っぽくしたり、夜っぽくしたりする為のデータ。

+ ３Ｄモデル

	３Ｄモデルについては、まだコマンドが十分に実装されておりません。
	そのため、現時点では使い物にならないです。

<font class="mada">

	３Ｄ用のモデルファイルです。
	[exe] フォルダ内に [x] というフォルダを作り、その中に入れてください。
	また、テクスチャについても同様に [x] フォルダに入れてください。

+ 対応形式

	x

+ x

	メタセコイア、六角大王、LightWave など、ほとんどの３Ｄモデリングツールで出力することができます。
	Siglus では Direct3D を使っているので、出力時に、座標系を「Direct3D」（または左手座標系）に設定してください。
	また、「左右を反転する」などの項目がある場合はチェックを入れてください。

+ 対応状況

	以下のものに対応しています。

<ul>
- テクスチャマッピング
- スキンメッシュ
- アニメーション
</ul>

</font>


■ デバッグ設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■デバッグ設定
// =============================================================
#DEBUG_ERROR_PATNO_OUT_OF_RANGE = 0     // パターン番号エラー
</pre>

	<font color="red">これらはデバッグ用の設定です。リリース時は無視されます。</font>

++ #DEBUG_ERROR_PATNO_OUT_OF_RANGE

	オブジェクトのパターン番号が不正なときのエラー表示方法を指定します。
	0=表示しない、1=エラーログに出力、2=エラーボックスを表示

	本来は、パターン番号の不正はエラーではありませんので、0 にして下さい。
	ゲームの仕様上、パターン番号が重要な場合に 1 もしくは 2 に設定して下さい。

	ボタンアクションなど一部の操作によっては、エラーが出ないこともあります。
	あくまで補助機能として使って下さい。





■ 初期設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■初期設定
// =============================================================
#DISCMARK = "SampleProject.env"         // ディスク認識ファイルのファイル名
#GAMENAME = "サンプルプロジェクト"      // キャプションなどに表示されるゲーム名
#GAMEVERSION = "Ver.1.0"                // ゲーム名のバージョン情報
#MANUAL_PATH = "manual\\index.html"     // マニュアルへのパス
#SCREEN_SIZE = 1280, 720                // スクリーンサイズ
</pre>

++ #DISCMARK

	ゲームディスクを認識する env ファイルを設定します。
	開発環境の「◇セットアップ環境」を参考に、ここで指定したファイルを環境に入れて下さい。
	ダミファイルチェックなどに使うため、ファイル名はゲーム固有のものにして下さい。（例：Rewrite.env など）

	ダウンロード用の体験版など、ディスクが存在しない場合は書く必要はありません。
	（書いてあっても問題はありません。）

++ #GAMENAME

	ゲーム名を指定して下さい。
	ゲーム名は、ウィンドウキャプションに表示されます。

++ #GAMEVERSION

	ゲームのバージョンを指定して下さい。
	バージョンは、システムコマンドメニューの「バージョン情報」や、環境設定ダイアログに表示されます。

++ #MANUAL_PATH

	マニュアルのパスを指定して下さい。
	マニュアルは、システムコマンドメニューの「マニュアルを開く」から呼び出されます。

	&yen; は &yen;&yen; と表記することに注意して下さい。

++ #SCREEN_SIZE

	ゲームウィンドウのサイズを指定します。
	「800, 600」、「1280, 720」などが一般的です。



■ ダミーファイルの設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ダミーファイルの設定
// =============================================================
#DUMMY_CHECK_STR    = "（ゲーム名）のディスクを入れてください。\\n\\n※プロテクトの誤認識ではありません。"
#DUMMY_CHECK_OK_STR = "この度は（ゲーム名）をお買い上げいただき、ありがとうございます。"
</pre>

	ダミーファイルの設定をします。
	詳しくは [[ダミーファイル]] を参照して下さい。

	プロテクト有りのゲームの場合、プロテクトの誤認識と区別する為、メッセージを工夫して下さい。

++ プロテクト有りの場合

    "（ゲーム名）のゲームディスクを入れてください。\\n\\n※プロテクトの誤認識ではありません。"

++ プロテクト無しの場合

    "（ゲーム名）のゲームディスクを入れてください。"



■ シーンの設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■シーンの設定
// =============================================================
#START_SCENE = "_start", 00             // スタートシーン
#MENU_SCENE = "_menu", 00               // メニューシーン
#CANCEL_SCENE = "_cancel", 00           // キャンセルシーン
#CONFIG_SCENE = "_config", 00           // 環境設定シーン
#SAVE_SCENE = "_save", 00               // セーブシーン
#LOAD_SCENE = "_load", 00               // ロードシーン
</pre>

	各種シーン名を設定します。

++ #START_SCENE

	スタートシーンです。ゲーム開始時に一度だけ呼ばれます。
	シーン名とＺラベル番号を指定します。
	省略した場合、_start.ss がスタートシーンになります。

++ #MENU_SCENE

	メニューシーンです。returnmenu コマンドや、システムコマンドメニューの「タイトルに戻る」から呼ばれます。
	シーン名とＺラベル番号を指定します。
	省略した場合、_menu.ss がスタートシーンになります。

++ #CANCEL_SCENE

	キャンセルシーンです。ゲーム中に右クリックされたときに呼ばれます。
	シーン名とＺラベル番号を指定します。
	省略した場合、システムコマンドメニューが表示されます。

++ #CONFIG_SCENE

	環境設定シーンです。システムコマンドメニューの「環境設定」などから呼ばれます。
	シーン名とＺラベル番号を指定します。
	省略した場合、環境設定ダイアログが表示されます。

++ #SAVE_SCENE

	セーブシーンです。システムコマンドメニューの「セーブ」などから呼ばれます。
	シーン名とＺラベル番号を指定します。
	省略した場合、セーブダイアログが表示されます。

++ #LOAD_SCENE

	ロードシーンです。システムコマンドメニューの「ロード」などから呼ばれます。
	シーン名とＺラベル番号を指定します。
	省略した場合、ロードダイアログが表示されます。













■ マウスカーソルの設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■マウスカーソルの登録
// =============================================================
#MOUSE_CURSOR.CNT = 1

// -------------------------------------------------------------
#MOUSE_CURSOR.000.FILE = "_MCUR00"    // ファイル名
#MOUSE_CURSOR.000.SPEED = 100         // アニメスピード（ﾐﾘ秒で指定）

// *************************************************************
// ■マウスカーソルの設定
// =============================================================
#MOUSE_CURSOR.DEFAULT = 0
</pre>

	マウスカーソルを設定します。

	マウスカーソルの作り方については [[マウスカーソルを設定する]] を参照して下さい。

+ #MOUSE_CURSOR.CNT

	登録するマウスカーソルの個数を指定します。
	現バージョンでは、２つ以上登録しても意味はありません。

+ #MOUSE_CURSOR.???.FILE

	マウスカーソルに使う g00 のファイル名を指定します。

+ #MOUSE_CURSOR.???.SPEED

	マウスカーソルのアニメーションスピードを設定します。
	値＝１コマにかける時間（ﾐﾘ秒）になります。
	値が大きいほど遅くなります。

+ #MOUSE_CURSOR.DEFAULT

	デフォルトで使うマウスカーソルの番号を指定します。
	-1 を設定すると、Windows のデフォルトのカーソルが使われます。





■ システムコマンドメニューの設定

	右クリックで呼び出されるシステムコマンドメニューの設定を行います。

+ システムコマンドメニューの設定（基本項目）

++ 設定ファイル

<pre class="source">
// *************************************************************
// ■システムコマンドメニュー（右クリックメニュー）の設定
// =============================================================
#SYSCOMMENU.READ_SKIP   = 1, 1, "既読文章を早送り"    // 一度読んだ文章の早送りを開始します。
#SYSCOMMENU.UNREAD_SKIP = 1, 1, "文章を早送り"        // 未読の文章でも早送りを開始します。
#SYSCOMMENU.AUTO_SKIP   = 1, 1, "自動早送り"          // 自動早送り機能をＯＮ／ＯＦＦします。
#SYSCOMMENU.AUTO_MODE   = 1, 1, "オートモード"        // オートモードを開始します。
#SYSCOMMENU.HIDE_MWND   = 1, 1, "ウィンドウを消す"    // メッセージウィンドウを一時的に消去します。
// =============================================================
#SYSCOMMENU.SAVE        = 1, 1, "セーブ"              // セーブを呼び出します。
#SYSCOMMENU.LOAD        = 1, 1, "ロード"              // ロードを呼び出します。
#SYSCOMMENU.RETURN_SEL  = 1, 1, "前の選択肢に戻る"    // 前の選択肢に戻ります。
// =============================================================
#SYSCOMMENU.CONFIG      = 1, 1, "環境設定"            // 環境設定を呼び出します。
#SYSCOMMENU.MANUAL      = 1, 1, "マニュアルを開く"    // マニュアルを表示します。
#SYSCOMMENU.VERSION     = 1, 1, "バージョン情報"      // バージョン情報を表示します。
// =============================================================
#SYSCOMMENU.RETURN_MENU = 1, 1, "タイトルに戻る"      // タイトルメニューに戻ります。
#SYSCOMMENU.GAME_END    = 1, 1, "ゲームを終了する"    // ゲームを終了します。
#SYSCOMMENU.CANCEL      = 1, 1, "キャンセル"          // システムコマンドメニューをキャンセルします。
</pre>

++ #SYSCOMMENU.??? = [無し／有り], [無効／有効], [文字列]

	無し／有り：0=無し 1=有り（存在の有無）<br />
	ゲームの起動時、及びタイトルメニューに戻った際の初期状態です。スクリプト命令で変更可能です。

	無効／有効：0=無効 1=有効（グレー表示）<br />
	ゲームの起動時、及びタイトルメニューに戻った際の初期状態です。スクリプト命令で変更可能です。

	文字列：項目の文字列

++ #SYSCOMMENU.READ_SKIP

	環境設定の「未読の文章も早送りできるようにする。」が無効の場合に表示されます。

++ #SYSCOMMENU.UNREAD_SKIP

	環境設定の「未読の文章も早送りできるようにする。」が有効の場合に表示されます。

++ #SYSCOMMENU.SAVE

	#SAVE_SCENE が設定されている場合は、そのシーンを呼び出します。設定されていない場合は、セーブダイアログを表示します。

++ #SYSCOMMENU.LOAD

	#LOAD_SCENE が設定されている場合は、そのシーンを呼び出します。設定されていない場合は、セーブダイアログを表示します。

++ #SYSCOMMENU.CONFIG

	#CONFIG_SCENE が設定されている場合は、そのシーンを呼び出します。設定されていない場合は、セーブダイアログを表示します。

++ #SYSCOMMENU.MANUAL

	マニュアルへのパスは #MANUAL_PATH で設定して下さい。

++ #SYSCOMMENU.VERSION

	バージョン情報は #GAMEVERSION で設定して下さい。

+ システムコマンドメニューの設定（ローカル汎用スイッチ）

++ 設定ファイル

<pre class="source">
// *************************************************************
// ■システムコマンドメニュー（右クリックメニュー）のローカル汎用スイッチの設定
// =============================================================
#SYSCOMMENU.LOCAL_EXTRA_SWITCH.000 = 1, 1, 1, "ローカル汎用スイッチ０番"   // ローカル汎用スイッチ０番
#SYSCOMMENU.LOCAL_EXTRA_SWITCH.001 = 1, 1, 1, "ローカル汎用スイッチ１番"   // ローカル汎用スイッチ１番
#SYSCOMMENU.LOCAL_EXTRA_SWITCH.002 = 0, 1, 1, "ローカル汎用スイッチ２番"   // ローカル汎用スイッチ２番
#SYSCOMMENU.LOCAL_EXTRA_SWITCH.003 = 0, 1, 1, "ローカル汎用スイッチ３番"   // ローカル汎用スイッチ３番
</pre>

	グローバル汎用スイッチは環境設定の設定にあります。

++ #SYSCOMMENU.LOCAL_EXTRA_SWITCH.??? = [無し／有り], [無効／有効], [初期状態], [文字列]

	無し／有り：0=無し 1=有り（存在の有無）
	ゲームの起動時、及びタイトルメニューに戻った際の初期状態です。スクリプト命令で変更可能です。

	無効／有効：0=無効 1=有効（グレー表示）
	ゲームの起動時、及びタイトルメニューに戻った際の初期状態です。スクリプト命令で変更可能です。

	初期状態：0=OFF 1=ON（チェック状態）
	ゲームの起動時、及びタイトルメニューに戻った際の初期状態です。スクリプト命令で変更可能です。

	文字列：項目の文字列

	ローカル汎用スイッチは４個（000～003）あります。

+ システムコマンドメニューの設定（ローカル汎用モード）

++ 設定ファイル

<pre class="source">
// *************************************************************
// ■システムコマンドメニュー（右クリックメニュー）のローカル汎用モードの設定
// =============================================================
#SYSCOMMENU.LOCAL_EXTRA_MODE.000 = 1, 1, 0, "ローカル汎用モード０番"   // ローカル汎用モード０番
#SYSCOMMENU.LOCAL_EXTRA_MODE.000.ITEM_CNT = 3                          // モードのアイテム数（項目数）は最大８個です。
#SYSCOMMENU.LOCAL_EXTRA_MODE.000.ITEM.000.STR = "モード０"             // アイテム（項目）の文字列
#SYSCOMMENU.LOCAL_EXTRA_MODE.000.ITEM.001.STR = "モード１"             // アイテム（項目）の文字列
#SYSCOMMENU.LOCAL_EXTRA_MODE.000.ITEM.002.STR = "モード２"             // アイテム（項目）の文字列

#SYSCOMMENU.LOCAL_EXTRA_MODE.001 = 1, 1, 0, "ローカル汎用モード１番"   // ローカル汎用モード１番
#SYSCOMMENU.LOCAL_EXTRA_MODE.001.ITEM_CNT = 3                          // モードのアイテム数（項目数）は最大８個です。
#SYSCOMMENU.LOCAL_EXTRA_MODE.001.ITEM.000.STR = "モード０"             // アイテム（項目）の文字列
#SYSCOMMENU.LOCAL_EXTRA_MODE.001.ITEM.001.STR = "モード１"             // アイテム（項目）の文字列
#SYSCOMMENU.LOCAL_EXTRA_MODE.001.ITEM.002.STR = "モード２"             // アイテム（項目）の文字列

#SYSCOMMENU.LOCAL_EXTRA_MODE.002 = 0, 1, 0, "ローカル汎用モード２番"   // ローカル汎用モード２番
#SYSCOMMENU.LOCAL_EXTRA_MODE.002.ITEM_CNT = 3                          // モードのアイテム数（項目数）は最大８個です。
#SYSCOMMENU.LOCAL_EXTRA_MODE.002.ITEM.000.STR = "モード０"             // アイテム（項目）の文字列
#SYSCOMMENU.LOCAL_EXTRA_MODE.002.ITEM.001.STR = "モード１"             // アイテム（項目）の文字列
#SYSCOMMENU.LOCAL_EXTRA_MODE.002.ITEM.002.STR = "モード２"             // アイテム（項目）の文字列

#SYSCOMMENU.LOCAL_EXTRA_MODE.003 = 0, 1, 0, "ローカル汎用モード３番"   // ローカル汎用モード３番
#SYSCOMMENU.LOCAL_EXTRA_MODE.003.ITEM_CNT = 3                          // モードのアイテム数（項目数）は最大８個です。
#SYSCOMMENU.LOCAL_EXTRA_MODE.003.ITEM.000.STR = "モード０"             // アイテム（項目）の文字列
#SYSCOMMENU.LOCAL_EXTRA_MODE.003.ITEM.001.STR = "モード１"             // アイテム（項目）の文字列
#SYSCOMMENU.LOCAL_EXTRA_MODE.003.ITEM.002.STR = "モード２"             // アイテム（項目）の文字列
</pre>

	グローバル汎用モードは環境設定の設定にあります。

++ #SYSCOMMENU.LOCAL_EXTRA_MODE.??? = [無し／有り], [無効／有効], [初期状態], [文字列]

	ローカル汎用モードは４個（000～003）あります。

	無し／有り：0=無し 1=有り（存在の有無）<br />
	ゲームの起動時、及びタイトルメニューに戻った際の初期状態です。スクリプト命令で変更可能です。

	無効／有効：0=無効 1=有効（グレー表示）<br />
	ゲームの起動時、及びタイトルメニューに戻った際の初期状態です。スクリプト命令で変更可能です。

	初期モード：0 ～ 7（選択状態）<br />
	ゲームの起動時、及びタイトルメニューに戻った際の初期状態です。スクリプト命令で変更可能です。

	文字列：項目の文字列

++ #SYSCOMMENU.LOCAL_EXTRA_MODE.003.ITEM_CNT

	各モードのアイテム数は８個までです。

++ #SYSCOMMENU.LOCAL_EXTRA_MODE.003.ITEM_CNT.???.STR

	モードに表示される文字列を指定します。




■ システムコマンドのメッセージの設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■各種確認メッセージの文字列の設定
// =============================================================
#WARNINGINFO.RESTART_WARNING_STR = "最初から始めてもよろしいですか？"
#WARNINGINFO.RETURNMENU_WARNING_STR = "タイトルに戻ってもよろしいですか？" 
#WARNINGINFO.RETURNSEL_WARNING_STR = "前の選択肢に戻ってもよろしいですか？"
#WARNINGINFO.GAMEEND_WARNING_STR = "終了してもよろしいですか？"  
</pre>

++ #WARNINGINFO.RESTART_WARNING_STR

	ゲームを最初から始める時の確認メッセージの文字列（デバッグ機能）を設定します。

++ #WARNINGINFO.RETURNMENU_WARNING_STR

	タイトルメニューに戻る時の確認メッセージの文字列を設定します。

++ #WARNINGINFO.RETURNSEL_WARNING_STR

	前の選択肢に戻る時の確認メッセージの文字列を設定します。

++ #WARNINGINFO.GAMEEND_WARNING_STR

	ゲームを終了する時の確認メッセージの文字列を設定します。



■ 環境設定の初期値の設定

+ 設定ファイル

<pre class="source">
// 画面モード
#CONFIG.WINDOW_MODE = 0                      // 画面モード（0=標準ウィンドウ 1=フルスクリーン）

// 音量
#CONFIG.VOLUME.ALL = 255                     // 音量：全体の音量（0～255）
#CONFIG.VOLUME.BGM = 255                     // 音量：ＢＧＭの音量（0～255）
#CONFIG.VOLUME.KOE = 255                     // 音量：音声の音量（0～255）
#CONFIG.VOLUME.PCM = 255                     // 音量：効果音の音量（0～255）
#CONFIG.VOLUME.SE = 255                      // 音量：システム音の音量（0～255）
#CONFIG.VOLUME.MOV = 255                     // 音量：ムービーの音量（0～255）

// ＢＧＭフェード（音声再生時にＢＧＭの音量を調整する機能）
#CONFIG.BGMFADE_VOLUME = 192                 // ＢＧＭフェード：ＢＧＭの音量の下げ率（0～255 : 0=無音 192=標準 255=変化しない）
#CONFIG.BGMFADE_ONOFF = 1                    // ＢＧＭフェード：機能の ON/OFF の初期状態（0=OFF 1=ON）

// メッセージウィンドウの背景色
#CONFIG.FILTER_COLOR = 000, 000, 255, 100    // メッセージウィンドウの背景色（ＲＧＢＡ）

// フォント
#CONFIG.FONT.TYPE = 0                        // フォント：種類（0=ＭＳゴシック 1=ＭＳ明朝）
#CONFIG.FONT.FUTOKU = 0                      // フォント：太くする（0=OFF 1=ON）
#CONFIG.FONT.SHADOW = 2                      // フォント：影モード（0=影なし 1=影あり 2=縁取る）

// メッセージ速度
#CONFIG.MESSAGE_SPEED = 100                  // メッセージ速度（0-100、小さいほど速い）
#CONFIG.MESSAGE_SPEED_NOWAIT.ONOFF = 0       // メッセージ速度：ノーウェイト（0=OFF 1=ON）

// メッセージ：キャラごとに色分けする
#CONFIG.MESSAGE_CHRCOLOR.ONOFF = 1           // メッセージをキャラごとに色分けする（0=OFF 1=ON）

// マウスカーソルを自動で隠す
#CONFIG.MOUSE_CURSOR_HIDE_ONOFF = 0          // マウスカーソルを自動で隠す
#CONFIG.MOUSE_CURSOR_HIDE_TIME = 5000        // マウスカーソルを自動で隠す時間

// オブジェクトの表示（※環境設定用ダイアログを変更するには #DIALOG.OBJECT_DISP. を設定して下さい。）
#CONFIG.OBJECT_DISP.000.ONOFF = 1            // オブジェクトの表示０番：ＯＮ／ＯＦＦ（0=OFF 1=ON）
#CONFIG.OBJECT_DISP.001.ONOFF = 1            // オブジェクトの表示１番：ＯＮ／ＯＦＦ（0=OFF 1=ON）
#CONFIG.OBJECT_DISP.002.ONOFF = 1            // オブジェクトの表示２番：ＯＮ／ＯＦＦ（0=OFF 1=ON）
#CONFIG.OBJECT_DISP.003.ONOFF = 1            // オブジェクトの表示３番：ＯＮ／ＯＦＦ（0=OFF 1=ON）

// グローバル汎用スイッチ（※環境設定用ダイアログを変更するには #DIALOG.GLOBAL_EXTRA_SWITCH. を設定して下さい。）
#CONFIG.GLOBAL_EXTRA_SWITCH.000.ONOFF = 1    // グローバル汎用スイッチ０番：ＯＮ／ＯＦＦ（0=OFF 1=ON）
#CONFIG.GLOBAL_EXTRA_SWITCH.001.ONOFF = 1    // グローバル汎用スイッチ１番：ＯＮ／ＯＦＦ（0=OFF 1=ON）
#CONFIG.GLOBAL_EXTRA_SWITCH.002.ONOFF = 1    // グローバル汎用スイッチ２番：ＯＮ／ＯＦＦ（0=OFF 1=ON）
#CONFIG.GLOBAL_EXTRA_SWITCH.003.ONOFF = 1    // グローバル汎用スイッチ３番：ＯＮ／ＯＦＦ（0=OFF 1=ON）

// グローバル汎用モード（※環境設定用ダイアログを変更するには #DIALOG.GLOBAL_EXTRA_MODE. を設定して下さい。）
#CONFIG.GLOBAL_EXTRA_MODE.000.MODE = 0       // グローバル汎用モード０番：モード値
#CONFIG.GLOBAL_EXTRA_MODE.001.MODE = 0       // グローバル汎用モード１番：モード値
#CONFIG.GLOBAL_EXTRA_MODE.002.MODE = 0       // グローバル汎用モード２番：モード値
#CONFIG.GLOBAL_EXTRA_MODE.003.MODE = 0       // グローバル汎用モード３番：モード値

// =============================================================

// 本プログラムの動作を遅くして、他のプログラムがスムーズに動作するようにする。：初期値
#CONFIG.SLEEP.ONOFF = 0

// 画面暗転効果のアニメを無効にする。：初期値
#CONFIG.NO_WIPE_ANIME.ONOFF = 0

// 画面暗転効果をマウスクリックで飛ばす。：初期値
#CONFIG.SKIP_WIPE_ANIME.ONOFF = 1

// メッセージウィンドウの開閉時のアニメを無効にする。：初期値
#CONFIG.NO_MWND_ANIME.ONOFF = 0

// マウスのホイールボタンの下回しで文章を読み進める。：初期値
#CONFIG.WHEEL_NEXT_MESSAGE.ONOFF = 1

// 声の再生中に次の文章に進んでも再生を続ける。：初期値
#CONFIG.KOE_DONT_STOP.ONOFF = 0

// 未読の文章も早送りできるようにする。：初期値
#CONFIG.SKIP_UNREAD_MESSAGE.ONOFF = 0

// サウンド再生時に雑音が入る場合はチェックして下さい。：初期値
#CONFIG.PLAY_SILENT_SOUND.ONOFF = 0
</pre>






■ 環境設定のダイアログの設定

	ダイアログの表示状態を設定するだけであり、各項目の機能が無効化されるわけではありません。
	ダイアログに項目が無くてもスクリプト命令から設定値を制御する事はできます。

+ 設定ファイル

<pre class="source">
// =============================================================

// 環境設定ダイアログのタブの存在の有無
#DIALOG_TAB_EXIST.SCREEN = 1        // 「画面」タブの存在の有無（0=無し 1=有り）
#DIALOG_TAB_EXIST.VOLUME = 1        // 「音量」タブの存在の有無（0=無し 1=有り）
#DIALOG_TAB_EXIST.MESSAGE = 1       // 「文章」タブの存在の有無（0=無し 1=有り）
#DIALOG_TAB_EXIST.MWNDBK = 1        // 「背景色」タブの存在の有無（0=無し 1=有り）
#DIALOG_TAB_EXIST.KOE = 1           // 「音声」タブの存在の有無（0=無し 1=有り）
#DIALOG_TAB_EXIST.AUTOMODE = 1      // 「オートモード」タブの存在の有無（0=無し 1=有り）
#DIALOG_TAB_EXIST.JITAN = 1         // 「時短再生」タブの存在の有無（0=無し 1=有り）
#DIALOG_TAB_EXIST.ELSE = 1          // 「その他」タブの存在の有無（0=無し 1=有り）
#DIALOG_TAB_EXIST.SYSTEM = 1        // 「システム」タブの存在の有無（0=無し 1=有り）

// =============================================================

// 「ＢＧＭ」項目の存在の有無（0=無し 1=有り）
#DIALOG_EXIST.BGM = 1       // 「ＢＧＭ」項目の存在の有無（0=無し 1=有り）

// 「音声」項目の存在の有無（0=無し 1=有り）
#DIALOG_EXIST.KOE = 1       // 「音声」項目の存在の有無（0=無し 1=有り）

// 「効果音」項目の存在の有無（0=無し 1=有り）
#DIALOG_EXIST.PCM = 1       // 「効果音」項目の存在の有無（0=無し 1=有り）

// 「システム音」項目の存在の有無（0=無し 1=有り）
#DIALOG_EXIST.SE = 1        // 「システム音」項目の存在の有無（0=無し 1=有り）

// 「ムービー」項目の存在の有無（0=無し 1=有り）
// 「システム」タブの「ムービーの再生方法」の有無にも関わります。
#DIALOG_EXIST.MOVIE = 1     // 「ムービー」項目の存在の有無（0=無し 1=有り）

// =============================================================

// 音量ダイアログのスタイル
#DIALOG_STYLE.VOLUME = 0    // 音量ダイアログのスタイル（0=音量＆ＢＧＭフェード  1=音量のみ）

// 音声ダイアログのスタイル
#DIALOG_STYLE.KOE = 0       // 音声ダイアログのスタイル（0=音声モード＆キャラクター音声  1=音声モードのみ  2=キャラクター音声のみ）

// =============================================================

// 文章の色分け：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.MESSAGE_CHRCOLOR.EXIST = 1
#DIALOG.MESSAGE_CHRCOLOR.STR = "文章を色分けする。"

// =============================================================
// ※「オブジェクトの表示」は４個（000～003）あります。

// オブジェクトの表示０番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.OBJECT_DISP.000.EXIST = 1
#DIALOG.OBJECT_DISP.000.STR = "日付を表示する"

// オブジェクトの表示１番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.OBJECT_DISP.001.EXIST = 1
#DIALOG.OBJECT_DISP.001.STR = "オブジェクト表示１番を表示する"

// オブジェクトの表示２番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.OBJECT_DISP.002.EXIST = 0
#DIALOG.OBJECT_DISP.002.STR = "オブジェクト表示２番を表示する"

// オブジェクトの表示３番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.OBJECT_DISP.003.EXIST = 0
#DIALOG.OBJECT_DISP.003.STR = "オブジェクト表示３番を表示する"

// =============================================================
// ※グローバル汎用スイッチは４個（000～003）あります。
// ※ローカル汎用スイッチはシステムコマンドメニューの設定にあります。
// ※デフォルトのスイッチ状態は #CONFIG.GLOBAL_EXTRA_SWITCH. で設定できます。

// グローバル汎用スイッチ０番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.GLOBAL_EXTRA_SWITCH.000.EXIST = 1
#DIALOG.GLOBAL_EXTRA_SWITCH.000.STR = "グローバル汎用スイッチ０番を使用する。"

// グローバル汎用スイッチ１番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.GLOBAL_EXTRA_SWITCH.001.EXIST = 1
#DIALOG.GLOBAL_EXTRA_SWITCH.001.STR = "グローバル汎用スイッチ１番を使用する。"

// グローバル汎用スイッチ２番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.GLOBAL_EXTRA_SWITCH.002.EXIST = 0
#DIALOG.GLOBAL_EXTRA_SWITCH.002.STR = "グローバル汎用スイッチ２番を使用する。"

// グローバル汎用スイッチ３番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.GLOBAL_EXTRA_SWITCH.003.EXIST = 0
#DIALOG.GLOBAL_EXTRA_SWITCH.003.STR = "グローバル汎用スイッチ３番を使用する。"

// =============================================================
// ※グローバル汎用モードは４個（000～003）あります。
// ※ローカル汎用モードはシステムコマンドメニューの設定にあります。
// ※デフォルトのモード状態は #CONFIG.GLOBAL_EXTRA_MODE. で設定できます。

// グローバル汎用モード０番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.GLOBAL_EXTRA_MODE.000.EXIST = 1
#DIALOG.GLOBAL_EXTRA_MODE.000.STR = "グローバル汎用モード０番"
#DIALOG.GLOBAL_EXTRA_MODE.000.ITEM_CNT = 3                        // モードのアイテム数（項目数）は最大８個です。
#DIALOG.GLOBAL_EXTRA_MODE.000.ITEM.000.STR = "モード０"           // アイテム（項目）の文字列
#DIALOG.GLOBAL_EXTRA_MODE.000.ITEM.001.STR = "モード１"           // アイテム（項目）の文字列
#DIALOG.GLOBAL_EXTRA_MODE.000.ITEM.002.STR = "モード２"           // アイテム（項目）の文字列

// グローバル汎用モード１番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.GLOBAL_EXTRA_MODE.001.EXIST = 1
#DIALOG.GLOBAL_EXTRA_MODE.001.STR = "グローバル汎用モード１番"
#DIALOG.GLOBAL_EXTRA_MODE.001.ITEM_CNT = 3                        // モードのアイテム数（項目数）は最大８個です。
#DIALOG.GLOBAL_EXTRA_MODE.001.ITEM.000.STR = "モード０"           // アイテム（項目）の文字列
#DIALOG.GLOBAL_EXTRA_MODE.001.ITEM.001.STR = "モード１"           // アイテム（項目）の文字列
#DIALOG.GLOBAL_EXTRA_MODE.001.ITEM.002.STR = "モード２"           // アイテム（項目）の文字列

// グローバル汎用モード２番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.GLOBAL_EXTRA_MODE.002.EXIST = 1
#DIALOG.GLOBAL_EXTRA_MODE.002.STR = "グローバル汎用モード２番"
#DIALOG.GLOBAL_EXTRA_MODE.002.ITEM_CNT = 1                        // モードのアイテム数（項目数）は最大８個です。
#DIALOG.GLOBAL_EXTRA_MODE.002.ITEM.000.STR = "モード０"           // アイテム（項目）の文字列

// グローバル汎用モード３番：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.GLOBAL_EXTRA_MODE.003.EXIST = 1
#DIALOG.GLOBAL_EXTRA_MODE.003.STR = "グローバル汎用モード３番"
#DIALOG.GLOBAL_EXTRA_MODE.003.ITEM_CNT = 1                        // モードのアイテム数（項目数）は最大８個です。
#DIALOG.GLOBAL_EXTRA_MODE.003.ITEM.000.STR = "モード０"           // アイテム（項目）の文字列

// =============================================================

// 本プログラムの動作を遅くして、他のプログラムがスムーズに動作するようにする。：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.SLEEP.EXIST = 1
#DIALOG.SLEEP.STR = "本プログラムの動作を遅くして、他のプログラムがスムーズに動作するようにする。"

// 画面暗転効果のアニメを無効にする。：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.NO_WIPE_ANIME.EXIST = 1
#DIALOG.NO_WIPE_ANIME.STR = "画面暗転効果のアニメを無効にする。"

// 画面暗転効果をマウスクリックで飛ばす。：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.SKIP_WIPE_ANIME.EXIST = 1
#DIALOG.SKIP_WIPE_ANIME.STR = "画面暗転効果をマウスクリックで飛ばす。"

// メッセージウィンドウの開閉時のアニメを無効にする。：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.NO_MWND_ANIME.EXIST = 1
#DIALOG.NO_MWND_ANIME.STR = "メッセージウィンドウの開閉時のアニメを無効にする。"

// マウスのホイールボタンの下回しで文章を読み進める。：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.WHEEL_NEXT_MESSAGE.EXIST = 1
#DIALOG.WHEEL_NEXT_MESSAGE.STR = "マウスのホイールボタンの下回しで文章を読み進める。"

// 声の再生中に次の文章に進んでも再生を続ける。：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.KOE_DONT_STOP.EXIST = 1
#DIALOG.KOE_DONT_STOP.STR = "声の再生中に次の文章に進んでも再生を続ける。"

// 未読の文章も早送りできるようにする。：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.SKIP_UNREAD_MESSAGE.EXIST = 1
#DIALOG.SKIP_UNREAD_MESSAGE.STR = "未読の文章も早送りできるようにする。"

// サウンド再生時に雑音が入る場合はチェックして下さい。：存在の有無（0=無し 1=有り）と項目の文字列
#DIALOG.PLAY_SILENT_SOUND.EXIST = 1
#DIALOG.PLAY_SILENT_SOUND.STR = "サウンド再生時に雑音が入る場合はチェックして下さい。"
</pre>






■ セーブ・ロードのダイアログおよびメッセージの設定

	セーブ・ロードの表記が保存、読込、栞を挟む、栞を開くなどに変更したい場合に設定して下さい。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■セーブ・ロードのダイアログ及び確認ウィンドウの文字列の設定
// =============================================================
#SAVELOAD_DIALOG.DATA_CNT_PAR_PAGE = 10
#SAVE.NO_DATA_STR = "データがありません。"
// =============================================================
#SAVEINFO.DLGWND_CAPTION_TITLE_STR="セーブ"
#SAVEINFO.DLGWND_DESIDE_BUTTON_STR="セーブする"
#SAVEINFO.DLGWND_DATALIST_NAMEHEADER_STR="セーブ"
#SAVEINFO.DLGWND_WARNING_CHKBOX_STR="セーブする前に上書きの確認メッセージを表示する。"
#SAVEINFO.DLGWND_DBLCLICK_CHKBOX_STR="リストをダブルクリックでセーブする。"
#SAVEINFO.WARNING_STR="セーブしてもよろしいですか？"
#SAVEINFO.QUICK_WARNING_STR="クイックセーブしてもよろしいですか？"
// =============================================================
#LOADINFO.DLGWND_CAPTION_TITLE_STR="ロード"
#LOADINFO.DLGWND_DESIDE_BUTTON_STR="ロードする"
#LOADINFO.DLGWND_DATALIST_NAMEHEADER_STR="ロード"
#LOADINFO.DLGWND_WARNING_CHKBOX_STR="ロードする前に確認メッセージを表示する。"
#LOADINFO.DLGWND_DBLCLICK_CHKBOX_STR="リストをダブルクリックでロードする。"
#LOADINFO.WARNING_STR="ロードしてもよろしいですか？"
#LOADINFO.QUICK_WARNING_STR="クイックロードしてもよろしいですか？"
</pre>

++ #SAVELOAD_DIALOG.DATA_CNT_PAR_PAGE

	セーブ・ロードダイアログの１ページ（１タブ）あたりのデータ数を設定します。

++ #SAVE.NO_DATA_STR

	存在しないセーブデータの文字列を設定します。

++ #SAVEINFO.DLGWND_CAPTION_TITLE_STR
++ #LOADINFO.DLGWND_CAPTION_TITLE_STR

	セーブ・ロードダイアログのキャプションタイトルの文字列を設定します。

++ #SAVEINFO.DLGWND_DESIDE_BUTTON_STR
++ #LOADINFO.DLGWND_DESIDE_BUTTON_STR

	セーブ・ロードダイアログの決定ボタンの文字列を設定します。

++ #SAVEINFO.DLGWND_DATALIST_NAMEHEADER_STR
++ #LOADINFO.DLGWND_DATALIST_NAMEHEADER_STR

	セーブ・ロードダイアログのデータリストの先頭文字列を設定します。

++ #SAVEINFO.DLGWND_WARNING_CHKBOX_STR
++ #LOADINFO.DLGWND_WARNING_CHKBOX_STR

	セーブ・ロードダイアログの確認チェックボックスの文字列を設定します。

++ #SAVEINFO.DLGWND_DBLCLICK_CHKBOX_STR
++ #LOADINFO.DLGWND_DBLCLICK_CHKBOX_STR

	セーブ・ロードダイアログのダブルクリックチェックボックスの文字列を設定します。

++ #SAVEINFO.WARNING_STR
++ #LOADINFO.WARNING_STR

	セーブ・ロード確認ウィンドウの確認文章の文字列を設定します。

++ #SAVEINFO.QUICK_WARNING_STR
++ #LOADINFO.QUICK_WARNING_STR

	クイックセーブ・クイックロード確認ウィンドウの確認文章の文字列を設定します。




■ セーブデータの設定

	セーブデータに関する情報を設定します。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■セーブデータの設定
// =============================================================
#SAVE.CNT = 100                                // セーブ個数
#QUICK_SAVE.CNT = 3                            // クイックセーブの個数
</pre>

++ #SAVE.CNT

	セーブデータの最大個数を設定します。

++ #QUICK_SAVE.CNT

	クイックセーブデータの最大個数を設定します。




■ エンドセーブの設定

	[[エンドセーブ]] に関する情報を設定します。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■エンドセーブの設定
// =============================================================
#END_SAVE.CNT = 1             // エンドセーブの個数（0か1を指定して下さい。0=使わない）
</pre>

++ #END_SAVE.CNT

	エンドセーブの最大個数を設定します。
	0か1を指定して下さい。0を指定すると、エンドセーブを使いません。



■ セーブサムネイルの設定

	セーブサムネイルに関する情報を設定します。
	セーブサムネイルを使うと、各セーブデータにサムネイルを持たせることができます。

	詳しくは [[セーブサムネイル]] を参照して下さい。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■セーブサムネイル
// =============================================================
#SAVE_THUMB.USE = 1
#SAVE_THUMB.SIZE = 320, 180
#SAVE_THUMB.TYPE = 0
</pre>

++ #SAVE_THUMB.USE

	セーブサムネイルを使うかどうかを設定します。0=使わない、1=使う

++ #SAVE_THUMB.SIZE

	セーブサムネイルのサイズを設定します。

++ #SAVE_THUMB.TYPE

	セーブサムネイルの形式を指定します。0=BMP、1=PNG

	通常は 0 にして下さい。
	PNG にすると、サムネイルの容量が小さくなりますが、セーブに少し時間がかかるようになります。

	セーブサムネイルが大きい（画面の半分を覆うなど）、かつセーブ数が多い（２００個など）など、
	セーブデータの容量が気になる場合は PNG にして下さい。




■ サムネイルテーブルの設定

	[[サムネイルテーブル]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■サムネイルテーブルの設定
// =============================================================
#THUMBTABLE_FILE = "thumbtable.dat"
</pre>

++ #THUMBTABLE_FILE

	サムネイルテーブルのファイル名を指定します。



■ ロード時のワイプの設定

	ロード時のワイプを設定できます。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ロード時のワイプ
// =============================================================
#LOAD.WIPE = 101, 3000                            // ロード時のワイプ
</pre>

++ #LOAD.WIPE = [ワイプ番号], [ワイプ時間]

	ワイプ番号とワイプ時間を指定します。
	ワイプオプションはまだ対応していません…。

+ 適用されるもの

<ul>
- 「ロード」時のワイプアウト、ワイプイン
- 「クイックロード」時のワイプアウト、ワイプイン
- 「前の選択肢に戻る」時のワイプアウト、ワイプイン
- 「タイトルに戻る」時のワイプアウト
</ul>




■ ロード直後コールの設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ロード直後コールの設定
// =============================================================
#LOAD_AFTER_CALL = "_load_after"        // ロード直後シーン
</pre>

	ロード直後コールで呼ばれるシーンを設定します。
	ロード直後コールについては [[ロード直後コール]] を参照して下さい。





■ キャラクター音声の設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■キャラクター音声
// =============================================================
#CHRKOE.CNT = 64						// バッファの個数
#CHRKOE.NOT_LOOK_NAME_STR = "？？？"	// 伏字用の文字列

//            表示名,      モード, チェック名, 制御番号
#CHRKOE.000 = "小鳥",       1,     "",         (01)
#CHRKOE.001 = "ちはや",     1,     "",         (02)
#CHRKOE.002 = "朱音",       1,     "",         (03)
#CHRKOE.003 = "静流",       1,     "",         (04)
#CHRKOE.004 = "ルチア",     1,     "",         (05)
#CHRKOE.005 = "女の子全て", 1,     "",         (01, 02, 03, 04, 05)
</pre>

	キャラクターの制御番号ごとに音声のオン／オフやボリュームを設定する機能の設定です。
	キャラクターの制御番号は、koe コマンドの２つ目の引数で指定します。

<pre class="exp">
koe(010000001, <font color="red">001</font>) ←ココが制御番号！
</pre>

++ #CHRKOE.CNT

	キャラクター音声の個数を設定します。

++ #CHRKOE.NOT_LOOK_NAME_STR

	伏字用の文字列を設定します。（環境設定ダイアログに表示される文字列です。）

++ #CHRKOE.??? = [表示名], [モード], [チェック名], [制御番号]

<div class="table-container">
<table>
|???|ここの番号を「登録番号」と呼びます。マニュアル内にも出てくるので覚えておくと役立つと思います。|
|表示名|環境設定ダイアログに表示される文字列です。|
|モード|0=伏字状態で自動チェックしない、1=公開状態で自動チェックしない 、2=伏字状態で自動チェックする|
|チェック名|自動チェックの際に利用する名前の文字列です。（※未定義の場合、項目に表示する名前の文字列でチェックします）|
|制御番号|制御する声の制御番号です。koe コマンドの２つ目の引数です。|
</table>
</div>

+ 登録番号と制御番号

	間違えやすいので気をつけて下さい。
	例えば「女の子全て」は、声 01～05 を制御しています。
	「女の子全て」の音声をオフにすると、制御番号 01～05 の声が全てオフになります。

	登録番号は、自力で環境設定メニューを組むような時に使います。

+ 自動チェックについて

	モードが 2 の場合、項目に表示する名前が伏字状態になります。
	ゲーム中、名前を表示するたびに自動チェックが行われ、
	登録した名前と同じ名前が表示されると自動的に伏字が解除されます。

	登録した名前と同じ名前が表示される事がない場合もあるかと思います。
	その場合は、「チェック名」を設定して下さい。
	自動チェックの際に「チェック名」でもチェックするようになります。（※表示名もチェックします）













■ 【名前】の設定

	名前を登録すると、名前を自動変換したり、名前ごとにメッセージの色を変えたりできます。

	例えば【？？】という名前があった場合、誰の台詞なのか分かりません。
	そのため、声撮りツールや「名前ごとにメッセージの色を変える」機能が上手く働きません。

	必ず名前を登録し、変換機能を使って表示しなくてはいけません。
	詳しくは [[名前を伏せる]] を参照して下さい。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■【名前】の設定
// =============================================================
//       登録名,         表示名,          文字色制御
#NAMAE = "小鳥",         "小鳥",          1, 100, -1, -1
#NAMAE = "？？＿小鳥",   "？？",          1, 100, -1, -1
#NAMAE = "ちはや",       "ちはや",        1, 101, -1, -1
#NAMAE = "？？＿ちはや", "？？",          1, 101, -1, -1
#NAMAE = "朱音",         "朱音",          1, 102, -1, -1
#NAMAE = "？？＿朱音",   "？？",          1, 102, -1, -1
#NAMAE = "静流",         "静流",          1, 103, -1, -1
#NAMAE = "？？＿静流",   "？？",          1, 103, -1, -1
#NAMAE = "ルチア",       "ルチア",        1, 104, -1, -1
#NAMAE = "？？＿ルチア", "？？",          1, 104, -1, -1
</pre>

++ #NAMAE = [登録名], [表示名], [文字色制御]

<div class="table-container">
<table>
|登録名|【】に指定する名前を登録します。|
|表示名|名前ウィンドウに表示される名前を指定します。|
|文字色制御|表示される文字の色を指定します。|
</table>
</div>

+ 名前の変換

	[[名前を伏せる]] を参照して下さい。

+ 文字色制御 = [使う／使わない], [文字の色], [影の色], [縁の色]

	「名前ごとにメッセージの色を変える」機能に使います。

<div class="table-container">
<table>
|使う／使わない|「名前ごとにメッセージの色を変える」機能を 0=使わない、1=使う|
|文字の色|文章の文字色を色番号で指定します。色番号については [[カラーテーブルの設定]] を参照して下さい。|
|影の色|文字の影の色を色番号で指定します。色番号については [[カラーテーブルの設定]] を参照して下さい。|
|縁の色|文字の縁の色を色番号で指定します。色番号については [[カラーテーブルの設定]] を参照して下さい。|
</table>
</div>

	「名前ごとにメッセージの色を変える」機能は、
	環境設定の「文章を色分けする。」でオンオフを設定できます。
	（オフの場合、メッセージの色は変換されません。）



■ フラグの設定

	[[フラグ]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■フラグの設定
// =============================================================
#FLAG.CNT = 1000
#GLOBAL_FLAG.CNT = 1000
#CALL_FLAG.CNT = 50
</pre>

++ #FLAG.CNT

	a, b, c, d, e, f, s フラグの個数を指定します。

++ #GLOBAL_FLAG.CNT

	g, z, m フラグの個数を指定します。

++ #CALL_FLAG.CNT

	コールごとに作られる l, k フラグの個数を指定します。



■ データベースの設定

	[[データベース]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■データベースの設定
// =============================================================
#DATABASE.CNT = 1
#DATABASE.000 = "sample"
</pre>

++ #DATABASE.CNT

	データベースの個数を設定します。

++ #DATABASE.??? = ???

	データベースのファイル名を設定します。



■ カウンタの設定

	[[カウンタ]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■カウンタの設定
// =============================================================
#COUNTER.CNT = 8
</pre>

++ #COUNTER.CNT

	カウンタの個数を設定します。



■ カラーテーブルの設定

	カラーテーブルの設定をします。

	ここで設定した色は、メッセージの色などに使われます。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■カラーテーブルの設定
// =============================================================
#COLOR_TABLE.CNT = 256

#COLOR_TABLE.000 = 255, 255, 255	// 白（文字色）
#COLOR_TABLE.001 =   0,   0,   0	// 黒（文字影）
#COLOR_TABLE.002 = 255,   0,   0	// 赤
#COLOR_TABLE.003 =   0, 255,   0	// 緑
#COLOR_TABLE.004 =   0,   0, 255	// 青
#COLOR_TABLE.005 = 255, 255,   0	// 黄
#COLOR_TABLE.006 = 255,   0, 255	// 紫

#COLOR_TABLE.100 = 192, 192,   0    // 小鳥
#COLOR_TABLE.101 = 255, 128, 128    // ちはや
#COLOR_TABLE.102 = 255, 128, 255    // 朱音
#COLOR_TABLE.103 = 255, 255,   0    // 静流
#COLOR_TABLE.104 = 192, 192, 255    // ルチア

#COLOR_TABLE.200 = 128, 128, 128	// グレー
#COLOR_TABLE.201 = 255, 128, 128	// 薄赤
</pre>

	０～９番はシステム色として予約されています。

<div class="table-container">
<table>
|０番|メッセージの文字の色|
|１番|メッセージの影の色|
</table>
</div>

++ #COLOR_TABLE.CNT

	色の個数を設定します。

++ #COLOR_TABLE.??? = [R], [G], [B]

	色を設定します。



■ ＣＧテーブルの設定

	[[ＣＧテーブル]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ＣＧテーブルの設定
// =============================================================
#CGTABLE_FILE = "mode.cgm"
#CGTABLE_FLAG_CNT = 1000
</pre>

++ #CGTABLE_FILE

	ＣＧテーブルのファイル名を指定します。

++ #GLOBAL_FLAG.CNT

	ＣＧテーブルのフラグの個数を指定します。



■ トーンカーブの設定

	[[トーンカーブ]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■トーンカーブの設定
// =============================================================
#TONECURVE_FILE = "tcdata.tcr"
</pre>

++ #TONECURVE_FILE

	トーンカーブデータのファイル名を指定します。



■ マスクの設定

	[[マスク]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■マスクの設定
// =============================================================
#MASK.CNT = 16
</pre>

++ #MASK.CNT

	マスクの個数を設定します。


■ Ｇ００先読みバッファの設定

	[[Ｇ００先読みバッファ]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■Ｇ００先読みバッファの設定
// =============================================================
#G00BUF.CNT = 16
</pre>

++ #G00BUF.CNT

	Ｇ００先読みバッファの個数を指定します。



■ システムコールの設定

<pre class="source">
// *************************************************************
// ■システムコールの設定
// =============================================================
#EXCALL.ORDER = 10000        // システムコールのオーダー
</pre>

	システムコールのオーダーを設定できます。
	システムコールのオブジェクト（excall.front.object）のオーダーなどに、この値が加算されます。

	環境設定画面などより上に、常にゲームのロゴを表示したい！などの場合に使えると思います。

+ サンプル：システムコールより上にオブジェクトを表示する

++ Gameexe.ini

<pre class="source">
#EXCALL.ORDER = 100
</pre>

++ ss 

<pre class="source">
front.object[0].create(unit00, 1)
front.object[0].order = 200
</pre>

	unit00 が、システムコールより上に表示されます。



■ ワールドの設定

	ワールドの設定をします。

	３Ｄ空間をワールドと呼びます。
	３Ｄを使用しない場合は使うことはありません。

	ワールドに関しては未実装です。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ワールドの設定
// =============================================================
#WORLD.CNT = 4
</pre>

++ #WORLD.CNT

	ワールドの個数を指定します。



■ オブジェクトの設定

	[[オブジェクト]] の設定をします。

	各オブジェクト個別の設定については [[オブジェクト個別の設定]] を参照して下さい。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■オブジェクトの設定
// =============================================================
#OBJECT.CNT = 100            // オブジェクトの個数
</pre>

++ #OBJECT.CNT

	オブジェクトの個数を指定します。



■ オブジェクト個別の設定

	[[オブジェクト]] の設定をします。

	オブジェクト全体の設定については [[オブジェクトの設定]] を参照して下さい。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■オブジェクト個別の設定
// =============================================================

// 全てのオブジェクトを使う
#OBJECT.000-099.USE = 1

// 90～99番オブジェクトはセーブしない
#OBJECT.090-099.SAVE = 0

// 20-21番オブジェクトは環境設定の「オブジェクトの表示０番」に従う
#OBJECT.020-021.OBJECT_DISP_NO = 0

// 20-21番オブジェクトはスペースキーで消える
#OBJECT.020-021.SPACE_HIDE = 1
</pre>

	単体で設定する場合は #OBJECT.???、複数まとめて設定する場合は #OBJECT.???-??? のように記述できます。

++ #OBJECT.???.USE = 1

	オブジェクトを使うかどうかを設定します。（0=使わない、1=使う）

	USE=0 にすると、そのオブジェクトは使えなくなります。
	使っていないオブジェクトを USE=0 にすることで、動作が速くなります。

++ #OBJECT.???.SAVE = 1

	オブジェクトをセーブするかどうかを設定します。（0=セーブしない、1=セーブする）

	SAVE=0 にすると、そのオブジェクトはセーブされなくなります。
	システム画面などで使うオブジェクトは、セーブする必要がありません。
	セーブしないオブジェクトを SAVE=0 にすることで、動作が速くなります。

++ #OBJECT.???.OBJECT_DISP_NO = -1

	環境設定の「オブジェクトの表示」???番に従う機能です。
	初期値は -1 です。（環境設定に従わない）

	例えば 0 を指定した場合、環境設定の「オブジェクト０番を表示しない」をオフにすると、
	そのオブジェクトは表示されなくなります。

	「日付を表示しない」などの機能が実装できます。

++ #OBJECT.???.SPACE_HIDE = 0

	スペースキーで、メッセージウィンドウと一緒に隠す機能です。（0=隠さない、1=隠す）

	日付などを表示しているオブジェクトは、スペースキーで一緒に消えると便利です。








■ オブジェクトボタングループの設定

	[[オブジェクトボタングループ]] の設定をします。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■オブジェクトボタングループの設定
// =============================================================
#OBJBTNGROUP.CNT = 16
</pre>

++ #OBJBTNGROUP.CNT

	オブジェクトボタングループの個数を指定します。



■ ボタンアクションの設定

	ボタンにマウスが当たったとき、押したときなどのボタンの動作を設定します。
	（マウスが当たったときは明るくする、押したときは右下に少しずらす、など）

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ボタンアクションの設定
// =============================================================
#BUTTON.ACTION.CNT = 16

//                           pat,  x,  y,  tr,  br,  dr
// カットのない１枚絵のボタン
#BUTTON.ACTION.000.NORMAL  =   0,  0,  0, 255,   0,   0
#BUTTON.ACTION.000.HIT     =   0,  0,  0, 255,  64,   0
#BUTTON.ACTION.000.PUSH    =   0,  1,  1, 255,  64,   0
#BUTTON.ACTION.000.SELECT  =   0,  0,  0, 255, 128,   0
#BUTTON.ACTION.000.DISABLE =   0,  0,  0, 255,   0, 128

// カットを利用したボタン
#BUTTON.ACTION.001.NORMAL  =   0,  0,  0, 255,   0,   0
#BUTTON.ACTION.001.HIT     =   1,  0,  0, 255,   0,   0
#BUTTON.ACTION.001.PUSH    =   2,  0,  0, 255,   0,   0
#BUTTON.ACTION.001.SELECT  =   3,  0,  0, 255,   0,   0
#BUTTON.ACTION.001.DISABLE =   4,  0,  0, 255,   0,   0
</pre>

++ #BUTTON.ACTION.CNT = 16

	ボタンアクションの個数を指定します。

++ #BUTTON.ACTION.???.??? = [パターン番号], [x], [y], [不透明度], [明度], [暗度]

	ボタンには、「通常」、「マウスが当たっている」、「マウスが押されている」、
	「決定されている」、「無効」の５種類の状態があります。
	それぞれの状態についてアクションを設定できます。

<div class="table-container">
<table>
|NORMAL|マウスが当たっていない場合|
|HIT|マウスが当たっている場合|
|PUSH|押している場合|
|SELECT|選んでいる場合|
|DESABLE|無効なボタンの場合|
</table>
</div>

++ [パターン番号]

	それぞれの状態で表示される画像のパターン番号を指定します。
	オブジェクトに設定したパターン番号に、この値が加算されます。

++ [x], [y], [不透明度], [明度], [暗度]

	それぞれの状態のときのオブジェクトに与えるパラメータを指定します。









■ ボタンアクションの設定

	ボタンにマウスが当たったとき、押したときなどに鳴らす効果音を設定します。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ボタン効果音の設定
// =============================================================
#BUTTON.SE.CNT = 4

// 決定ボタン
#BUTTON.SE.000.HIT    = 0
#BUTTON.SE.000.PUSH   = -1
#BUTTON.SE.000.DECIDE = 1

// キャンセルボタン
#BUTTON.SE.001.HIT    = 0
#BUTTON.SE.001.PUSH   = -1
#BUTTON.SE.001.DECIDE = 2
</pre>

++ #BUTTON.SE.CNT = 16

	ボタン効果音の個数を指定します。

++ #BUTTON.SE.???.??? = [システム音番号]

<div class="table-container">
<table>
|HIT|マウスが当たったときの効果音|
|PUSH|マウスで押したときの効果音|
|DECIDE|決定したときの効果音|
</table>
</div>

++ [システム音番号]

	システム音番号で指定します。[[システム音の設定]] を参照して下さい。
	-1 を指定すると、効果音は鳴りません。


■ アイコンの設定

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■アイコンの設定
// =============================================================
#ICON.CNT = 16

// -------------------------------------------------------------
#ICON.000.FILE = "_KEY_ICON"  // ファイル名
#ICON.000.SPEED = 100         // アニメスピード（ﾐﾘ秒で指定）
#ICON.000.CNT = 8
</pre>

	アイコンを設定します。
	アイコンは、メッセージウィンドウのキー待ちアイコンなどに使います。

++ #ICON.CNT

	登録するアイコンの個数を指定します。

++ #ICON.???.FILE

	アイコンに使う g00 のファイル名を指定します。

++ #ICON.???.SPEED

	アイコンのアニメーションスピードを設定します。
	値＝１コマにかける時間（ﾐﾘ秒）になります。
	値が大きいほど遅くなります。

++ #ICON.???.CNT

	アイコンのアニメーションに使うパターン番号の個数を指定します。




■ メッセージウィンドウの設定

	[[メッセージウィンドウ]] の設定をします。

	各メッセージウィンドウ個別の設定については [[メッセージウィンドウ個別の設定]] を参照して下さい。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■メッセージウィンドウの設定
// =============================================================
#MWND.CNT = 5                   // メッセージウィンドウの個数
#MWND.DEFAULT_MWND_NO = 0       // デフォルトのメッセージウィンドウ番号
#MWND.DEFAULT_SEL_MWND_NO = 1   // デフォルトのメッセージウィンドウ番号（選択肢用）
#MWND.ORDER = 1                 // メッセージウィンドウの表示オーダー
#MWND.FILTER_LAYER_REP = 0      // フィルターのレイヤー値補正
#MWND.WAKU_LAYER_REP = 10       // 枠のレイヤー値補正
#MWND.FACE_LAYER_REP = 20       // 顔グラのレイヤー値補正
#MWND.SHADOW_LAYER_REP = 30     // 文字の影のレイヤー値補正
#MWND.FUCHI_LAYER_REP = 40      // 文字の縁のレイヤー値補正
#MWND.MOJI_LAYER_REP = 50       // 文字のレイヤー値補正
#MWND.SHADOW_COLOR = 1          // 影の色（カラーテーブルの番号で指定）
#MWND.FUCHI_COLOR = 1           // 縁の色（カラーテーブルの番号で指定）
#MWND.MOJI_COLOR = 0            // 文字の色（カラーテーブルの番号で指定）
</pre>

++ #MWND.CNT

	メッセージウィンドウの個数を指定します。

	メッセージウィンドウは非常に処理の重い機能です。
	使わない分は、なるべく個数を削ることをオススメします。

++ #MWND.DEFAULT_MWND_NO

	デフォルトで使うメッセージウィンドウの番号を指定します。

++ #MWND.DEFAULT_SEL_MWND_NO

	デフォルトで選択肢用に使うメッセージウィンドウの番号を指定します。

++ #MWND.ORDER

	メッセージウィンドウのオーダーの値を指定します。通常はオーダー１です。

++ #MWND.FILTER_LAYER_REP

	メッセージウィンドウのフィルター部分のレイヤー値を指定します。

++ #MWND.WAKU_LAYER_REP

	メッセージウィンドウの枠部分のレイヤー値を指定します。

++ #MWND.FACE_LAYER_REP

	メッセージウィンドウの顔グラフィック部分のレイヤー値を指定します。

++ #MWND.SHADOW_LAYER_REP

	メッセージの影部分のレイヤー値を指定します。

++ #MWND.MOJI_LAYER_REP

	メッセージの文字のレイヤー値を指定します。

++ #MWND.SHADOW_COLOR

	メッセージの影の色を、カラーテーブルの番号で指定します。

++ #MWND.MOJI_COLOR

	メッセージの文字の色を、カラーテーブルの番号で指定します。



■ メッセージウィンドウ個別の設定

	メッセージウィンドウ個別の設定を行います。

	メッセージウィンドウは、ウィンドウと枠を組み合わせて作ります。
	よく使われるのが以下の組み合わせです。

<div class="table-container">
<table>
|固定ウィンドウ＋固定枠|デザインされた固定サイズのウィンドウ|
|可変ウィンドウ＋可変枠|選択肢用のウィンドウなどの可変長のウィンドウ|
|固定ウィンドウ＋可変枠|コマンドウィンドウなど、大きさの違う複数のウィンドウ|
</table>
</div>

	メッセージウィンドウの設定では、主に位置や文字サイズなど、メッセージに関する設定をします。
	背景色や顔グラ、ボタンなどの設定は、枠の設定で行います。
	[[メッセージウィンドウ枠の設定]] を参照して下さい。

+ 名前ウィンドウについて

	メッセージウィンドウごとに、名前ウィンドウの設定も行います。
	名前ウィンドウにも枠をつけることができます。
	位置や揃え位置などの設定が難しいですが、実際に試して見て下さい。

+ 開閉アニメについて

	開きアニメ、閉じアニメを設定できます。
	[[メッセージウィンドウ開閉アニメタイプ一覧]] を参照して下さい。

+ 固定ウィンドウのサンプル

++ 設定ファイル

<pre class="source">
#MWND.000.EXTEND_TYPE = 0                      // 0:固定サイズ、1:可変サイズ
#MWND.000.WINDOW_POS = 320, 520                // ウィンドウの位置
#MWND.000.WINDOW_SIZE = 640, 160               // ウィンドウのサイズ（固定サイズのみ）
#MWND.000.MESSAGE_POS = 32, 32                 // メッセージの位置（固定サイズのみ）
#MWND.000.MESSAGE_MARGIN = 32, 32, 32, 32      // メッセージの表示矩形（可変サイズのみ）
#MWND.000.MOJI_CNT = 23, 3                     // 表示する文字数
#MWND.000.MOJI_SIZE = 24                       // 文字のサイズ
#MWND.000.MOJI_SPACE = 0, 12                   // 文字間のスペース
#MWND.000.RUBY_SIZE = 10                       // ルビの文字サイズ
#MWND.000.RUBY_SPACE = 0                       // ルビと文字の間のスペース
#MWND.000.WAKU_NO = 0                          // 枠番号（-1: 枠なし）
// -------------------------------------------------------------
#MWND.000.NAME_DISP_MODE = 0                   // 名前の表示方法（0:名前ウィンドウに表示、1:メッセージの先頭に表示、2:表示しない）
// -------------------------------------------------------------
#MWND.000.NAME_EXTEND_TYPE = 0                 // （名前ウィンドウ）0=固定サイズ、1=可変サイズ
#MWND.000.NAME_WINDOW_ALIGN = 1                // （名前ウィンドウ）揃え位置（0=左、1=中央、2=右）
#MWND.000.NAME_WINDOW_POS = 80, -60            // （名前ウィンドウ）ウィンドウの位置
#MWND.000.NAME_WINDOW_SIZE = 160, 60           // （名前ウィンドウ）ウィンドウのサイズ（固定サイズのみ）
#MWND.000.NAME_MESSAGE_POS = 0, 28             // （名前ウィンドウ）メッセージの位置（固定サイズのみ）
#MWND.000.NAME_MESSAGE_POS_REP = 100, 0        // （名前ウィンドウ）メッセージの修正位置（Ｘ、Ｙ）（固定サイズのみ）
#MWND.000.NAME_MESSAGE_MARGIN = 8, 8, 8, 8     // （名前ウィンドウ）メッセージの表示矩形（可変サイズのみ）
#MWND.000.NAME_MOJI_CNT = 8                    // （名前ウィンドウ）表示する文字数
#MWND.000.NAME_MOJI_SIZE = 24                  // （名前ウィンドウ）文字のサイズ
#MWND.000.NAME_MOJI_SPACE = -1, 10             // （名前ウィンドウ）文字間のスペース
#MWND.000.NAME_BRACKET = 0                     // （名前ウィンドウ）名前を括弧で括る（0:括弧なし、1:【】）
#MWND.000.NAME_WAKU_NO = 10                    // （名前ウィンドウ）枠番号（-1: 枠なし）
// -------------------------------------------------------------
#MWND.000.NOVEL_MODE = 0                       // 0:ＡＶＧモード、1:ノベルモード
// -------------------------------------------------------------
#MWND.000.FACE_HIDE_NAME = 0                   // 顔グラを表示したとき名前を自動で隠す（0:隠さない、1:隠す）
// -------------------------------------------------------------
#MWND.000.OPEN_ANIME_TYPE = 3                  // 開きアニメ
#MWND.000.OPEN_ANIME_TIME = 500                // 開きアニメの時間
#MWND.000.CLOSE_ANIME_TYPE = 3                 // 閉じアニメ
#MWND.000.CLOSE_ANIME_TIME = 500               // 閉じアニメの時間
</pre>

++ メッセージウィンドウとメッセージの設定
<div class="table-container">
<table>
|EXTEND_TYPE|0:固定サイズ、1:可変サイズ|
|WINDOW_POS|ウィンドウの位置（Ｘ、Ｙ）を指定します。|
|WINDOW_SIZE|ウィンドウのサイズ（幅、高）を指定します。<br />固定サイズのときのみ設定してください。可変サイズの場合は自動で調整されます。|
|MESSAGE_POS|メッセージを表示する位置（Ｘ、Ｙ）を指定します。<br />固定サイズのときのみ設定してください。可変サイズの場合は MESSAGE_MARGIN で指定されます。|
|MESSAGE_MARGIN|ウィンドウとメッセージ間のマージン（左、上、右、下）を指定します。<br />可変サイズのときのみ設定してください。|
|MOJI_CNT|メッセージの文字数（横、縦）を指定します。|
|MOJI_SIZE|文字のサイズを指定します。|
|MOJI_SPACE|文字間のスペース（横、縦）を指定します。ルビサイズより大きくするのが望ましいです。|
|RUBY_SIZE|ルビの文字サイズを指定します。|
|RUBY_SPACE|ルビと文字の間のスペースを指定します。|
|WAKU_NO|枠番号を指定します。-1 で枠無しになります。|
</table>
</div>

++ 名前と名前ウィンドウの設定

<div class="table-container">
<table>
|NAME_DISP_MODE|名前の表示設定をします。<br />0: 名前ウィンドウに名前を表示します。<br />1: メッセージの先頭に名前を表示します。メッセージのオーバーフローに注意して下さい。<br />2: 名前を表示しません。ノベルモードなどに最適です。<br />名前を表示しない場合、メッセージバックやセーブメッセージにも名前は表示されません。|
|NAME_EXTEND_TYPE|0:固定サイズ、1:可変サイズ|
|NAME_WINDOW_ALIGN|名前ウィンドウの揃え位置を指定します。（0=左、1=中央、2=右）|
|NAME_WINDOW_POS|名前ウィンドウの位置（Ｘ、Ｙ）を、ウィンドウの位置からの相対座標で指定します。|
|NAME_WINDOW_SIZE|名前ウィンドウのサイズ（幅、高）を指定します。<br />固定サイズのときのみ設定してください。可変サイズの場合は自動で調整されます。|
|NAME_MESSAGE_POS|名前を表示する位置（Ｘ、Ｙ）を指定します。<br />固定サイズのときのみ設定してください。可変サイズの場合は NAME_MESSAGE_MARGIN で指定されます。<br />左寄せの場合は右に、右寄せの場合は左に移動します。中央寄せの場合は NAME_MESSAGE_POS_REP を参照して下さい。|
|NAME_MESSAGE_POS_REP|名前を表示する修正位置（Ｘ、Ｙ）を指定します。<br />左／中央／右寄せを行った後、この値が位置に加算されます。|
|NAME_MESSAGE_MARGIN|名前ウィンドウと名前のマージン（左、上、右、下）を指定します。<br />可変サイズのときのみ設定してください。|
|NAME_MOJI_CNT|名前の文字数（横、縦）を指定します。|
|NAME_MOJI_SIZE|名前の文字サイズを指定します。|
|NAME_MOJI_SPACE|名前の文字間のスペース（横、縦）を指定します。|
|NAME_BRACKET|名前を括弧で括るかを設定します。0:括弧なし、1:【】で括る|
|NAME_WAKU_NO|名前ウィンドウの枠番号を指定します。-1 で枠無しになります。|
</table>
</div>

++ ノベルモードの設定

<div class="table-container">
<table>
|NOVEL_MODE|1 にするとノベルモードになります。[[ノベルモード]] を参照して下さい。|
</table>
</div>

++ 顔グラフィックの設定

<div class="table-container">
<table>
|FACE_HIDE_NAME|顔グラを表示したときに、自動で名前を隠します。<br />ただし、メッセージバックやセーブメッセージには名前は残ります。名前がネタバレになる場合は、表示されなくても【？？？】などに設定して下さい。|
</table>
</div>

++ ウィンドウアニメの設定

<div class="table-container">
<table>
|OPEN_ANIME_TYPE|開きアニメのタイプを指定します。|
|OPEN_ANIME_TIME|開きアニメにかける時間をﾐﾘ秒で指定します。|
|CLOSE_ANIME_TYPE|閉じアニメのタイプを指定します。|
|CLOSE_ANIME_TIME|閉じアニメにかける時間をﾐﾘ秒で指定します。|
</table>
</div>


+ 選択肢用の可変ウィンドウのサンプル

++ 設定ファイル

<pre class="source">
#MWND.001.EXTEND_TYPE = 1                      // 0:固定サイズ、1:可変サイズ
#MWND.001.WINDOW_POS = 720, 16                 // ウィンドウの位置
#MWND.001.MESSAGE_MARGIN = 32, 32, 32, 32      // メッセージの表示矩形（可変サイズのみ）
#MWND.001.MOJI_SIZE = 20                       // 文字のサイズ
#MWND.001.MOJI_SPACE = 0, 8                    // 文字間のスペース
#MWND.001.WAKU_NO = 3                          // 枠番号（-1: 枠なし）
// -------------------------------------------------------------
#MWND.001.OPEN_ANIME_TYPE = 5                  // 開きアニメ
#MWND.001.OPEN_ANIME_TIME = 250                // 開きアニメの時間
#MWND.001.CLOSE_ANIME_TYPE = 1                 // 閉じアニメ
#MWND.001.CLOSE_ANIME_TIME = 250               // 閉じアニメの時間
</pre>











■ メッセージウィンドウ枠の設定

	メッセージウィンドウ枠の設定をします。

	各メッセージウィンドウ枠個別の設定については [[メッセージウィンドウ枠個別の設定]] を参照して下さい。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■メッセージウィンドウ枠の設定
// =============================================================
#WAKU.CNT = 32          // 枠の個数
#WAKU.BTN.CNT = 20      // ボタンの個数
#WAKU.FACE.CNT = 1      // 顔グラフィックの個数
#WAKU.OBJECT.CNT = 1    // オブジェクトの個数
</pre>

++ #WAKU.CNT

	メッセージウィンドウ枠の個数を指定します。

++ #WAKU.BTN.CNT

	枠の持つボタンの個数を指定します。

++ #WAKU.FACE.CNT

	枠の持つ顔グラの個数を指定します。

++ #WAKU.OBJECT.CNT

	枠の持つ子オブジェクトの個数を指定します。




■ メッセージウィンドウ枠個別の設定

+ 設定ファイル

<pre class="source">
#WAKU.000.EXTEND_TYPE = 0                      // 0=固定サイズ、1=可変サイズ
#WAKU.000.WAKU_FILE = "_mwaku00"               // 枠用の画像ファイル
#WAKU.000.FILTER_FILE = "_mfilter02"           // フィルターのファイル
#WAKU.000.FILTER_MARGIN = 0, 0, 0, 0           // フィルターをかける部分の矩形（左、上、右、下）（マージン指定）
#WAKU.000.FILTER_COLOR = 0, 0, 0, 255          // フィルターの色を指定します。（ＲＧＢＡ）
#WAKU.000.FILTER_CONFIG_COLOR = 1              // フィルターの色に環境設定の値を加算します。
#WAKU.000.FILTER_CONFIG_TR = 1                 // フィルターの透明度に環境設定の値を合成します。
// -------------------------------------------------------------
#WAKU.000.ICON_NO = 0                          // キー待ちアイコンの番号
#WAKU.000.PAGE_ICON_NO = 1                     // ページ待ちアイコンの番号
#WAKU.000.ICON_POS_TYPE = 1                    // キー／ページ待ちアイコンの位置タイプ（0:固定（ICON_POS で指定）、1:文末）
#WAKU.000.ICON_POS = 3, 0, 0                   // キー／ページ待ちアイコンの位置（0:左上、1:右上、2:左下、3:右下）
// -------------------------------------------------------------
#WAKU.000.FACE.000.POS = 24, 24                // 顔グラ０番の位置
// -------------------------------------------------------------
#WAKU.000.BTN.000.TYPE = "close_mwnd"          // ボタンの種類（メッセージウィンドウを閉じる）
#WAKU.000.BTN.000.FILE = "_mbtn00"             // ボタンのファイル名
#WAKU.000.BTN.000.CUT_NO = 0                   // ボタンのカット番号
#WAKU.000.BTN.000.POS = 1, 20, 0               // ボタンの初期位置（0:左上、1:右上、2:左下、3:右下）
#WAKU.000.BTN.000.ACTION = 0                   // ボタンのボタンアクションの設定
#WAKU.000.BTN.000.SE = -1                      // ボタンのボタン効果音の設定
#WAKU.000.BTN.000.CALL = "", ""                // ボタンのコール先の設定
</pre>

+ 固定枠と可変枠

	固定枠は、画像なし、またはカット１枚の画像が使えます。
	可変枠は、カット１２枚の画像が使えます。

+ フィルター

	フィルターは、メッセージウィンドウの下地にあたります。画像または矩形を使うことができます。

	画像を使う場合は、ファイルを指定してください。

<pre class="source">
#WAKU.000.FILTER_FILE = "_mfilter00"           // フィルターファイル
</pre>

	矩形を使う場合は、マージンと色を指定してください。

<pre class="source">
#WAKU.000.FILTER_MARGIN = 0, 0, 0, 0           // フィルターをかける部分の矩形（左、上、右、下）（マージン指定）
#WAKU.000.FILTER_COLOR = 0, 0, 0, 255          // フィルターの色（ＲＧＢＡ）
</pre>

+ 実際のフィルター色について

	実際に表示されるフィルター色は、画像または矩形色に加えて、環境設定の「背景色」の色が加算されます。

	例：FILTER_COLOR の値を 0, 0, 255, 255 にして青いフィルターを作成した
	 ＋ 環境設定で背景色の緑を 255 に設定した
	 ＝ 水色のフィルターが表示されます。

<div class="chips">
たとえば青いウィンドウを作りたい場合でも、フィルターは黒で作成し、
環境設定の初期値を青に設定するべきです。
ユーザは環境設定を触ることで、黒～白のフィルタを選ぶことができます。
青で作成してしまうと、ユーザは青～白のフィルタしか選ぶことができません。
</div>

<pre class="source">
#WAKU.000.FILTER_CONFIG_COLOR = 1              // フィルターの色に環境設定の値を加算します。
#WAKU.000.FILTER_CONFIG_TR = 1                 // フィルターの透明度に環境設定の値を合成します。
</pre>

	フィルターに、環境設定の「背景色」を適用するかどうかを設定します。
	色と透明度で別々に設定することができます。デフォルト値は 1 です。
	「透明度は変更してもいいけど、色は変えて欲しくない…」と言った場合に使うことができます。

+ キー待ちアイコン

	メッセージのキー待ち中に表示されるアイコンです。
	PAGE_ICON_NO は、[[ノベルモード]] でページ待ちの場合に表示されるアイコンです。
	詳しくは[[アイコンの設定]] を参照して下さい。

	ICON_POS_TYPE を 1 にした場合、アイコンは文末につきます。
	0 にした場合、アイコン位置は固定となり、ICON_POS で位置を指定します。

+ 顔グラフィック（顔グラ）

	顔グラは標準で１個だけ設定できます。増やしたい場合は #WAKU.FACE_CNT を設定してください。

+ ウィンドウボタン

	ボタンは標準で８個までつけることができます。増やしたい場合は #WAKU.BTN_CNT を設定してください。

++ ボタンタイプ

	ボタンの種類を指定します。

<div class="table-container">
<table>
|TYPE = "none"|何もしないボタン|
|TYPE = "save"|セーブボタン|
|TYPE = "load"|ロードボタン|
|TYPE = "qsave", 0|クイックセーブ（番号の指定が必要です。）|
|TYPE = "qload", 0|クイックロード（番号の指定が必要です。）|
|TYPE = "read_skip", 0|既読早送りボタン（モードの指定が必要です。）|
|TYPE = "auto_mode", 0|オートモードボタン（モードの指定が必要です。）|
|TYPE = "return_sel"|前の選択肢に戻るボタン|
|TYPE = "koe_play"|声再生ボタン|
|TYPE = "msg_log"|メッセージログを開く|
|TYPE = "close_mwnd"|メッセージウィンドウを閉じる|
|TYPE = "local_switch", 0, 0|ローカル汎用スイッチ（番号とモードの指定が必要です。）|
|TYPE = "local_mode", 0, 0|ローカル汎用モード（番号とモードの指定が必要です。）|
|TYPE = "global_switch", 0, 0|グローバル汎用スイッチ（番号とモードの指定が必要です。）|
|TYPE = "global_mode", 0, 0|グローバル汎用モード（番号とモードの指定が必要です。）|
</table>
</div>

++ 何もしないボタン

	何もしませんが、
	SE で指定した音を鳴らす、CALL で指定したシーンをコールする、などの機能は働きます。

++ ボタンモード

	「既読早送り」や「オートモード」、「ローカル汎用スイッチ」などは、
	モードがＯＮ／ＯＦＦの２種類のボタンが必要です。
	また、「ローカル汎用モード」は、モードの数だけボタンが必要です。

<pre class="source">
#WAKU.000.BTN.000.TYPE = "read_skip", 0    // ボタン０番：既読早送りのモード０（ＯＦＦの状態）
#WAKU.000.BTN.001.TYPE = "read_skip", 1    // ボタン１番：既読早送りのモード１（ＯＮの状態）
#WAKU.000.BTN.002.TYPE = "switch", 0, 0    // ボタン２番：スイッチ０番のモード０（ＯＦＦの状態）
#WAKU.000.BTN.003.TYPE = "switch", 0, 1    // ボタン３番：スイッチ０番のモード１（ＯＮの状態）
</pre>

++ 既読早送りボタンのモード

<ul>
- モード０：早送りがＯＦＦのときに使われるボタン（押すとＯＮになる）
- モード１：早送りがＯＮのときに使われるボタン（押すとＯＦＦになる）
</ul>

++ オートモードボタンのモード

<ul>
- モード０：オートモードがＯＦＦのときに使われるボタン（押すとＯＮになる）
- モード１：オートモードがＯＮのときに使われるボタン（押すとＯＦＦになる）
</ul>

++ ローカル汎用スイッチのモード

<ul>
- モード０：スイッチがＯＦＦのときに使われるボタン（押すとＯＮになる）
- モード１：スイッチがＯＮのときに使われるボタン（押すとＯＦＦになる）
</ul>

++ ローカル汎用モードのモード

<ul>
- モード０：モードの値が０のときに使われるボタン（押すと値が１になる）
- モード１：モードの値が１のときに使われるボタン（押すと値が２になる）
- モード２：モードの値が２のときに使われるボタン（押すと値が３になる）
- …
</ul>

++ ボタンアクション

	ボタンアクションの番号を指定します。[[ボタンアクションの設定]] を参照して下さい。

++ ボタン効果音

	ボタン効果音の番号を指定します。[[ボタン効果音の設定]] を参照して下さい。

++ コール

	ボタンを押したときに、特定のシーンまたはコマンドをコールすることができます。

<pre class="source">
#WAKU.000.BTN.000.CALL = "_system", 0        // _system.ss の #z00 をコールする
#WAKU.000.BTN.000.CALL = "_system", "$sys00" // _system.ss のコマンド "$sys00" をコールする
</pre>

++ 注意点

	コールを指定した場合、ボタンを押したときのデフォルトの動作は無効化されます。
	例えば、セーブボタンを押してもセーブ画面は開きません。
	状況に応じて、コール先で syscom.call_save_menu などの処理が必要です。

	ではタイプを指定する意味はないのかと言うと、そうではありません。
	例えばセーブボタンに設定すると、セーブが無効化されているときはそのボタンは押せません。
	（ボタンアクションの「無効」の状態になります。）

+ オブジェクト

	メッセージウィンドウにオブジェクトをつけることができます。
	オブジェクトは標準では１個だけつけることができます。増やしたい場合は #WAKU.OBJECT_CNT を設定してください。



















■ ボタン選択肢の設定

	ボタン選択肢（selbtn）の設定を行います。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ボタン選択肢の設定
// =============================================================
#SELBTN.CNT = 1                             // ボタン選択肢の数
// -------------------------------------------------------------
#SELBTN.000.BASE_FILE = "_sel_base00"       // ボタンのファイル名
#SELBTN.000.BACK_FILE = "_sel_back00"       // 背景のファイル名
#SELBTN.000.BASE_POS = 640, 300             // ボタンの位置
#SELBTN.000.REP_POS = 40, 90                // ボタンの修正位置
#SELBTN.000.ALIGN = 1, 1                    // ＸＹ方向の揃え位置（0=左／上、1=中央、2=右／下）
// -------------------------------------------------------------
#SELBTN.000.MOJI_SIZE = 30, 0, 0, 0         // 文字のサイズ、字間、行間、横文字数
#SELBTN.000.MOJI_POS = 286, 22              // 文字の位置
#SELBTN.000.MOJI_ALIGN = 1, 0               // 文字のＸＹ方向の揃え位置（0=左／上、1=中央、2=右／下）
#SELBTN.000.MOJI_COLOR = 0                  // 文字の色
#SELBTN.000.MOJI_HIT_COLOR = 5              // マウスが当たったときの文字の色（-1=変更しない）
#SELBTN.000.BTN_ACTION = 3                  // ボタンアクション（-1:使わない）
// -------------------------------------------------------------
#SELBTN.000.OPEN_ANIME = 6, 500             // 開きアニメタイプ、時間
#SELBTN.000.CLOSE_ANIME = 6, 500            // 閉じアニメタイプ、時間
#SELBTN.000.DECIDE_ANIME = 2, 500           // 決定アニメタイプ、時間
</pre>

<div class="table-container">
<table>
|#SELBTN.CNT|ボタン選択肢の個数を指定します。|
|#SELBTN.???.BASE_FILE|ボタン選択肢のベースとなるファイルを指定します。|
|#SELBTN.???.BACK_FILE|ボタン選択肢の背景となるファイルを指定します。|
|#SELBTN.???.BASE_POS|１つ目のボタンの位置を指定します。|
|#SELBTN.???.REP_POS|２つ目以降のボタンの修正位置を指定します。|
|#SELBTN.???.ALIGN|ＸＹ方向の揃え位置を指定します。（0=左／上、1=中央、2=右／下）|
|#SELBTN.???.MOJI_SIZE|文字のサイズ、字間、行間、横文字数を指定します。|
|#SELBTN.???.MOJI_POS|文字の位置を指定します。|
|#SELBTN.???.MOJI_ALIGN|文字のＸＹ方向の揃え位置を指定します。（0=左／上、1=中央、2=右／下）|
|#SELBTN.???.MOJI_COLOR|文字の色を指定します。[[カラーテーブルの設定]] を参照して下さい。|
|#SELBTN.???.MOJI_HIT_COLOR|マウスが当たったときの文字の色を指定します。[[カラーテーブルの設定]] を参照して下さい。（-1=変更しない）|
|#SELBTN.???.BTN_ACTION|ボタンアクションを指定します。[[ボタンアクションの設定]] を参照して下さい。（-1:指定しない）|
|#SELBTN.???.OPEN_ANIME|開きアニメタイプと時間を指定します。下記のアニメタイプを参照して下さい。|
|#SELBTN.???.CLOSE_ANIME|閉じアニメタイプと時間を指定します。下記のアニメタイプを参照して下さい。|
|#SELBTN.???.DECIDE_ANIME|決定アニメタイプと時間を指定します。下記のアニメタイプを参照して下さい。|
</table>
</div>

+ 開く / 閉じる / 決定時のアニメタイプ

++ 開きアニメタイプ

<div class="table-container">
<table>
|0|アニメなし|
|1|フェードイン|
|2|上から出てくる|
|3|下から出てくる|
|4|左から出てくる|
|5|右から出てくる|
|6|左右から交互に出てくる|
|7|一番上の選択肢の位置から散らばるように出てくる（▲未実装）|
|8|一番上の選択肢の位置から順番に出てくる（▲未実装）|
</table>
</div>

++ 閉じアニメタイプ

<div class="table-container">
<table>
|0|アニメなし|
|1|フェードアウト|
|2|上へ消える|
|3|下へ消える|
|4|左へ消える|
|5|右へ消える|
|6|左右へ交互に消える|
|7|一番上の選択肢の位置へ集まるように消える（▲未実装）|
|8|一番上の選択肢から順番に消える（▲未実装）|
</table>
</div>

++ 決定アニメタイプ

<div class="table-container">
<table>
|0|アニメなし|
|1|選択した項目以外をフェードで消去|
|2|選択した項目以外を選択した項目に集まるように消去|
|3|選択した項目以外を消去（▲未実装）|
</table>
</div>

++ 閉じアニメタイプの注意

	決定アニメモードを 0（アニメなし）以外に指定した場合、
	閉じアニメモードは自動的に変更されます。

<div class="table-container">
<table>
|0|アニメなし|
|1 - 7|フェードアウト|
</table>
</div>

	キャンセルした場合は決定アニメが行われないので、
	指定された閉じアニメが実行されます。




■ メッセージバックの設定

<div align="center">
<img src="msgbk.png">
</div>

	メッセージバックを表示するウィンドウの設定をします。

+ 設定ファイル

<pre class="source">
// -------------------------------------------------------------
// ウィンドウの設定
#MSGBK.WINDOW_POS = 160, 20                 // ウィンドウの位置（Ｘ、Ｙ）（普通は 0, 0 でいいと思います）
#MSGBK.WINDOW_SIZE = 960, 680               // ウィンドウのサイズ（幅、高）
#MSGBK.DISP_MARGIN = 0, 20, 0, 20           // メッセージなどを表示する矩形（ウィンドウからのマージンで指定）（左、上、右、下）
#MSGBK.MESSAGE_POS = 160                    // メッセージを表示する位置（Ｘ）
#MSGBK.MOJI_CNT = 25, 12                    // 表示する文字数（横、縦）
#MSGBK.MOJI_SIZE = 25                       // 文字のサイズ
#MSGBK.MOJI_SPACE = 0, 10                   // 文字間のスペース（横、縦）
// -------------------------------------------------------------
// 背景の設定
#MSGBK.BACK_FILE = "_fmsgbk_back_yoko"      // 背景ファイル（必要ない場合は ""）
// -------------------------------------------------------------
// フィルターの設定
#MSGBK.FILTER_FILE = ""                     // フィルターファイル
#MSGBK.FILTER_MARGIN = 0, 0, 0, 0           // フィルター矩形（ウィンドウからのマージンで指定）（左、上、右、下）
#MSGBK.FILTER_COLOR = 0, 0, 0, 255          // フィルター色（Ｒ、Ｇ、Ｂ、Ａ）
// -------------------------------------------------------------
// 閉じるボタン
#MSGBK_ITEM.CLOSE_BTN.FILE = "_fmsgbk_btn_close"
#MSGBK_ITEM.CLOSE_BTN.POS = 887, 12         // ボタンの位置（ウィンドウからの位置で指定）
#MSGBK_ITEM.CLOSE_BTN.ACTION = 1            // ボタンアクション番号
#MSGBK_ITEM.CLOSE_BTN.SE = -1               // ボタン効果音番号
// -------------------------------------------------------------
// スライダー
#MSGBK_ITEM.SLIDER.FILE = "_fmsgbk_slider"
#MSGBK_ITEM.SLIDER.POS = 888, 80, 633       // ボタンの位置（ウィンドウからの座標で指定）
#MSGBK_ITEM.SLIDER.ACTION = 1               // ボタンアクション番号
#MSGBK_ITEM.SLIDER.SE = -1                  // ボタン効果音番号
// -------------------------------------------------------------
// ↑ボタン
#MSGBK_ITEM.MSG_UP_BTN.FILE = "_fmsgbk_btn_msg_up"
#MSGBK_ITEM.MSG_UP_BTN.POS = 887, 46        // ボタンの位置（ウィンドウからの座標で指定）
#MSGBK_ITEM.MSG_UP_BTN.ACTION = 1           // ボタンアクション番号
#MSGBK_ITEM.MSG_UP_BTN.SE = -1              // ボタン効果音番号
// -------------------------------------------------------------
// ↓ボタン
#MSGBK_ITEM.MSG_DOWN_BTN.FILE = "_fmsgbk_btn_msg_down"
#MSGBK_ITEM.MSG_DOWN_BTN.POS = 887, 641     // ボタンの位置（ウィンドウからの座標で指定）
#MSGBK_ITEM.MSG_DOWN_BTN.ACTION = 1         // ボタンアクション番号
#MSGBK_ITEM.MSG_DOWN_BTN.SE = -1            // ボタン効果音番号
// -------------------------------------------------------------
// 声ボタン
#MSGBK_ITEM.KOE_BTN.FILE = "_fmsgbk_btn_koe"
#MSGBK_ITEM.KOE_BTN.POS = -40, 0            // ボタンの位置（メッセージからの座標で指定）
#MSGBK_ITEM.KOE_BTN.ACTION = 0              // ボタンアクション番号
#MSGBK_ITEM.KOE_BTN.SE = -1                 // ボタン効果音番号
// -------------------------------------------------------------
// ロードボタン
#MSGBK_ITEM.LOAD_BTN.FILE = "_fmsgbk_btn_load"
#MSGBK_ITEM.LOAD_BTN.POS = -140, 0          // ボタンの位置（メッセージからの座標で指定）
#MSGBK_ITEM.LOAD_BTN.ACTION = 1             // ボタンアクション番号
#MSGBK_ITEM.LOAD_BTN.SE = -1                // ボタン効果音番号
// -------------------------------------------------------------
// ロードコール
#MSGBK.LOAD_CALL = "_system", "$msgbk_btn_load"               // ボタンのコール先の設定
// -------------------------------------------------------------
// セパレーター
#MSGBK.SEPARATOR_FILE = "_fmsgbk_separator"                   // セパレーターの画像
#MSGBK.SEPARATOR_TOP_FILE = "_fmsgbk_separator_top"           // セパレーターの画像（先頭）
#MSGBK.SEPARATOR_BOTTOM_FILE = "_fmsgbk_separator_bottom"     // セパレーターの画像（末尾）
// -------------------------------------------------------------
// その他の設定
#MSGBK.MSG_CLICK_ACTION = 2                 // メッセージをクリックしたときの動作（0=無し、1=声を再生、2=ロード）
</pre>

+ メッセージウィンドウの位置と大きさ

<div align="center">
<img src="msgbk_btn.png">
</div>

	メッセージウィンドウのウィンドウの位置と大きさを指定します。
	ボタンやスライダーの位置は、メッセージバックのウィンドウの左上を基点に位置を指定します。

+ メッセージなどを表示する矩形

	メッセージや声アイコンなどを表示できる範囲です。この範囲で文字や画像は切り取られます。
	ウィンドウからのマージンで指定します。

+ フィルター

	「ファイルで指定する方法」と「矩形と色で指定する方法」があります。
	詳しくは [[メッセージウィンドウ枠個別の設定]] を参考にして下さい。

+ ボタンのアクション番号と効果音番号

	それぞれ [[ボタンアクションの設定]]、[[ボタン効果音の設定]] を参照して下さい。

+ スライダーの動く範囲

<div align="center">
<img src="msgbk_slider.png">
</div>

	スライダーの範囲は、Ｘ座標および、Ｙ座標の上端と下端を指定します。
	スライダーの画像がその範囲に納まるように動きます。

+ セパレーター

<div align="center">
<img src="msgbk_separator.png">
</div>

	セパレーターを画像で指定できます。
	セパレーターを指定した場合、文と文の間はその画像の大きさになります。
	セパレーターを指定しなかった場合、文字サイズ分だけ自動で空けられます。

+ ターゲットの文字色

	中央付近にあるメッセージは黄色になっていますが、<font color="red">デバッグ時のみです。</font>
	'P' キーを押したときにコピーされるメッセージは、黄色くなっているこのメッセージです。
	この色を変えることはできません。





















■ メッセージバックセーブの設定

	メッセージバックセーブに関する情報を設定します。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■メッセージバックセーブの設定
// =============================================================
#MESSAGE_BACK_SAVE.CNT = 100                   // メッセージバックセーブの個数
#MESSAGE_BACK_SAVE.INTERVAL = 1                // メッセージバックセーブの間隔
</pre>

++ #MESSAGE_BACK_SAVE.CNT

	何個セーブデータを作成するかを設定します。１００個程度で十分だと思います。
	それ以上増やす場合はメモリの使用量に注意してください。


++ #MESSAGE_BACK_SAVE.INTERVAL

	セーブデータを作成する間隔を設定します。
	１で毎メッセージごとに作成します。
	画面デザインによりますが、１～５程度が使いやすいようです。



■ フレームアクションの設定

	[[フレームアクション]] の設定を行います。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■フレームアクションの設定
// =============================================================
#FRAME_ACTION_CH.CNT = 16       // フレームアクションチャンネルの個数
</pre>

++ #FRAME_ACTION_CH.CNT

	フレームアクションチャンネルの個数を設定します。



■ エフェクトの設定

	[[エフェクト]] の設定を行います。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■エフェクトの設定
// =============================================================
#EFFECT.CNT = 4         // エフェクトの個数
</pre>

++ #EFFECT.CNT

	エフェクトの個数を設定します。



■ シェイクの設定

	[[シェイク]] の設定を行います。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■シェイクの設定
// =============================================================
#SHAKE.CNT = 4         // シェイクの個数
#SHAKE.000 = (0,8,64)(0,-8,64)(0,8,64)(0,-8,48)(0,8,32)
#SHAKE.001 = (-32,32,64)(-32,-32,64)(32,-32,64)(32,32,64)(16,-16,64)(-8,-8,64)(-4,4,48)(2,2,32)
</pre>

++ #SHAKE.CNT

	シェイクの個数を設定します。

++ #SHAKE.??? = ([x], [y], [time])...

	揺れをコマ単位で設定します。
	各コマの揺れＸ、Ｙ、かける時間を指定します。




■ クエイクの設定

	[[クエイク]] の設定を行います。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■クエイクの設定
// =============================================================
#QUAKE.CNT = 16         // クエイクの個数
</pre>

++ #QUAKE.CNT

	クエイクの個数を設定します。


■ エディットボックスの設定

	[[エディットボックス]] の設定を行います。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■エディットボックスの設定
// =============================================================
#EDITBOX.CNT = 4         // エディットボックスの個数
</pre>

++ #EDITBOX.CNT

	エディットボックスの個数を設定します。


■ ＢＧＭの設定

	[[ＢＧＭ]] の設定を行います。

	※ＣＤ－ＤＡの設定は削除されました。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■ＢＧＭの設定
// =============================================================
#BGM.CNT = 4         // ＢＧＭの個数
#BGM.001 = "朝",    "BGM001", 0, -1, 00000000
#BGM.002 = "学校１","BGM002", 0, -1, 00420518
</pre>

++ #BGM.CNT

	ＢＧＭの個数を設定します。

++ #BGM.??? = [登録名], [ファイル名], [開始位置], [終了位置], [リピート位置]

	※RealLive とは順番が違うので注意してください。

<div class="table-container">
<table>
|登録名|スクリプトから呼び出すときの名前を指定します。|
|ファイル名|音ファイルのファイル名を指定します。|
|開始位置|再生開始位置をサンプル位置で指定します。|
|終了位置|再生終了位置をサンプル位置で指定します。-1 で最後まで再生します。|
|リピート位置|リピート開始位置をサンプル位置で指定します。|
</table>
</div>

+ ＢＧＭの再生

	登録名で呼び出します。

<pre class="source">
bgm.play("朝")
</pre>





■ 効果音チャンネルの設定

	[[効果音チャンネル]] の設定を行います。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■効果音チャンネルの設定
// =============================================================
#PCMCH.CNT = 16         // 効果音チャンネルの個数
</pre>

++ #PCMCH.CNT

	効果音チャンネルの個数を設定します。


■ 効果音イベントの設定

	[[効果音イベント]] の設定を行います。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■効果音イベントの設定
// =============================================================
#PCMEVENT.CNT = 16         // 効果音イベントの個数
</pre>

++ #PCMEVENT.CNT

	効果音イベントの個数を設定します。


■ システム音の設定

	[[システム音]] の設定を行います。

	必ず 8 個以上作成してください。
	0 - 7 番はシステムが予約しています。

+ 設定ファイル

<pre class="source">
// *************************************************************
// ■システム音の設定
// =============================================================
#SE.CNT = 16         // システム音の個数

#SE.000 = "_se10"    // システム／選択
#SE.001 = "_se11"    // システム／決定
#SE.002 = "_se12"    // システム／キャンセル
#SE.003 = ""         // システム／警告
#SE.004 = ""         // システム／セーブ
#SE.005 = ""         // システム／ロード
#SE.006 = ""         // システム／タイトルに戻る
#SE.007 = ""         // システム／前の選択肢に戻る
</pre>

++ #SE.CNT

	システム音の個数を設定します。

++ #SE.??? = [ファイル名]

	０～７番はシステムが予約しています。

<div class="table-container">
<table>
|0|システム／選択|
|1|システム／決定|
|2|システム／キャンセル|
|3|システム／警告|
|4|システム／セーブ|
|5|システム／ロード|
|6|システム／タイトルに戻る|
|7|システム／前の選択肢に戻る|
</table>
</div>



■ 定義ファイル（*.inc）

	文字列の置き換えを行ったり、フラグを作成したりすることが出来ます。

+ 定義ファイルを作る

	ss フォルダの中に新規作成してください。拡張子は inc です。

<div class="table-container">
<table>
|system.inc|システム関連の定義を行う|
|flag.inc|ゲームで使用するフラグの定義を行う|
<caption>定義ファイルのファイル名の例</caption>
</table>
</div>

<pre class="source">
game
  +- exe
  |   +- SiglusEngine.exe
  |
  +- ss
  |   +- _start.ss
  |   +- _menu.ss
  |   +- Gameexe.ini
  |   +- <font color="red">flag.inc          // 定義ファイル。新規作成してください。</font>
  |
  +- tmp
  |
  +- SiglusCompiler.exe
</pre>

	定義ファイルでは、全シーンで共通して使う「置換」、「マクロ」、「ユーザフラグ」などを定義できます。

++ 定義ファイルの例

<pre class="source">
#replace    文字列                 文字列２
#define     @好感度                a[0]
#macro      @好感度アップ(@value)  @好感度 += (@value)
#property   $game_clear            : int
</pre>


■ シーン内定義

+ #inc_start / #inc_end

	#inc_start / #inc_end を使うことで、シーン内で定義を行うことが出来ます。
	シーン内で定義された置換やマクロは、そのシーン内でのみ適用されます。

+ シーン０１.ss

<pre class="source">
#z00

#inc_start
    #replace    文字列                 文字列２
    #define     @好感度                a[0]
    #macro      @好感度アップ(@value)  @好感度 += (@value)
#inc_end
</pre>


■ 置換

	置換を使ってフラグなどに名前をつけると、スクリプトの見た目が分かりやすくなります。

	例えば、主人公の体力、賢さ、運のよさ、など多くのフラグが必要だとします。
	それぞれ a[0]、a[1]、a[2]… のようにフラグを割り当てますが、
	そのままスクリプトに記述した場合、見通しが悪いです。

+ 見通しの悪いスクリプトの例

<pre class="source">
a[0] += 5
a[1] += 3
a[2] += 7
</pre>

	そこで、定義ファイルを使って、フラグに名前をつけます。

<h5>定義ファイル</h5>

<pre class="source">
#define     @体力                  a[0]
#define     @賢さ                  a[1]
#define     @運のよさ              a[2]
</pre>

<h5>見通しの良くなったスクリプトの例</h5>

<pre class="source">
@体力 += 5
@賢さ += 3
@運のよさ += 7
</pre>

	<font color="red">置換の先頭には、必ず @ をつけてください。</font>

+ 置換（define / replace）

	文字列の置換を行います。

++ 定義ファイル

<pre class="source">
#define     @好感度                a[0]
</pre>

++ シーン０１.ss

<pre class="source">
@好感度 += 1
</pre>

++ シーン０１.ss（置換後）

<pre class="result">
a[0] = 1
</pre>

+ 多重展開

	define による置換は、多重展開されます。

++ 定義ファイル

<pre class="source">
#define     @持ち物先頭            100
#define     @持ち物１              s[@持ち物先頭 + 0]
#define     @持ち物２              s[@持ち物先頭 + 1]
#define     @持ち物３              s[@持ち物先頭 + 2]
</pre>

++ 置換の流れ

<pre class="result">
@持ち物１ = "やくそう"
↓
s[@好感度先頭 + 0] = "やくそう"
↓
s[100 + 0] = "やくそう"
</pre>

+ 多重展開のよる無限ループ

	以下のような置換は失敗します。

<pre class="source">
#define     月宮            ruby(月宮) つきみや ruby
</pre>

++ 置換の流れ

<pre class="result">
月宮
↓
ruby(月宮) つきみや ruby
↓
ruby(ruby(月宮) つきみや ruby) つきみや ruby
↓
（…以下、無限ループ）
</pre>

	置換の先頭に @ をつけていれば問題ありませんが、どうしてもつけたくない場合もあります。
	その場合は replace を使ってください。replace は多重展開されない置換です。

++ 定義ファイル

<pre class="source">
#replace     月宮            ruby(月宮) つきみや ruby
</pre>

++ 置換の流れ

<pre class="result">
月宮
↓
ruby(月宮) つきみや ruby
</pre>



■ マクロ

	引数を使った置換です。

++ 定義ファイル

<pre class="source">
#define     @好感度                a[0]
#macro      @好感度アップ(@value)  @好感度 += (@value)
#macro      @好感度最大            @好感度 = 100
</pre>

++ 置換の流れ

<pre class="result">
@好感度アップ(10)
↓
@好感度 += (10)
↓
a[0] += (10)
</pre>

	引数のないマクロの場合は、() はあってもなくても大丈夫です。

<pre class="result">
@好感度最大
↓
@好感度 = 100
↓
a[0] = 100
</pre>

<pre class="result">
@好感度最大()
↓
@好感度 = 100
↓
a[0] = 100
</pre>

+ デフォルト引数

	デフォルト引数を設定することで、引数を省略することが出来ます。

++ 定義ファイル

<pre class="source">
#define     @好感度                   a[0]
#macro      @好感度アップ(@value<font color="red">(1)</font>)  @好感度 += (@value)
</pre>

++ 置換の流れ

<pre class="result">
@好感度アップ
↓
@好感度 += (1)    // ←引数を省略したので、デフォルト引数の 1 が使われます。
↓
a[0] += (1)
</pre>

<pre class="result">
@好感度アップ(10)
↓
@好感度 += (10)   // ←引数をつけたので、デフォルト引数は無視されます。
↓
a[0] += (10)
</pre>



■フラグ

	キャラクターの好感度、主人公の体力など、ゲームに関する値は、フラグを使って制御します。
	選んだ選択肢をフラグに保存しておくことで、選択肢によってシナリオを分岐することもできます。

	フラグには、整数フラグと文字列フラグがあります。
	それぞれ、整数、文字列を扱うことができます。
	小数や分数を扱うことはできません。

	[[整数]]、[[基本構文\文字列]] の項目も参照して下さい。

<div class="table-container">
<table>
<caption>フラグの割り当ての例</caption>
|a[0000]|キャラＡの好感度|
|a[0001]|キャラＢの好感度|
|a[0002]|キャラＣの好感度|
|b[0000]|主人公の体力|
|b[0001]|主人公の所持金|
|s[0000]|主人公の名前|
|g[0000]|ＣＧ１番を見た|
|g[0001]|ＣＧ２番を見た|
</table>
</div>



■ グローバル／ローカル／コールフラグ

+ グローバルフラグ

	全セーブデータで共通して持つフラグです。
	ＣＧ鑑賞モードを作る場合は、「ＣＧを見たか見てないか」を記憶する必要があります。
	この値は全セーブデータで共通して持つべきですので、グローバルフラグを使います。

	整数フラグが g, z の２種類あります。文字列フラグは m フラグのみです。
	それぞれ 1000 個ずつあります。（設定ファイルで変更できます。[[フラグの設定]] 参照）
	g, z の２つに違いはありません。分かりやすく使い分けてください。

<div class="table-container">
<table>
|表記|型|
|g[0000]～g[0999]|整数|
|z[0000]～z[0999]|整数|
|m[0000]～m[0999]|文字列|
</table>
</div>

+ ローカルフラグ

	セーブデータごとに持つフラグです。
	キャラクターの好感度などは各セーブデータが持つべきですので、ローカルフラグを使います。

	整数フラグが a, b, c, d, e, f の６種類あります。文字列フラグは s フラグのみです。
	それぞれ 1000 個ずつあります。（設定ファイルで変更できます。[[フラグの設定]] 参照）
	６つの整数フラグに違いはありません。分かりやすく使い分けてください。

<div class="table-container">
<table>
|表記|型|
|a[0000]～a[0999]|整数|
|b[0000]～b[0999]|整数|
|c[0000]～c[0999]|整数|
|d[0000]～d[0999]|整数|
|e[0000]～e[0999]|整数|
|f[0000]～f[0999]|整数|
|s[0000]～s[0999]|文字列|
</table>
</div>

+ コールフラグ

	gosub、farcall などのコール時、またはユーザコマンドが呼ばれたときに作られるフラグです。
	それぞれ 50 個ずつあります。（設定ファイルで変更できます。[[フラグの設定]] 参照）
	詳しくはコールの項目で説明します。
	非常に便利なフラグです。上手に使ってください。

<div class="table-container">
<table>
|表記|型|
|l[00]～l[49]|整数|
|k[00]～k[49]|文字列|
</table>
</div>



■ フラグの値の設定と表示

+ フラグの値を設定する

<pre class="source">
b[0000] = 100            // 体力を100に設定する
s[0000] = "理樹"         // 名前を「理樹」に設定する
</pre>

	演算については、[[整数の演算]]、[[コマンドを含めた演算]] などを参照して下さい。

+ フラグの値を表示する

	フラグの値を表示するには、print コマンドを使います。

<pre class="source">
a[0] = 100 + 200
計算結果は print(a[0]) です。r
</pre>

<pre class="result">
計算結果は300です。
</pre>





■ ビットフラグ

	フラグをビットに分解する機能です。
	通常のフラグは１つにつき 32bit 使い、-2147483648 ～ 2147483647 の整数を扱うことができます。
	これを細かく分解して使うことで、少ない容量で多くのフラグを扱うことができます。
	ただし、扱える数字も小さくなってしまいます。

	上級者向けの機能です。フラグが足りない場合に使って下さい。

	ローカルフラグはもちろん、グローバルフラグやコールフラグ、
	intlist 型のユーザフラグも対応しています。

	フラグの個数は、デフォルト（1000個）を基準に計算しています。
	フラグの個数が変更されるとビットフラグの個数も変更されます。

<h5>１ビット分解（値：0 or 1）</h5>

<pre class="exp">
a.bit[00000] ～ a.bit[31999]
</pre>

<h5>２ビット分解（値：0 ～ 3）</h5>

<pre class="exp">
a.bit2[00000] ～ a.bit2[15999]
</pre>

<h5>４ビット分解（値：0 ～ 15）</h5>

<pre class="exp">
a.bit4[00000] ～ a.bit4[07999]
</pre>

<h5>８ビット分解（値：0 ～ 255）</h5>

<pre class="exp">
a.bit8[00000] ～ a.bit8[03999]
</pre>

<h5>１６ビット分解（値：0 ～ 65535）</h5>

<pre class="exp">
a.bit16[00000] ～ a.bit16[01999]
</pre>





■ フラグを確認／編集する（デバッグ）

	デバッグメニューの「ｳｨﾝﾄﾞｳ」→「フラグ情報」で、現在のフラグの情報が確認できます。

	また、リストをダブルクリックすることで編集することもできます。

<div align="center">
<img src="フラグ情報.png">
</div>

	「ｳｨﾝﾄﾞｳ」→「★エレメント情報」でさらに高度な情報が確認できます。


■ 名前フラグ

	主人公の名前を、プレイヤーに入力させたいことがあると思います。
	s フラグなどの文字列フラグでも管理できますが、
	名前フラグを使うとより簡単に管理できます。

+ 名前フラグの種類

++ グローバル名前フラグ

	＊Ａ、＊Ｂ、…、＊Ｚ（26個）<br />
	＊ＡＡ、＊ＡＢ、…、＊ＺＺ（26×26 = 676 個）

	合計 702 個あります。

++ ローカル名前フラグ

	％Ａ、％Ｂ、…、％Ｚ（26個）<br />
	％ＡＡ、％ＡＢ、…、％ＺＺ（26×26 = 676 個）

	合計 702 個あります。

+ 名前フラグを使った例

<pre class="source">
【小鳥】「うん。いいよ」R
【小鳥】「<font color="red">＊Ａ</font>君がいいと思うのなら、やればいいと思うの」R
【小鳥】「それに本当にいい出会いになるかもしんないし」R
【<font color="red">＊Ａ</font>】「………いや、そういうのは」R
記憶の奥にしまった、ザリッとした記憶が一瞬だけよみがえる。R
【小鳥】「最近の<font color="red">＊Ａ</font>君、やる気なんだよね」R
【<font color="red">＊Ａ</font>】「…まあね」R
【小鳥】「協力する」R
【<font color="red">＊Ａ</font>】「…サンキュ」R
</pre>

	これらの名前フラグは、名前や文章中に埋め込むことができます。
	声撮りツールに通しやすくするため、積極的に使って下さい。





■ 名前フラグを設定／取得する

	名前フラグの扱いは少し特殊です。

+ 名前フラグの値を設定する

<pre class="source">
namae("％Ａ") = "しぐらす"
</pre>

+ 名前フラグの値を取得する

<pre class="source">
s[0] = namae("％Ａ")
</pre>

	名前は、エディットボックスなどでプレイヤーが入力できると便利です。
	マニュアルの [[エディットボックス]] やサンプルを参照し、上手く作って下さい。





■ 名前フラグを表示する

	名前フラグは、文章中に記述すると自動的に展開されます。

+ 文章中に使う

<pre class="source">
【<font color="red">＊Ａ</font>】「僕の名前は<font color="red">＊Ａ</font>だよ！」r
</pre>

<pre class="result">
【<font color="red">太郎</font>】僕の名前は<font color="red">太郎</font>だよ！
</pre>

+ 選択肢で使う

	sel などの選択肢、selbtn などのボタン選択肢にも使えます。

<pre class="source">
l[0] = sel(<font color="red">＊Ａ</font>, <font color="red">＊Ｂ</font>)
</pre>

<pre class="result">
　<font color="red">太郎</font>
　<font color="red">次郎</font>
</pre>

+ print 文で使用する

	print 文で使うこともできます。文字列を高度に扱うときに使って下さい。

<pre class="source">
s[0] = <font color="red">"＊Ａ"</font>
<font color="red">print(s[0])</font>のレベルが上がった！r
</pre>

<pre class="result">
<font color="red">太郎</font>のレベルが上がった！
</pre>



■ 名前フラグの一部を表示する

	＊Ａ０、＊Ａ１、…で名前の１文字目、２文字目…を表示できます。
	＊Ａ＝たろう　とした場合、＊Ａ０＝た、＊Ａ１＝ろ、＊Ａ２＝う　となります。

+ サンプル：名前フラグの一部を表示する機能の有効な使い方１

<pre class="source">
namae("＊Ａ") = 太郎
namae("＊Ｂ") = たろう
「＊Ｂ０、＊Ａ…」r
</pre>

<pre class="result">
「た、太郎…」
</pre>

+ サンプル：名前フラグの一部を表示する機能の有効な使い方２

<pre class="source">
namae("＊Ａ") = 太郎
namae("＊Ｂ") = たろう
「＊Ｂ０～＊Ｂ１～＊Ｂ２！！」r
</pre>

<pre class="result">
「た～ろ～う！！」
</pre>




■ 名前フラグを確認／編集する（デバッグ）

	デバッグメニューの「ｳｨﾝﾄﾞｳ」→「名前フラグ情報」で、現在の名前が確認できます。

	また、リストをダブルクリックすることで編集することもできます。

<div align="center">
<img src="名前フラグ情報.png">
</div>



■ エレメント

+ エレメント

	Siglus は、いろいろなエレメントを持っています。
	絵を表示するためには、「オブジェクト（object）」というエレメントを使います。
	時間を計測するためには、「カウンタ（counter）」というエレメントを使います。

	エレメントには「コマンド」と「プロパティ」があります。
	r、owari、returnmenu など、エンジンに命令を行うエレメントを「コマンド」と言います。
	対して a[0] といったフラグ、object、counter などは「プロパティ」と言います。

+ エレメントの子エレメント

	エレメントは、さらに子エレメントを持つことがあります。
	例えば、オブジェクトというエレメントには、位置を表すプロパティ（x, y）、画像を読み込むコマンド（create）などを持っています。

<pre class="source">
// フロントステージのオブジェクト０番のプロパティ x に 100 を代入する
front.object[0].x = 100

// フロントステージのオブジェクト０番に "BG001" という画像を読みこむ
front.object[0].create(BG001, 1)

// バックステージのオブジェクト１０番のプロパティ y をフラグ a[0] に代入する
a[0] = back.object[10].y
</pre>


■ 型

+ 型

	Siglus では、「型」の概念が非常に重要になります。
	全ての式やエレメントは、必ず「型」を持ちます。
	例えば、100 と言った整数や a[0] と言った整数を扱うフラグは、「int 型」という型になります。
	"abc" や s[0] と言った文字列は「str 型」になります。

<div class="table-container">
<table>
|型|型の意味|例|
|void|なし|print など、戻り値を持たないコマンド|
|int|整数|100, -5, a[0], g[0], l[0]<br />3 + 5 などの式<br />mouse.get_x など、整数を返すコマンド|
|intlist|整数の配列|a, g, l|
|str|文字列|"abc", あいうえお, s[0], m[0], k[0]<br />get_title など、文字列を返すコマンド|
|strlist|文字列の配列|s, m, k|
|stage|ステージ|front, back|
|object|オブジェクト|front.object[0]|
|...|||
</table>
</div>

	型の一覧については [[エレメント一覧]] を参照して下さい。

<img src="型.png">


■ 整数

+ 整数

	整数は int 型のエレメントです。
	Siglus では -2147483648 ～ 2147483647 までの整数を扱えます。
	小数や分数を扱うことはできません。

+ １０進数、１６進数、２進数

	Siglus では１０進数の他に、１６進数、２進数が扱えます。
	16進数は 0x???、2進数は 0b???、と書きます。

<div class="table-container">
<table>
|表記|値|
|100|100（10進数）|
|<font color="red">0x</font>FF|255（16進数）|
|<font color="red">0b</font>1000|8（2進数）|
</table>
</div>




■ 整数の演算

<pre class="source">
a[0] = a[0] + 10                  // 好感度を１０あげる
a[1] *= 2                         // 攻撃力を２倍にする
a[2] = ((b[0] * 2) - b[1]) / 4    // ダメージを計算する
</pre>

+ 基本演算

<div class="table-container">
<table>
|整数 + 整数|加算（足し算）|
|整数 - 整数|減算（引き算）|
|整数 * 整数|乗算（掛け算）|
|整数 / 整数|除算（割り算）|
|整数 % 整数|剰余算（余り）|
</table>
</div>

++ 例

<pre class="source">
print(10 + 3)r
print(10 - 3)r
print(10 * 3)r
print(10 / 3)r
print(10 % 3)r
</pre>

++ 実行結果

<pre class="result">
13       // 10＋3 = 13
7        // 10－3 = 7
30       // 10×3 = 30
3        // 10÷3 = 3（余りは切り捨て）
1        // 10÷3 の余りは 1
</pre>

	演算はつなげることもできます。"()" を使うこともできます。

<pre class="source">
a[0] = ((b[0] * 2) - b[1]) / 4    // ドラクエ風のダメージを計算する
</pre>

+ 論理演算

	上級者向けの演算です。普通は使わないと思います。ビット演算が分かる方は使って下さい。

<div class="table-container">
<table>
|~ 整数|NOT 演算（論理否定）|
|整数 &amp; 整数|AND 演算（論理積）|
<tr><td>整数 | 整数</td><td>OR 演算（論理和）</td></tr>
|整数 ^ 整数|XOR 演算（排他的論理和）|
|整数 &lt;&lt; 整数|左シフト演算|
|整数 &gt;&gt; 整数|右シフト演算（算術）|
|整数 &gt;&gt;&gt; 整数|右シフト演算（論理）|
</table>
</div>

	通常の整数フラグでシフト演算を行った場合、左シフトは論理シフト、右シフトは算術シフトになります。
	[[ビットフラグ]] の場合は負の数がないので、右シフトも論理シフトになります。

	「&gt;&gt;&gt;」を使った場合は、強制的に論理シフトになります。

<pre class="source">
a[0] = 0b11011111111111111111111111111111
a[1] = a[0] &lt;&lt; 2
print(a[0])
</pre>

	a[1] は 0b01111111111111111111111111111100 となります。








■ 文字

+ 文字コード

	あまり使わないと思います。
	文字を ''（シングルコーテーション）で囲むことで、その文字の文字コードを取得できます。
	全角文字も扱えます。
	文字列の先頭がアルファベットの場合は…などの処理に使います。

<div class="table-container">
<table>
|表記|値|意味|
|'a'|97|a（小文字）|
|'A'|65|A（大文字）|
|'Ａ'|65313|Ａ（全角）|
|'ｱ'|65393|ｱ（半角カタカナ）|
|'あ'|12354|あ（全角ひらがな）|
|<font color="red">'\\'</font>|92|\（円記号）|
|<font color="red">'\''</font>|39|'（シングルコーテーション）|
|'&quot;'|34|&quot;（ダブルコーテーション）|
</table>
</div>

	文字コードは int 型です。次の２つの処理は全く同じ意味になります。

<pre class="source">
if (a[0] == 'A') { /* 何か処理 */ }
if (a[0] == 65)  { /* 何か処理 */ }
</pre>

	Siglus では、Unicode（UTF-16）を採用しています。
	文字コード一覧については、インターネット上で「Unicode 文字一覧表」などで検索して下さい。

+ 先頭がアルファベットかどうかを調べる

<pre class="source">
// *************************************************************
// 文字列 s[0] の１文字目がアルファベットかどうかを調べるサンプル
// =============================================================

// s[0] に "abc" を代入する
s[0] = "abc"

// s[0] の１文字目の文字コードを取得する
a[0] = s[0].get_code(0)

// 文字コードを比較し、アルファベットかどうかを調べる
if (('A' <= a[0] && a[0] <= 'Z') || ('a' <= a[0] && a[0] <= 'z'))    {
    「print(s[0])」の１文字目はアルファベットです。r
}
else    {
    「print(s[0])」の１文字目はアルファベットではありません。r
}

// s[0] に "あいうえお" を代入する
s[0] = "あいうえお"

// s[0] の１文字目の文字コードを取得する
a[0] = s[0].get_code(0)

// 文字コードを比較し、アルファベットかどうかを調べる
if (('A' <= a[0] && a[0] <= 'Z') || ('a' <= a[0] && a[0] <= 'z'))    {
    「print(s[0])」の１文字目はアルファベットです。r
}
else    {
    「print(s[0])」の１文字目はアルファベットではありません。r
}
</pre>

<pre class="result">
「abc」の１文字目はアルファベットです。r
「あいうえお」の１文字目はアルファベットではありません。r
</pre>


■ 文字列

+ 文字列

	文字列は &quot;&quot;（ダブルクォート）で囲みます。
	全角文字のみの場合は &quot;&quot; を省略できます。

<div class="table-container">
<table>
|表記|意味|
|&quot;abc&quot;|abc|
|&quot;あいうえお&quot;|あいうえお|
|<font color="red">あいうえお</font>|あいうえお|
|&quot;\\&quot;|\（円記号）|
|&quot;\&quot;&quot;|&quot;（ダブルコーテーション）|
|&quot;'&quot;|'（シングルコーテーション）|
|&quot; &quot;|&nbsp;（半角スペース）|
</table>
</div>

+ 文字列の例外

	コマンドの引数や代入文の右辺としてのみ、半角文字列も文字列として扱います。

<pre class="source">
front.object[0].create("BG001", 1, 0, 0)
front.object[0].create(BG001, 1, 0, 0)     // これでもＯＫ
</pre>

	危険な処理ですが、手間を考えると圧倒的に楽になります。
	また、声撮りに関してもこの方が都合が良いです。


■ 文字列の演算

+ 基本演算

	文字列には足し算と掛け算があります。

<div class="table-container">
<table>
|文字列 + 文字列|加算（足し算）|"abc" + "def" -> "abcdef"|
|文字列 * 整数|乗算（掛け算）|"abc" * 3 -> "abcabcabc"|
</table>
</div>






■ 代入

	代入は "=" を使います。

<pre class="source">
a[0] = 10        // a[0] に 10 を代入する
a[0] = 30 + 5    // a[0] に 30 + 5 の結果を代入する
</pre>

	文字列も整数と同じように、文字列フラグに代入できます。

<pre class="source">
s[0] = "abc"     // s[0] に "abc" を代入する
</pre>

+ 代入演算

	代入と演算を同時に行えます。

<pre class="source">
a[0] += 5           // a[0] = a[0] + 5 と同じ
a[0] *= 10 + a[1]   // a[0] = a[0] * (10 + a[1]) と同じ
s[0] += "def"       // s[0] = s[0] + "def" と同じ
</pre>

<div class="table-container">
<table>
<caption>代入演算子一覧</caption>
|a[0] += 整数|加算代入（足し算）|
|a[0] -= 整数|減算代入（引き算）|
|a[0] *= 整数|乗算代入（掛け算）|
|a[0] /= 整数|除算代入（割り算）|
|a[0] %= 整数|剰余算代入（余り）|
|a[0] &amp;= 整数|AND 演算代入（論理積）|
<tr><td>a[0] |= 整数</td><td>OR 演算代入（論理和）</td></tr>
|a[0] ^= 整数|XOR 演算代入（排他的論理和）|
|a[0] &lt;&lt;= 整数|左シフト演算代入|
|a[0] &gt;&gt;= 整数|右シフト演算代入（算術）|
|a[0] &gt;&gt;&gt;= 整数|右シフト演算代入（論理）|
|s[0] += 文字列|加算代入（足し算）|
|s[0] *= 整数|乗算代入（掛け算）|
</table>
</div>








■ 条件演算

+ 等号・不等号

<div class="table-container">
<table>
|整数 == 整数|左と右が等しい|
|整数 != 整数|左と右が等しくない|
|整数 &gt;= 整数|右より左が大きいか等しい|
|整数 &lt;= 整数|右より左が小さいか等しい|
|整数 &gt; 整数|右より左が大きい|
|整数 &lt; 整数|右より左が小さい|
|文字列 == 文字列|左と右が等しい|
|文字列 != 文字列|左と右が等しくない|
</table>
</div>

++ 例

<pre class="source">
// a[0] が 0 の時に文字列を表示するサンプル
if (a[0] == 0) {
    print("こんにちは。")r
}

// a[0] が 5 より等しい時に文字列を表示するサンプル
if (a[0] >= 5) {
    print("こんばんは。")r
}
</pre>

	文字列の比較は、大文字小文字を無視して比較します。

<pre class="source">
s[0] = "abc"
if (s[0] == "ABC") {
    /* ... */              // ここを通る
}
</pre>



+ 条件演算

<div class="table-container">
<table>
|A &amp;&amp; B|A と B が両方成り立つ|
<tr><td>A || B</td><td>A と B の片方、または両方が成り立つ</td></tr>
</table>
</div>

<pre class="source">
// a[0] が 0、かつ b[0] が 0 の時に文字列を表示するサンプル
if (a[0] == 0 &amp;&amp; b[0] == 0) {
	print("こんにちは。")r
}

// a[0] と b[0] のどちらか片方、または両方が 95 以上のときに文字列を表示するサンプル
if (a[0] >= 95 || b[0] >= 95) {
	print("合格です！")r
}
</pre>







■ コマンドを含めた演算

	演算にはコマンドを含めることもできます。

<pre class="source">
a[0] = counter[0].get + 10

if (get_title == "５月１４日") { /* ... */ }

if (s[0].left(2) == "BS" && s[0].mid(4, 3) == "001" ) { /* ... */ }
</pre>


■ 分岐

+ if / elseif / else

	if 文を使ってスクリプト処理を分岐できます。
	選択肢によってシナリオを変更する時などに使います。

<pre class="source">
// 選択肢を表示します。
// 「選択肢１」が選ばれた場合、a[0] に 0 が代入されます。
// 「選択肢２」が選ばれた場合、a[0] に 1 が代入されます。
// 「選択肢３」が選ばれた場合、a[0] に 2 が代入されます。
a[0] = sel("選択肢１", "選択肢２", "選択肢３")

// a[0] の値でシナリオを分岐します。
if (a[0] == 0) {

    // a[0] が 0 の場合はここを通ります。
    選択肢１が選ばれました。r
}
elseif (a[0] == 1)  {

    // a[0] が 1 の場合はここを通ります。
    選択肢２が選ばれました。r
}
else  {

    // それ以外の場合はここを通ります。
    選択肢３が選ばれました。r
}
</pre>

	複雑な条件文を書くこともできます。

<pre class="source">
// #define @１度ゲームをクリアした g[0]
// #define @キャラＡの好感度       a[0]
// #define @キャラＢの好感度       a[1]

// １度でもゲームをクリアしたか、もしくは、
// キャラＡとＢの両方の好感度が１０以上の場合、隠しシナリオを表示する
if (@１度ゲームをクリアした || (@キャラＡの好感度 >= 10 && @キャラＢの好感度 >= 10)) {

    // ここに隠しシナリオを記述する
}
</pre>


+ switch / case / default

	条件が単純で数の多い分岐の時は、switch 文を使うと楽です。

<pre class="source">
どのシナリオを読みますか？

// 選択肢を表示する
// 選んだ結果によって、a[0] に 0～7 が入る
// 右クリックでキャンセルすると、-1 が入る
a[0] = sel_cancel(
    "プロローグ",
    "第１章",
    "第２章",
    "第３章",
    "第４章",
    "エンディングＡ",
    "エンディングＢ",
    "ゲームを終了する"
    )

// a[0] の値によって飛び先を分岐する
// 7 もしくは -1 が入っている場合はゲームを終了する
switch (a[0]) {
    case (00)   jump("プロローグ")
    case (01)   jump("第１章")
    case (02)   jump("第２章")
    case (03)   jump("第３章")
    case (04)   jump("第４章")
    case (05)   jump("エンディングＡ")
    case (06)   jump("エンディングＢ")
    default     owari
}
</pre>



■ ループ

+ while

	while 文を使って処理を繰り返すことができます。

<pre class="exp">
while (条件式)  {
    // ...
}
</pre>

++ 処理を１０回繰り返す

<pre class="source">
// フラグを初期化します。
a[0] = 0

// a[0] が 10 より小さい間、{ } の中を実行し続けます。
<font color="red">while (a[0] < 10)   {</font>

    print(a[0])回目です。r

    // a[0] の値を１増やします。
    a[0] += 1
<font color="red">}</font>
</pre>

<pre class="result">
0
1
2
3
4
5
6
7
8
9
</pre>

	※for 文を使った方が綺麗に書けます。

++ 無限ループ

<pre class="source">
<font color="red">while (1)  {</font>
    この処理は無限に繰り返されます。r
<font color="red">}</font>
</pre>

	必ず break 文などでループを抜け出すようにして下さい。


+ for

	for 文を使って処理を繰り返すことができます。

<pre class="exp">
for (初期化文, 条件式, ループ文)  {
    // ...
}
</pre>

<ul>
- １．初期化文が実行されます。
- ２．条件式が真の場合、{ } の中身が実行されます。
- ３．ループ文が実行されます。
- ４．２に戻ります。
</ul>

++ 処理を１００回繰り返す

<pre class="source">
<font color="red">for (a[0] = 0, a[0] < 100, a[0] += 1)   {</font>
    print(a[0])回目です。r
<font color="red">}</font>
</pre>

<pre class="result">
0
1
2
3
4
5
6
7
8
9
</pre>

++ オブジェクトの１０番～１９番を表示する

<pre class="source">
<font color="red">for (a[0] = 10, a[0] < 20, a[0] += 1)   {</font>

    // オブジェクト a[0] 番を表示する
    front.object[ a[0] ].disp = 1
<font color="red">}</font>
</pre>

+ break

	ループ文を脱出します。

++ 効果音を再生し、１０秒たてば次へ進む

<pre class="source">
// 効果音を再生します。
pcm.play(fanfare)

// カウンタをスタートさせます。
counter[0].start

// 無限ループに入ります。
while (1)  {

    // カウンタの値を取得し、１０秒（10000ﾐﾘ秒）を超えたらループを脱出します。
    if (counter[0].get > 10000)  {
        <font color="red">break</font>
    }

    // 画面を更新します。
    disp
}
</pre>

	※timewait コマンドを使うと簡単です。⇒[[時間待ち]]

+ continue

	次のループに入ります。

++ 表示されているオブジェクトに対して不透明度を半分に設定する


<pre class="source">
// オブジェクト０番～９番まで処理
for (a[0] = 0, a[0] < 10, a[0] += 1)  {

    // オブジェクトが表示されていない場合は次のループへ
    if (front.object[ a[0] ].disp == 0)   {
       <font color="red">continue</font>
    }

    // オブジェクト a[0] 番の不透明度を設定する
    front.object[ a[0] ].tr = 128
}
</pre>


■ ラベルとラベルジャンプ

+ #label / goto

<pre class="exp">
#label
goto #label
</pre>

	ラベルを作成することで、その場所にジャンプすることができます。

++ _start.ss

<pre class="source">
#z00

ここからスタートします。r
                            //
goto #label_01              // ─┐
                            //   │
ここは実行されません。r     //   │  ラベルまでジャンプする
                            //   │
#label_01                   // ←┘
                            //
ここが実行されます。r

owari
</pre>

++ 実行結果

<pre class="result">
ここからスタートします。
ここが実行されます。
</pre>

■ Ｚラベルとシーンジャンプ

+ jump

<pre class="exp">
jump($scene_name)
jump($scene_name, $z_label_no)
</pre>

	jump を使うことで、別のシーンにジャンプすることができます。
	正確には、シーンの #z00 がある位置にジャンプします。

++ _start.ss

<pre class="source">
#z00

ここからスタートします。r

jump("５月１４日")
</pre>

++ ５月１４日.ss

<pre class="source">
#z00

次にここが実行されます。r

owari
</pre>

+ Ｚラベル

	Ｚラベルを使うと、シーンの途中にジャンプすることができます。
	Ｚラベルは、#z00 ～ #z999 の合計1000個作ることができます。

<div class="chips">
(2012/04/13) 使えるZラベルが999まで増えました。今までは99まででした。
</div>

++ ５月１４日.ss

<pre class="source">
#z00

jump("５月１５日", 01)       // ５月１５日.ss の #z01 にジャンプします。
</pre>

++ ５月１５日.ss

<pre class="source">
#z00

ここは実行されません。r

#z01

最後にここが実行されます。r

owari
</pre>



■ コール

+ コールの注意点

	<font color="red">
	ラベルコールやシーンコールから戻るのに、goto や jump などを使ってはいけません！
	goto や jump で抜け出すと、後述する「コールフラグ」が残ったままになります。
	コールフラグがたまり続けると、「スタックオーバーフロー」という致命的なエラーになります。
	gosub を使った場合は、必ず return で戻ってください。
	</font>

+ ラベルコール

<pre class="exp">
gosub #label
return
</pre>

	ラベルジャンプと似てますが、ラベルコールの場合は、return 文で呼び出し元に戻ることができます。

++ _start.ss

<pre class="source">
#z00

ここからスタートします。r

gosub #label_01

ここが最後に実行されます。r

owari

#label_01

ラベルコールされました。r

return
</pre>

++ 実行結果

<pre class="result">
ここからスタートします。
ラベルコールされました。
ここが最後に実行されます。
</pre>

+ シーンコール

<pre class="exp">
farcall($scene_name)
farcall($scene_name, $z_label_no)
</pre>

	シーンジャンプと似てますが、シーンコールの場合は、return 文で元のシーンに戻ることができます。

++ _start.ss

<pre class="source">
#z00

ここからスタートします。r

farcall("５月１４日")           // ５月１４日.ss の #z00 をコールします。
farcall("５月１５日", 01)       // ５月１５日.ss の #z01 をコールします。

ゲームを終了します。r

owari

</pre>

++ ５月１４日.ss

<pre class="source">
#z00

次にここが実行されます。r

return                             // 呼び出し元に戻ります。
</pre>

++ ５月１５日.ss

<pre class="source">
#z00

ここは実行されません。r

return

#z01

最後にここが実行されます。r

return                             // 呼び出し元に戻ります。
</pre>

++ 実行結果

<pre class="result">
ここからスタートします。
次にここが実行されます。
最後にここが実行されます。
ゲームを終了します。
</pre>



■ コールフラグ

	ラベルコールやシーンコールが行われると、コールフラグ（l フラグ、k フラグ）が作られます。
	コールフラグは、コールが行われる度に新たに作られ、return などで戻ると自動的に消滅します。

<pre class="source">
#z00

    l[0] = 100
    "l[0] " の値は print(l[0]) です。r
    gosub #label
    "l[0] " の値は print(l[0]) です。r

    owari

#label

    l[0] = 200
    "l[0] " の値は print(l[0]) です。r

    return
</pre>

++ 実行結果

<pre class="result">
100
200
100
</pre>

	コール内で一時的にしか使わない場合は、積極的にコールフラグを使ってください。


■ コールの引数と戻り値

+ コールの引数

	ラベルコールやシーンコールは、引数を持つことも出来ます。

<pre class="exp">
gosub(100, "abc") #label
farcall("５月１４日", 0, 100, "abc")
</pre>

	引数は、コールフラグを使って受け取ります。
	渡された順に、整数なら l フラグ、文字列なら k フラグが受け取ります。

++ 整数を渡す

<pre class="source">
gosub(100, 200, 300) #label

#label

    // l[0] = 100
    // l[1] = 200
    // l[2] = 300

    return
</pre>

++ 文字列を渡す

<pre class="source">
gosub("abc", "def") #label

#label

    // k[0] = "abc"
    // k[1] = "def"

    return
</pre>

++ 整数と文字列を混ぜて渡す

<pre class="source">
gosub(100, 200, "abc", 300, "def") #label

#label

    // l[0] = 100
    // l[1] = 200
    // k[0] = "abc"
    // l[2] = 300
    // k[1] = "def"

    return
</pre>

+ コールの戻り値

	ラベルコールやシーンコールは、戻り値を受け取ることもできます。

<pre class="source">
a[0] = gosub(100, 200) #plus
print(a[0])
owari

#plus

    // l[0] = 100
    // l[1] = 200

    return(l[0] + l[1])
</pre>

<pre class="result">
300
</pre>

	return に引数をつけると、その結果を gosub / farcall は受け取ります。

	例では、gosub は #plus に 100, 200 を渡しています。
	#plus は、100 + 200、つまり 300 を返します。
	gosub は 300 を受け取り、a[0] に代入されます。


■ ユーザフラグ

	フラグは、定義ファイルなどを利用して独自に作成することも出来ます。これをユーザフラグと呼びます。

	ローカルフラグのみ対応しています。グローバルフラグを作ることは出来ません。

	<font color="red">フラグ名の先頭には、必ず "$" をつけてください。</font>

	ユーザフラグには、３つの作り方があります。

<ul>
- 定義ファイルで作る

	定義ファイルで作られたユーザフラグは、全てのシーンで共通して使うことが出来ます。

- シーンファイルで作る

	シーンファイルで作られたユーザフラグは、そのシーンでのみ使うことが出来ます。

- ユーザコマンド内で作る

	そのユーザコマンド内でのみ使うことが出来ます。
	ユーザコマンド内で作られたユーザフラグは、コールフラグとなります。コールする度に作られ、コールから抜けると破棄されます。

</ul>



■ 定義ファイルでユーザフラグを作る

+ 定義ファイルでユーザフラグを作る

++ 定義ファイル

<pre class="source">
#property   $point : int
#property   $name : str
</pre>

	名前の後ろに &quot;: 型名&quot; をつけ、フラグの型を指定します。

++ _start.ss

<pre class="source">
#z00

// $name に名前を、$point に好感度を代入する
$name = "舞"
$point = 5

// 好感度を１あげる
$point += 1

// 結果を表示する
print($name)の好感度が１あがった！r
現在の好感度はprint($point)です。r

// ゲームを終了する
owari
</pre>

++ 実行結果

<pre class="result">
舞の好感度が１あがった！
現在の好感度＝6
</pre>

+ 型名を省略する

<pre class="source">
#property   $point
</pre>

	型名を省略した場合は int 型（整数）になります。


■ シーン内定義でユーザフラグを作る

++ _start.ss

<pre class="source">
#z00

#inc_start
    #property   $mouse_x
    #property   $mouse_y
#inc_end

$mouse_x = mouse.pos_x
$mouse_y = mouse.pos_y
マウス座標は "(" print($mouse_x) "," print($mouse_y) ")" です。r

owari
</pre>

	※mouse.pos_x、mouse.pos_y は、マウスの位置を調べるコマンドです。

++ 実行結果

<pre class="result">
マウス座標は(100,200)です。
</pre>


■ ユーザコマンド内でユーザフラグを作る

++ ５月１４日.ss

<pre class="source">
#z00

$hello

owari

command $hello
{
    property $i

    for ($i = 0, $i < 3, $i += 1){
        こんにちは！r
    }
}
</pre>

++ 実行結果

<pre class="result">
こんにちは！
こんにちは！
こんにちは！
</pre>



 ユーザフラグで配列を作る

++ 定義ファイル

<pre class="source">
#property   $point : intlist[3]
#property   $string : strlist[3]
</pre>

++ _start.ss

<pre class="source">
#z00

$point[0] = 72
$point[1] = 39
$point[2] = 55
for ($i = 0, $i < 3, $i += 1)   {
    print($i + 1)人目の点数はprint($point[$i])です。
}

owari
</pre>

++ 実行結果

<pre class="result">
1人目の点数は72点です。
2人目の点数は39点です。
3人目の点数は55点です。
</pre>


■ ユーザコマンド

	コマンドも自分で作ることができます。これをユーザコマンドと呼びます。

	<font color="red">ユーザフラグと同じく名前の先頭には、必ず "$" をつけてください。</font>

	ユーザコマンドには、２つの作り方があります。

<ul>
- そのシーンでのみ使えるコマンドを作る

	シーンファイルでコマンドを作った場合、
	そのシーンでのみ使うことができるコマンドになります。

- 全てのシーンで使えるコマンドを作る

	シーンファイルで作ったコマンドを定義ファイルで宣言することで、
	そのコマンドは全てのシーンで使えるようになります。

</ul>


■ ユーザコマンドを作る

++ _start.ss

<pre class="source">
#z00

$hello                // コマンド $hello を呼び出します。

owari                 // ゲームを終了します。

command $hello        // ここから、コマンド $hello の中身です。
{
    こんにちは。r
}
</pre>

<pre class="result">
こんにちは。
</pre>

	command { } を使ってコマンドを作ります。
	コマンドを呼び出す場合は、通常のコマンドと同じように、コマンドの名前を書くだけです。


■ ユーザコマンドの引数と戻り値

+ 引数

	ユーザコマンドに引数を持たせることができます。

++ _start.ss

<pre class="source">
$plus(10, 20)     // コマンド $plus に引数 10, 20 を渡して呼び出します。
$plus(-30, 50)    // コマンド $plus に引数 -30, 50 を渡して呼び出します。

owari             // ゲームを終了します。

// コマンド $plus の定義です。
command $plus(<font color="red">property $a : int, property $b : int</font>)
{
    print($a + $b)r   // ２つの引数を足し算した結果を表示します。
}
</pre>

++ 実行結果

<pre class="result">
30
20
</pre>

	型を省略した場合は、int 型になります。

<pre class="source">
// 上の例と同じコマンドです。
command $plus(<font color="red">property $a, property $b</font>)
{
    print($a + $b)r   // ２つの引数を足し算した結果を表示します。
}
</pre>


+ 戻り値

	ユーザコマンドが値を返すこともできます。

++ _start.ss

<pre class="source">
#z00

a[0] = $plus(10, 20)     // コマンド $plus に引数 10, 20 を渡して呼び出します。
                         // 戻り値を a[0] フラグで受け取ります。

計算結果は print(a[0]) です。r    // a[0] の値を表示します。

owari                    // ゲームを終了します。r

// コマンド $plus の定義です。
command $plus(property $a : int, property $b : int)<font color="red"> : int</font>
{
    <font color="red">return ($a + $b)</font>
}
</pre>

<h5>実行結果</h5>

<pre class="result">
30
20
</pre>

	型を省略した場合は、int 型になります。

<pre class="source">
// 上の例と同じコマンドです。
command $plus(property $a : int, property $b : int)
{
    <font color="red">return ($a + $b)</font>
}
</pre>


■ 全てのシーンで使えるユーザコマンド

	ユーザコマンドを作っただけでは、そのユーザコマンドはそのシーン内でしか呼び出せません。

	全てのシーンで呼び出せるユーザコマンドを作るには、
	ユーザコマンドを<font color="red">シーンファイルで作成し、定義ファイルで宣言する</font>必要があります。

++ 定義ファイル

<pre class="source">
#command    $hello
#command    $plus(int, int) : int
</pre>

++ command.ss

<pre class="source">
// コマンドをまとめたシーンファイルです。

command $hello
{
    こんにちは。r
}

command $plus(property $a : int, property $b : int) : int
{
    return ($a + $b)
}
</pre>

++ シナリオ１.ss

<pre class="source">
// シナリオ１です。

$hello                // 定義ファイルで宣言しているコマンドは、他のシーンからも呼び出せます。

a[0] = $plus(10, 20)  // 定義ファイルで宣言しているコマンドは、他のシーンからも呼び出せます。
</pre>

+ 注意点

<ul>
- command の前に &quot;#&quot; が必要です。
- 引数がないコマンドの場合は、() は必要ありません。
- 引数の型は、int 型であっても省略できません。
</ul>


■ コールフラグ

	ユーザコマンドを呼び出した場合も、コールフラグが作られます。

<pre class="source">
command $plus(property $a : int, property $b : int) : int
{
    l[0] = $a + $b

    return(l[0])
}
</pre>


■ 整数配列

	整数配列についての説明です。
	通常の a～f と言ったフラグも整数配列であることに注意して下さい。

+ 代表的な整数配列

<ul>
- a フラグ、g フラグ、l フラグなどのフラグ
- intlist 型のユーザフラグ
- オブジェクトの修正座標
</ul>

+ 初期化する

<pre class="exp">
a.init                 // a フラグを初期化する
</pre>

	配列を初期化します。
	resize で個数を変更していた場合、個数も元に戻ることに注意して下さい。

+ 要素の個数を変更する

<pre class="exp">
l.resize($cnt)         // l フラグの個数を $cnt 個にする
</pre>

	コールフラグの個数の変更は、そのコール内でのみ有効です。

<div class="chips">
このコマンドで a フラグ、g フラグなどの個数を変更することはできません。
l フラグ、オブジェクトの修正座標、などの個数を変更することができます。
</div>

+ 要素の個数を取得する

<pre class="exp">
a[0] = l.get_size      // l フラグの個数を取得する
</pre>

+ 値を一括で設定する

<pre class="exp">
a.sets($top, $value, $value, ...)
</pre>

	配列の $top から、値を順に設定します。

<h5>使い方の例</h5>

<pre class="source">
a.sets(0, 10, 11, 12)      // a[0] = 10  a[1] = 11  a[2] = 12
a.sets(100, 0, 1, 2, 3)    // a[100] = 0  a[101] = 1  a[102] = 2  a[103] = 3
</pre>

+ 値を一括でクリアする

<pre class="exp">
a.clear($start_index, $end_index)
a.clear($start_index, $end_index, $value)
</pre>

	値を $value でクリアします。$value を省略すると 0 でクリアします。

<h5>使い方の例</h5>

<pre class="source">
a.clear(0, 3)      // a[0] = 0  a[1] = 0  a[2] = 0  a[3] = 0
a.clear(2, 5, 100) // a[2] = 100  a[3] = 100  a[4] = 100  a[5] = 100
</pre>







■ 数値演算

+ 最大値、最小値を求める

<pre class="exp">
a[0] = math.max($a, $b)
a[0] = math.min($a, $b)
</pre>

	２つの値のうち、大きい（小さい）方の値を求めます。

+ 範囲内に収める

<pre class="exp">
a[0] = math.limit($a, $num, $b)
</pre>

	$num を、$a ～ $b の範囲に収めます。

<h5>使い方の例</h5>

<pre class="source">
math.limit(100,  50, 200) → 100
math.limit(100, 150, 200) → 150
math.limit(100, 250, 200) → 200
</pre>

+ 絶対値を求める

<pre class="exp">
a[0] = math.abs($num)
</pre>

+ 乱数を求める

<pre class="exp">
a[0] = math.rand($min, $max)
</pre>

	$min～$max の範囲でランダムな値を返します。

++ 使い方の例

<pre class="source">
a[0] = math.rand(0, 99)
</pre>

	0～99 の範囲でランダムな値を返します。

+ ルートの値を求める

<pre class="exp">
a[0] = math.sqrt($num, $rate)
</pre>

<ul>
- $num：数値
- $rate：この値を掛け算した結果が求まります。小数は切り捨てられます。
</ul>

++ 使い方の例

<pre class="source">
a[0] = math.sqrt(2, 100)       // (√2) * 100
</pre>

	√2 = 1.4142... なので、100 をかけた 141 が返ってきます。

+ 対数の値を求める

<pre class="exp">
a[0] = math.log2($num, $rate)       // 2 を底とした対数
a[0] = math.log10($num, $rate)      // 常用対数（10 を底とした対数）
a[0] = math.log($num, $rate)        // 自然対数（e を底とした対数）
</pre>

<ul>
- $num：数値
- $rate：この値を掛け算した結果が求まります。小数は切り捨てられます。
</ul>

++ 使い方の例

<pre class="source">
a[0] = math.log10(2, 100)        // log10(2) * 100
</pre>

	log(2) = 0.3010... なので、100 を掛けた 30 が返ってきます。

+ 三角関数の値を求める

<pre class="exp">
a[0] = math.sin($degree, $rate)
a[0] = math.cos($degree, $rate)
a[0] = math.tan($degree, $rate)
</pre>

<ul>
- $degree：角度（10 = 1ﾟ、3600 = 360ﾟ）
- $rate：この値を掛け算した結果が求まります。小数は切り捨てられます。
</ul>

++ 使い方の例

<pre class="source">
a[0] = math.sin(600, 100)    // sin(600 / 10) * 100
</pre>

	sin(60ﾟ) = 0.866... なので、100 を掛けた 86 が返ってきます。

+ 逆三角関数の値を求める

<pre class="exp">
a[0] = math.arcsin($num, $rate)
a[0] = math.arccos($num, $rate)
a[0] = math.arctan($num, $rate)
</pre>

<ul>
- $num：数値
- $rate：$num をこの値で割り算した値を渡します。
- 戻り値：角度で求まります。小数は切り捨てられます。（0～3599）（arctan の場合は 0～1799）（10 = 1ﾟ、3600 = 360ﾟ）
</ul>

<h5>使い方の例</h5>

<pre class="source">
a[0] = math.arcsin(50, 100)   // arcsin(50 / 100) * 10
</pre>

	arcsin(50 / 100) = 30ﾟ なので、300 が返ってきます。

+ ２点の距離を求める

<pre class="exp">
a[0] = math.distance($x1, $y1, $x2, $y2)
</pre>

<ul>
- $x1, $y1, $x2, $y2：２点の座標
</ul>

++ 使い方の例

<pre class="source">
a[0] = math.distance(100, 100, 200, 200)
</pre>

	(100, 100) - (200, 200) の距離は 141.421... なので、141 が返ってきます。

+ ２点の角度を求める

<pre class="exp">
a[0] = math.angle($x1, $y1, $x2, $y2)
</pre>

	(x1, y1) を中心としたときの点 (x2, y2) への偏角を求めます。（10 = 1ﾟ、3600 = 360ﾟ）

	x 軸正の向きを基準（0ﾟ）に、y 軸正の向きへの回転を正として計算します。

<ul>
- $x1, $y1, $x2, $y2：２点の座標
</ul>

++ 使い方の例

<pre class="source">
a[0] = math.angle(0, 0, 100, 100)
</pre>

	(0, 0) - (100, 100) の偏角は 45ﾟ なので、450 が返ってきます。



■ 補完値を求める

+ 補完値を求める１

<pre class="exp">
a[0] = math.linear($time_0, $time_1, $value_1, $time_2, $value_2)
</pre>

	ある値が time_1 のときに value_1, time_2 のときに value_2 になるとして、time_0 のときの値を調べます。

++ 使い方の例

<pre class="source">
a[0] = math.linear(500, 0, 100, 1000, 200)
</pre>

<pre class="p">
時刻    -1000     ０     1000    2000
─────┼───＋───＋───┼──────
 値       ０     100      200     300
</pre>

	time_1 や time_2 の外側を指定した場合、値は value_1 や value_2 の外側になります。

+ 補完値を求める２<font color="red">（ｵｽｽﾒ!）</font>

<pre class="exp">
a[0] = math.timetable($now_time, $rep_time, $start_value, 
                    [$start_time, $end_time, $end_value(, $speed_mode)],
                    [$start_time, $end_time, $end_value(, $speed_mode)],
                    ...
                   )
</pre>

<div class="table-container">
<table>
|$now_time|現在時刻（ﾐﾘ秒）|
|$rep_time|修正時刻（ﾐﾘ秒）|
|$start_value|開始値|
|$start_time|開始時刻（ﾐﾘ秒）|
|$end_time|終了時刻（ﾐﾘ秒）|
|$end_value|終了値|
|$speed_mode|0: 等速、1:加速、2:減速（省略すると等速になります）|
</table>
</div>

	「時刻 $start_time から 時刻 $end_time の間に、値を $start_value から $end_value に変化させたときの現在の値を求める」コマンドです。
	カウンタと同時に使うことが多いと思います。

++ 使い方の例

<pre class="source">
a[0] = math.timetable(500, 0, 0, [0, 1000, 255])
</pre>

<pre class="p">
時刻      ０                       1000
─────┼────────────┼──────
 値       ０                        255
</pre>

	時刻 0 ﾐﾘ秒～時刻 1000 ﾐﾘ秒の間に、値を 0～255 に変化させます。
	現在時刻は 500 秒なので、128 が返ってきます。

<pre class="source">
a[0] = math.timetable(500, 0, 0, [1000, 2000, 255], [3000, 4000, 0])
</pre>

<pre class="p">
時刻      ０   1000  2000  3000  4000
─────┼──┼──┼──┼──┼──
 値       ０    ０    255   255   ０
</pre>

	時刻 1000 ﾐﾘ秒～時刻 1000 ﾐﾘ秒の間に値を 0～255 に変化させます。
	また、時刻 3000 ﾐﾘ秒～時刻 4000 ﾐﾘ秒の間に値を 255～0 に変化させます。

<div class="table-container">
<table>
|現在時刻が ～1000 の時|0 が返ります。|
|現在時刻が 1000～2000 の時|0～255 が返ります。|
|現在時刻が 2000～3000 の時|255 が返ります。|
|現在時刻が 3000～4000 の時|255～0 が返ります。|
|現在時刻が 4000～ の時|255 が返ります。|
</table>
</div>

++ 修正時間

	タイムテーブルの計算を、修正時間分遅らせて開始します。

++ 加速減速モード

	$speed_mode に 1 を指定すると徐々に速く、2 を指定すると徐々に遅くなるよう動きます。
	実際に使ってみて、目で確認した方が分かりやすいと思います。


■ 文字列

+ 文字列を変換する

<pre class="exp">
s[1] = s[0].upper            文字列を大文字に変換する
</pre>
<pre class="exp">
s[1] = s[0].lower            文字列を小文字に変換する
</pre>

+ 文字列の文字数／長さを取得する

<pre class="exp">
a[0] = s[0].cnt              文字列の文字数を取得する（半角=1、全角=1）
</pre>
<pre class="exp">
a[0] = s[0].len              文字列の長さを取得する（半角=1、全角=2）
</pre>

<pre class="source">
s[0] = "abcあいうABC"
a[0] = s[0].cnt              // 9 が返されます。
a[0] = s[0].len              // 12 が返されます。
</pre>

+ 文字列を取り出す

<pre class="exp">
s[1] = s[0].left($cnt)       文字列の左 $cnt 文字を取得する（半角=1、全角=1）
s[1] = s[0].left_len($cnt)   文字列の左 $cnt 文字を取得する（半角=1、全角=2）
</pre>

<pre class="exp">
s[1] = s[0].right($cnt)      文字列の右 $cnt 文字を取得する（半角=1、全角=1）
s[1] = s[0].right_len($cnt)  文字列の右 $cnt 文字を取得する（半角=1、全角=2）
</pre>

<pre class="exp">
s[1] = s[0].mid($pos)           文字列の $pos 文字目から最後までを取得する（半角=1、全角=1）
s[1] = s[0].mid($pos, $cnt)     文字列の $pos 文字目から $cnt 文字を取得する（半角=1、全角=1）
s[1] = s[0].mid_len($pos)       文字列の $pos 文字目から最後までを取得する（半角=1、全角=2）
s[1] = s[0].mid_len($pos, $cnt) 文字列の $pos 文字目から $cnt 文字を取得する（半角=1、全角=2）
</pre>

	$pos は、0 が 1 文字目です。

<pre class="source">
s[0] = "abcあいうABC"
s[1] = s[0].mid(2, 5)       // "cあいうA" が返されます。
s[1] = s[0].mid_len(2, 5)   // "cあい" が返されます。
</pre>

+ 文字列を検索する

<pre class="exp">
a[0] = s[0].search($str)         文字列の先頭から文字列を検索する
a[0] = s[0].search_last($str)    文字列の末尾から文字列を検索する
</pre>

	文字列から文字列を検索します。見つかった場合はその位置を返します。１文字目が 0 なので注意してください。
	見つからなかった場合は -1 を返します。大文字、小文字を区別しません。

<pre class="source">
s[0] = "abcあいうABC"
a[0] = s[0].search("abc")       // 0 が返されます。
a[0] = s[0].search_last("abc")  // 6 が返されます。
a[0] = s[0].search_last("cba")  // 見つからないので -1 が返されます。
</pre>



■ 文字列を数値に変換する

<pre class="exp">
a[0] = s[0].tonum
</pre>

<pre class="source">
s[0] = "12345"

// s[0] を数値に変換する
a[0] = s[0].tonum

// 数値を表示する
print(a[0])r
</pre>

<pre class="result">
12345
</pre>




■ 数値を文字列に変換する

+ 数値を文字列に変換する

<pre class="exp">
s[0] = math.tostr($num)
s[0] = math.tostr($num, $length)
s[0] = math.tostr_zero($num, $length)
s[0] = math.tostr_zen($num)
s[0] = math.tostr_zen($num, $length)
s[0] = math.tostr_zen_zero($num, $length)
</pre>

	数値を文字列に変換します。

++ $length

	長さを指定します。文字列は右寄せになります。

<div class="table-container">
<table>
|tostr(123) → "123"|
|tostr(123, 5) → "**123"（'*' は半角スペース）|
|tostr_zero(123, 5) → "00123"|
|tostr_zen(123) → "１２３"|
|tostr_zen(123, 5) → "＊＊１２３"（'＊' は全角スペース）|
|tostr_zen_zero(123, 5) → "００１２３"|
</table>
</div>

	※ '*'、'＊' はそれぞれ半角、全角のスペースです。


■ 文字コードを取得する

<pre class="exp">
a[0] = s[0].get_code($pos)
</pre>

	文字列の $pos 番目の文字の文字コードを取得します。

	参考：[[文字]]




■ 文字コードから文字列を作成する

+ 文字コードから文字列を作成する

<pre class="exp">
s[0] = math.tostr_by_code($num)
</pre>

	文字コードから文字列を作成します。
	文字コードは Unicode（UTF-16）に準拠します。

	ハートマークなど、Shift-JIS に存在しない文字を表示したい場合に使って下さい。

	フォントによっては上手く表示されない場合があります。必ず「フォントの問題」をお読み下さい。

<pre class="source">
print(math.tostr_by_code(0x2661))r
</pre>

<pre class="result">
（ハートマークが表示されます）
</pre>

+ フォントの問題

	選んだフォントによっては、文字が表示できない場合があります。

	Windows 標準フォント（「ＭＳ　ゴシック」など）は問題なく対応していますので、普通は問題ありません（XP でも大丈夫です）。
	フリーの古いフォントなどは対応していない可能性が高いので、
	環境設定の「フォントの変更」機能を重視する場合は注意して下さい。



■ 文字列配列

	文字列配列についての説明です。
	s フラグなども文字列配列であることに注意して下さい。

+ 代表的な整数配列

<ul>
- s フラグ、m フラグ、k フラグなどの文字列フラグ
- strlist 型のユーザフラグ
</ul>

+ 初期化する

<pre class="exp">
s.init                 // s フラグを初期化する
</pre>

	配列を初期化します。
	resize で個数を変更していた場合、個数も元に戻ることに注意して下さい。

+ 要素の個数を変更する

<pre class="exp">
k.resize($cnt)         // k フラグの個数を $cnt 個にする
</pre>

	コールフラグの個数の変更は、そのコール内でのみ有効です。

<div class="chips">
このコマンドで s フラグ、m フラグなどの個数を変更することはできません。
k フラグ、などの個数を変更することができます。
</div>

+ 要素の個数を取得する

<pre class="exp">
a[0] = k.get_size      // k フラグの個数を取得する
</pre>





■ シーン制御

+ ゲームを終了する

<pre class="exp">
owari
</pre>

	ゲームを終了します。

+ メニューに戻る

<pre class="exp">
returnmenu
</pre>

	メニューシーンに戻ります。


■ シーンタイトル

	シーンごとにサブタイトルをつける機能です。
	シーンタイトルはウィンドウキャプションやセーブダイアログに表示されます。
	また、セーブデータごとに保存され、syscom.get_save_title コマンドで取り出すこともできます。
	非常に重要な機能です。設定することをお勧めします。

<div class="table-container">
<table>
<caption>シーンタイトルの例</caption>
|set_title(５月１４日)|
|set_title(メリッサの憂鬱)|
|set_title(タイトルメニュー)|
|set_title(姫歌エンディング)|
</table>
</div>

+ シーンタイトルを設定／取得する

<pre class="exp">
set_title($title)
s[0] = get_title
</pre>

	シーンタイトルを設定／取得します。


■ 現在のシーン名を取得する

<pre class="exp">
s[0] = get_scene_name
</pre>

	現在実行中の、ss ファイルの名前を取得します。
	例えば test.ss を実行している場合、"test" が返ってきます。
	シーンタイトルと間違わないようにして下さい。

	マクロ内で使っても、inc ファイルの名前を取得できるわけではありません。
	そのマクロを呼び出した ss ファイルの名前が取得できます。

	デバッグ以外であまり使うことはないと思います。

<pre class="exp">
l[0] = get_line_no
</pre>

	現在実行中の、ss ファイルの行番号を取得します。

	マクロ内で使っても、そのマクロが使われた行番号が取得されます。

	デバッグ以外であまり使うことはないと思います。




■ コールスタック制御

<pre class="exp">
init_call_stack                  // コールスタックを初期化
del_call_stack($cnt)             // コールスタックを $cnt 個減らす
set_call_stack_cnt($cnt)         // コールスタックの個数を $cnt に設定（増やすことはできません）
a[0] = get_call_stack_cnt($cnt)  // コールスタックの個数を取得
</pre>

	かなり上級者向けのコマンドです。

	コールスタックの個数を増やしたり減らしたりします。
	非常に危険なコマンドですので、よく理解した上で使って下さい。

<h4>コールスタックの初期値</h4>

	コールスタックの初期値は、<font color="red">０ではなく１です</font>。最初から１つ、コールを持っていると考えて下さい。
	また、１未満に減らすことはできません。

<h4>使い道</h4>

	深い階層から一気に戻るときに使います。
	解放処理などを忘れないように気を付けて下さい。

<h4>コールフラグについて</h4>

	コールスタックを減らした時点で、Ｌフラグ、Ｋフラグなどのコールフラグは消滅します。
	このコマンド以降にコールフラグを使用してはいけません。

<h4>注意点</h4>

	例えば次のようなコードがあります。

<pre class="source">
#z01

	// システムコマンドを禁止する
	syscom.set_syscom_menu_disable

	// メイン処理を行う
	gosub #z02

	// システムコマンドを許可する
	syscom.set_syscom_menu_enable

	// 戻る
	return
</pre>

	１行目でシステムコマンドの呼び出しを禁止しています。
	ただし、#z02 の中でどのような処理が行われても、
	必ず３行目でシステムコマンドの呼び出しが元に戻ります。
	安全なコードと言えます。

	コールスタックを自力で制御した場合、このフロー制御すら破壊される可能性があります。

	デバッグ作業が困難になります。
	しかし、うまく使えば非常に便利なコマンドです。
	理解した上で使用して下さい。





















■ カウンタ

	カウンタを使って、時間を計測することができます。
	「１秒かけてオブジェクトを移動する」などの処理を組むために使えます。

	カウンタはデフォルトで１６個あります。
	（設定ファイルで変更できます。[[カウンタの設定]] 参照）

+ カウンタを開始する

<pre class="exp">
counter[0].start
counter[0].start_real                                               // 早送りできないバージョン

counter[0].start_frame($start_num, $end_num, $time)
counter[0].start_frame_real($start_num, $end_num, $time)            // 早送りできないバージョン

counter[0].start_frame_loop($start_num, $end_num, $time)
counter[0].start_frame_loop_real($start_num, $end_num, $time)       // 早送りできないバージョン
</pre>

	時間の計測を 0 から開始します（1000 = 1秒）。

++ フレーム

	_frame のつくコマンドは、カウンタを、$time 時間かけて $start_num から $end_num まで動かします。

	_frame_loop の場合はフレームの値がループします。$start_num = 0, $end_num = 60 の場合、0, 1, 2, ..., 58, 59, 0, 1, 2, ... となります。60 になることはないので注意してください。</p>

++ 早送りできないバージョン

<ul>
- _real がつかないコマンドは、早送りできます。

<ul>
- Ctrl キーを押している間は 32倍速で進みます。
- ウィンドウをつかんでいる間などは時間が進みません。
</ul>

- _real がつくコマンドは、早送りできません。

<ul>
- Ctrl キーで早送りされません。
- ウィンドウをつかんでいる間なども時間が進みます。
- 音楽にあわせた演出を組むときなどに使ってください。
</ul>

</ul>

	どちらの場合でも、デバッグキーによる加速・減速ができます。

<div class="table-container">
<table>
<caption>デバッグキーによる加速・減速</caption>
|[Insert]|４倍速|
|[Delete]|２倍速|
|[Home]|１／４倍速|
|[End]|１／８倍速|
|[Home] + [End]|時間を進めない|
</table>
</div>

+ カウンタを停止する

<pre class="exp">
counter[0].stop
</pre>

	カウンタを一時停止します。

+ カウンタを再開する

<pre class="exp">
counter[0].resume
</pre>

	カウンタを、一時停止した場所から再開します。

+ カウンタの値をリセットする

<pre class="exp">
counter[0].reset
</pre>

	カウンタの値を 0 に戻します。

+ カウンタの値を設定する

<pre class="exp">
counter[0].set($count)
</pre>

	カウンタの値を $count に設定します。

+ カウンタの値を取得する

<pre class="exp">
a[0] = counter[0].get
</pre>

	カウンタの値を取得します。

+ カウンタを待つ

<pre class="exp">
counter[0].wait($count)
a[0] = counter[0].wait_key($count)      // キーで飛ばせるバージョン
</pre>

	カウンタの値が $count になるまで待ちます。
	wait_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

+ カウンタの値を判定する

<pre class="exp">
counter[0].check_value($count)         // カウンタの値が $count を超えているかどうかを判定する
</pre>

	カウンタの値が $count を超えているかどうかをチェックします。
	0=超えていない、1=等しいまたは超えている

+ カウンタが動いているかを判定する

<pre class="exp">
counter[0].check_active                // カウンタが動いているかどうかを判定する
</pre>

	カウンタが動いているかどうかを判定します。
	0=動いていない、1=動いている



■ 時間待ち

+ 時間を待つ

<pre class="exp">
timewait($time)
a[0] = timewait_key($time)  // （0=ﾀｲﾑｵｰﾊﾞｰ、1=決定キー、-1=キャンセルキー）
</pre>

	$time ﾐﾘ秒間、時間を待ちます。

	timewait_key の場合、キーで時間待ちをスキップできます。
	決定キーまたはキャンセルキーでスキップした場合は 1 または -1 が返ります。
	タイムオーバーした場合は 0 が返ります。

	右クリックでシステムコマンドメニューが呼び出せる場合は、
	-1 が返ってくることはありません。


■ 現在の時間を取得する

	システム関数を使います。
	[[システム制御\現在の時間を取得する]] を参照して下さい。


■ 総プレイ時間を取得する

	システムコマンドを使います。
	[[システム制御\総プレイ時間を取得／設定する]] を参照して下さい。


■ メッセージ

<h4>一般的なメッセージの例</h4>

<pre class="source">
koe(100000000,000)set_face(FCRN00)【鈴】「今日はすごいぞ」r
koe(100000001,000)set_face(FCRN01)【鈴】「聞いて驚け」r
koe(100000002,000)set_face(FCRN02)【鈴】「じゃん！」r
</pre>

	通常は、声、顔グラフィック、名前、メッセージ、r コマンドの順に並べます。

<h4>メッセージを表示する</h4>

<pre class="exp">
print($num)
print($str)
</pre>

	メッセージを表示します。
	フラグの内容を表示するときなどに使います。

<pre class="source">
print(a[0])           // a[0] の値を表示する
print(a[0] + a[1])    // a[0] + a[1] の値を表示する
</pre>

<h4>メッセージを消去する</h4>

<pre class="exp">
clear
</pre>

	文字を消去する準備を行います。

	実際は、すぐには消去されません。
	次に文字が表示される直前に消去されます。

<pre class="source">
（キャラ１を表示）
（文章１を表示）pp clear
wipe(0, 1000)
（キャラ２を表示）
（文章２を表示）pp clear
</pre>

	上記のような演出時、は、以下の用に処理されます。

<ul>
<li>キャラ１が表示される</li>
<li>文章１が表示される</li>
<li>ワイプされる</li>
<li>キャラ２が表示される</li>
<li><font color="red">文章１が消える</font></li>
<li>文章２が表示される</li>
</ul>

<h4>メッセージの表示終了を待つ</h4>

<pre class="exp">
wait_msg
</pre>

	現在の文章が最後まで表示されるのを待ちます。
	通常は自動で待つので、あまり使うことのないコマンドです。

<h4>メッセージのキー待ちを行う</h4>

<pre class="exp">
pp
</pre>

	現在の文章が最後まで表示されるのを待ち、その後、キー待ちを行います。

<h4>メッセージのＲ待ちを行う</h4>

<pre class="exp">
r
</pre>

	現在の文章が最後まで表示されるのを待ち、キー待ちを行い、メッセージのクリア準備を行います。
	pp clear とほぼ同じコマンドです。
	ほぼ全ての文章の後につけることになると思います。非常に重要なコマンドです。

	[[ノベルモード]] の場合は、メッセージはクリアされません。

<pre class="source">
【鈴】「今日はすごいぞ」r
【鈴】「聞いて驚け」r
【鈴】「じゃん！」r
</pre>

<h4>メッセージのＲ待ちを行い、改ページする</h4>

<pre class="exp">
page
</pre>

	[[ノベルモード]] で使います。
	ノベルモードでは r コマンドでメッセージはクリアされないので、
	ページの切り替え位置で page コマンドを使って下さい。





■ メッセージを整形する

+ メッセージを改行する

<pre class="exp">
nl
nli
</pre>

	文章を改行します。
	nl はインデントを無視して改行します。
	通常は、インデント位置まで改行する nli を使ってください。

+ インデントを設定する

<pre class="exp">
indent
</pre>

	通常、インデントは自動的に設定されます。
	任意でインデントを設定したい場合にこのコマンドを使って下さい。

++ インデントの例

<pre class="source">
インデント：indent 文章作成ソフトウェアにおける、字下げ機能このこと。改行後の文字の開始位置を指定できる。
</pre>

++ 結果

<pre class="result">
インデント：文章作成ソフトウェアにおける、字下げ機
　　　　　　能このこと。改行後の文字の開始位置を指
　　　　　　定できる。

↑インデントが適用された
</pre>

+ インデントをクリアする

<pre class="exp">
clear_indent
</pre>

	インデントの位置を初期化します。



■ メッセージにルビをつける

+ メッセージにルビをつける

<pre class="exp">
ruby($str)       // ルビを開始する
ruby             // ルビを終了する
</pre>

	ruby($str) と ruby で囲まれた文章にルビをつけます。

++ ルビの例

<pre class="source">
ruby("ぶんしょう") 文章 ruby に ruby("るび") ルビ ruby をつける ruby("てすと") テスト ruby です。
</pre>

++ 注意点

	改行をまたぐ文章には、ルビをつけることができません。
	上手く調整してください。

++ 置換を使った例

	定義ファイルの置換を使うと便利です。

<h6>定義ファイル</h6>

<pre class="source">
#define    @鈴    ruby("りん") 鈴 ruby
#define    @理樹  ruby("りき") 理樹 ruby
</pre>

<h6使い方</h6>

<pre class="source">
@鈴 は @理樹 を…
</pre>


■ 文字を装飾する

+ 文字サイズを変更する

<pre class="exp">
size($size)      // 文字サイズを設定する
size             // 文字サイズを初期設定に戻す
</pre>

+ 文字の色を変更する

<pre class="exp">
color($color_no) // 文字色を設定する
color            // 文字色を初期設定に戻す
</pre>

	色は、Gameexe.ini で作成した COLOR_TABLE の番号を設定します。
	[[カラーテーブルの設定]] を参照して下さい。



■ 文字の位置を補正する

+ 文字の位置を補正する

<pre class="exp">
rep_pos($x, $y)      // 文字の位置を補正する
rep_pos              // 文字の位置補正を初期設定に戻す
</pre>

	文字の位置を補正します。
	改行やオーバーフローには一切影響せず、単純にその文字の表示位置をずらすだけです。

+ サンプル：小さい文字を（縦位置で）中央寄せする

	size コマンドで小さい文字を表示したときに、中央に表示します。

<pre class="source">
普通の文字 size(10) 小さい文字 size 普通の文字（デフォルト）nl
普通の文字 size(10) rep_pos(0, 8) 小さい文字 size rep_pos 普通の文字（縦に"8px"ずらしてみた）r
</pre>

	<img src="rep_pos.png" />







■ 絵文字を表示する

<div align="center">
<img src="emoji.jpg">
</div>

	独自の絵文字を表示することができます。

+ 絵文字ファイルを作る

	絵文字は通常の g00 として作ります。
	１文字ごとにカットデータとして作って下さい。
	サンプルデータを参考にして下さい。

<div class="chips">
RealLive では１枚の画像につなげて絵文字を書いていましたが、
Siglus ではカットデータにする必要があります。
</div>

+ 絵文字を登録する

	絵文字を使うには、絵文字を設定ファイルに登録します。

<pre class="source">
// *************************************************************
// ■絵文字の設定
// =============================================================
#EMOJI.CNT = 4
#EMOJI.000 = "_emoji00", 16
#EMOJI.001 = "_emoji01", 24
#EMOJI.002 = "_emoji02", 32
#EMOJI.003 = "_emoji03", 48
</pre>

	（_emoji00.g00 ～ _emoji03.g00 の例を掲載予定）

	絵文字は文字サイズごとに登録します。
	上の例では、文字サイズ 16, 24, 32, 48 の４種類を登録しています。
	その時の文字サイズによって、適切なものが自動で使われます。
	具体的には、その時の文字サイズ以下で、より近いサイズの絵文字が使用されます。

<div class="table-container">
<table>
|文字のサイズ|使われる絵文字|
|～23|登録０番|
|24～31|登録１番|
|32～47|登録２番|
|48～|登録３番|
</table>
</div>

+ 絵文字を表示する

	＃Ａ？？　絵文字をそのままの色で表示（？？＝カット番号）
	＃Ｂ？？　絵文字を文字色で表示（？？＝カット番号）

<pre class="source">
絵文字タイプＡです。＃Ａ００＃Ａ０１＃Ａ０２＃Ａ０３r
絵文字タイプＢです。＃Ｂ００＃Ｂ０１＃Ｂ０２＃Ｂ０３r
</pre>

++ 絵文字の後に数字を表示する

	絵文字０番の後に、「１２３」と続けて表示したいとします。
	「＃Ａ００１２３」と書くと、絵文字１２３番が使われてしまいます。
	この場合は「"Ａ００"１２３」のように絵文字を "" で括って下さい。

<pre class="source">
【名前】１２３&quot;＃Ａ００&quot;４５６&quot;＃Ａ００&quot;７８９r
</pre>




■ マルチメッセージ

	１つのメッセージウィンドウに、複数のメッセージを同時に表示する機能です。

<pre class="exp">
multi_msg           // マルチメッセージを開始する
next_msg            // 次のメッセージに移動する
</pre>

++ スクリプトサンプル

<pre class="source">
// ★３つのセリフを同時に表示

<font color="red">multi_msg</font> KOE(051400486,001)【鈴・りん・リン】
【鈴】「おまえにもわかるか…そうだろうそうだろう」nl <font color="red">next_msg</font>
【りん】「絶対に捕まえられないな」nl <font color="red">next_msg</font>
【リン】「捕まえるのに六十五年はかかるな」r
</pre>

++ 名前について

	必ず、「それぞれのメッセージにつく名前」および「表示される名前」の両方を設定してください。
	実際に表示されるのは、multi_msg の前の「表示される名前」だけです。
	「それぞれのメッセージにつく名前」は、声撮りのためには必須です。

++ 声について

	２つ以上の声を再生する場合は、あらかじめ声を合成したデータを作っておく必要があります。

++ 長い文章の自動改行

<pre class="source">
multi_msg
「あいうえおかきくけこさしすせそたちつてとなにぬねの」nl next_msg
「はひふへほまみむめもやゆよらりるれろわをん」r
</pre>

	長い文章は自動で改行されるので、次のように表示されます。

<pre class="result">
「あいうえおかきくけこさしすせそたちつてと
　なにぬねの」
「はひふへほまみむめもやゆよらりるれろわを
　ん」
</pre>

++ 色、サイズ、ルビ等

	文章を装飾する系のコマンドは、普通に使うことが出来ます。

<pre class="source">
multi_msg
「color(2)あいうえおcolorかきくけこsize(32)さしすせそsize」nl next_msg
「かんじruby(かんじ)漢字rubyカンジ」r
</pre>

++ オーバーフロー

	オーバーフローには対応していません。文章が長くなりすぎないように注意してください。



■ ノベルモード

<div align="center">
<img src="novel.png" />
</div>

	メッセージをノベルモードにすることができます。
	ノベルモードにするには、メッセージウィンドウの設定を行います。

<pre class="source">
#MWND.000.NOVEL_MODE = 0      // 0:ＡＶＧモード、1:ノベルモード
#MWND.000.NAME_DISP_MODE = 0  // 0:名前ウィンドウに表示、1:メッセージの先頭に表示、2:表示しない
</pre>

	詳しくは [[メッセージウィンドウ個別の設定]] を参照して下さい。

+ ノベルモード

	通常、r コマンドを実行すると、メッセージがクリアされていました。
	ノベルモードでは r コマンドではメッセージはクリアされません。
	クリアするには page コマンドを使います。

<div class="chips">
(2010/10/26) ノベルモードでの文章送りを、pp nl などで行ってはいけません。
必ず r コマンドを使って下さい。古いサンプルでは行っていましたが、間違いです。
セーブポイントの設置、メッセージバック、既読フラグなどが正常に働かなくなります。
</div>

+ ノベルモードのサンプル

<pre class="source">
KOE(101900064,002)【ちはや】「あはは、瑚太朗はばかですねー」R
【瑚太朗】「………」R
KOE(101900068,002)【ちはや】「な、何ですかその目はっ」R
【瑚太朗】「馬鹿にばかって言われてもなんだか逆に可哀想にしか…」R
KOE(101900072,002)【ちはや】「な、何ですかそれっ！？　ばかっていうやつのほうがばかなんですっ！」<font color="red">PAGE</font>
</pre>








■ その他のメッセージ制御

+ 一時的にオートモードにする／解除する

<pre class="exp">
script.start_auto_mode                        // 一時的にオートモードにする
script.end_auto_mode                          // 解除する
script.set_auto_mode_moji_wait($time)         // 一時的なオートモードの文字待ち時間を設定する
script.set_auto_mode_moji_wait_default($time) // 一時的なオートモードの文字待ち時間をデフォルトに設定する
a[0] = script.get_auto_mode_moji_wait($time)  // 一時的なオートモードの文字待ち時間を取得する
script.set_auto_mode_min_wait($time)          // 一時的なオートモードの最小待ち時間を設定する
script.set_auto_mode_min_wait_default($time)  // 一時的なオートモードの最小待ち時間をデフォルトに設定する
a[0] = script.get_auto_mode_min_wait($time)   // 一時的なオートモードの最小待ち時間を取得する
</pre>

	待ち時間 ＝ ( 表示した文字数 × 文字時間 ) ＋ 最小時間

	演出上、一時的にオートモードを使いたい場合に使って下さい。
	環境設定のオートモードを開始するには、syscom.set_auto_mode_onoff_flag を使って下さい。
	環境設定のオートモードを設定／取得するには、
	syscom.set_auto_mode_***_wait / syscom.get_auto_mode_***_wait を使って下さい。

	環境設定では 0-500 の間で設定しましたが、
	このコマンドではより大きな値を使うこともできます。

	この設定のデフォルト値は -1（環境設定に従う）です。
	初期化するときは必ず script.set_auto_mode_***_wait_default を使って下さい。

+ オートモードの待ち時間を個別に設定する（文字数で指定）

<pre class="exp">
script.set_auto_mode_moji_cnt($moji_cnt)     // 一時的にオートモードの文字数を設定する
</pre>

	オートモードの計算式

	待ち時間 ＝ ( 表示した文字数 × 文字時間 ) ＋ 最小時間

	のうち、「表示した文字数」を設定するコマンドです。

	文字をグラフィカルに表示して r 待ちを行った場合、
	オートモードだと「最小時間」だけ待ってすぐに次に進んでしまいます。
	このコマンドを使って「表示した文字数」を設定すると、オートモード時に適切に待ち時間が入ります。
	オートモード時以外はこのコマンドは無視されます。

	clear、r コマンドなどにより、この値は自動で初期化されます。

<pre class="source">
// これは普通の文章。
あいうえおかきくけこさしすせそ。r

// グラフィカルに文字を１０文字表示する
// オートモードの文字数を設定し、r 待ちを行う
front.object[0].create("moji_length_10")		// １０文字分の画像
script.set_auto_mode_moji_cnt(10)r
</pre>

+ 一時的にメッセージ速度を変更する

<pre class="exp">
script.set_message_speed($speed)    // 一時的にメッセージ速度を変更する（小さいほど速い）
script.set_message_speed_default    // 一時的にメッセージ速度を変更するを解除する
a[0] = script.get_message_speed     // 一時的に変更したメッセージ速度を取得する（小さいほど速い）
</pre>

	一時的にメッセージ速度を変更します。
	１文字表示するのにかかる時間をﾐﾘ秒単位で指定します。（例：1000 を指定した場合、１文字表示するのに１秒かかります。）
	環境設定を設定／取得する場合は、syscom.set_message_speed / get_message_speed を使って下さい。

	環境設定では 0-100 の間で設定しましたが、
	このコマンドではより大きな値を使うこともできます。（2010/9/8 Ver.1.0.1.6 より）

	この設定のデフォルト値は -1（環境設定に従う）です。
	初期化するときは必ず script.set_message_speed_default を使って下さい。

+ 一時的にメッセージをノーウェイトにする

<pre class="exp">
script.set_message_nowait_flag($onoff)    // 一時的にメッセージをノーウェイトにするフラグを設定する（0=解除する、1=ノーウェイトにする）
a[0] = script.get_message_nowait_flag     // 一時的にメッセージをノーウェイトにするフラグを取得する（0=解除する、1=ノーウェイトにする）
</pre>

	一時的にメッセージをノーウェイトにします。
	環境設定を設定／取得する場合は、syscom.set_message_nowait / get_message_nowait を使って下さい。

+ 一時的に「クリックすると文章を最後まで表示する」機能を無効にする／解除する

<pre class="exp">
script.set_end_msg_by_key_disable   // 一時的に「クリックすると文章を最後まで表示する」を無効にする
script.set_end_msg_by_key_enable    // 解除する
</pre>

	表示中の文章は、画面をクリックすると一括表示されます。その機能を無効にします。

+ 一時的にメッセージを非同期モードにする

<pre class="exp">
script.set_msg_async_mode_on        // 一時的にメッセージを非同期モードにする
script.set_msg_async_mode_off       // 解除する
</pre>

	メッセージの表示を非同期モードにします。
	メッセージを表示しながら、演出を行うことが出来ます。


+ 一時的に「次の文章に進んでも声を止めない」機能をオンにする／オフにする／解除する

<pre class="exp">
script.set_koe_dont_stop_on_flag($onoff)         // 一時的に「次の文章に進んでも声を止めない」機能をオンにするフラグを設定する（0=解除する、1=設定する）
a[0] = script.get_koe_dont_stop_on_flag($onoff)  // 一時的に「次の文章に進んでも声を止めない」機能をオンにするフラグを取得する（0=解除する、1=設定する）
script.set_koe_dont_stop_off_flag($onoff)        // 一時的に「次の文章に進んでも声を止めない」機能をオフにするフラグを設定する（0=解除する、1=設定する）
a[0] = script.get_koe_dont_stop_off_flag($onoff) // 一時的に「次の文章に進んでも声を止めない」機能をオフにするフラグを取得する（0=解除する、1=設定する）
</pre>

	環境設定の「次の文章に進んでも声を止めない」機能に関するコマンドです。
	このコマンドは、一時的に機能をオンにする／オフにする／解除するコマンドです。

++ set_koe_dont_stop_on_flag(1)

	環境設定を無視して、強制的に「次の文章に進んでも声を止めない」機能をオンにします。
	set_koe_dont_stop_on_flag(0) で元に戻します。

++ set_koe_dont_stop_off_flag(1)

	環境設定を無視して、強制的に「次の文章に進んでも声を止めない」機能をオフにします。
	set_koe_dont_stop_off_flag(0) で元に戻します。

	この２つは別々のフラグなので注意して下さい。














■ 名前を設定する

<pre class="exp">
set_namae("なまえ")    // 名前を設定する
</pre>

	メッセージウィンドウに表示する名前を手動で設定します。

	普通は使うことはないと思います。
	名前を自力制御するときに使います。






■ メッセージウィンドウ

	メッセージウィンドウは設定ファイルで作成します。
	詳しくは以下を参照して下さい。

<ul>
- [[メッセージウィンドウの設定]]
- [[メッセージウィンドウ個別の設定]]
- [[メッセージウィンドウ枠の設定]]
- [[メッセージウィンドウ枠個別の設定]]
</ul>

	メッセージウィンドウを作成するには、
	「メッセージウィンドウ本体」と「メッセージウィンドウ枠」を作成します。

	メッセージウィンドウ本体には「固定ウィンドウ」と「可変ウィンドウ」があります。
	通常は固定ウィンドウを使います。
	選択肢用のウィンドウなどは、選択肢の数に応じて伸び縮みする必要があります。
	このような場合に可変ウィンドウを使います。

	メッセージウィンドウ枠にも「固定枠」と「可変枠」があります。
	可変ウィンドウには可変枠しか設定できません。
	複数の大きさの異なるウィンドウに同じ枠を設定する場合にも可変枠が使えます。



■ メッセージウィンドウの機能

	メッセージウィンドウでは次のようなことができます。

+ メッセージを表示する

	メッセージを表示します。決定キーで次に進みます。
	色やサイズを変えたり、ルビを振ったりもできます。
	詳しくは [[メッセージ]] を参照して下さい。

+ 選択肢を表示する

	選択肢を表示します。
	詳しくは [[選択肢]] を参照して下さい。

+ 名前ウィンドウを表示する

	名前を表示する小さなウィンドウを隣につけることができます。
	詳しくは [[メッセージウィンドウ個別の設定]] を参照して下さい。

+ 枠をつける

	メッセージウィンドウに枠をつけることができます。
	詳しくは [[メッセージウィンドウ枠個別の設定]] を参照して下さい。

	途中で枠を変えることもできます。
	視点が変わるたびに枠を変える、怒っている台詞で枠を変える、など有効に使って下さい。
	詳しくは [[メッセージウィンドウを操作する]] を参照して下さい。

+ 背景を設定する

	メッセージウィンドウに背景フィルターをつけることができます。
	このフィルターは、環境設定の「メッセージウィンドウの背景色」で
	ユーザが任意に設定することができます。
	詳しくは [[メッセージウィンドウ枠個別の設定]] を参照して下さい。

+ キー待ちアイコンをつける

	メッセージ送り待ちのとき、メッセージウィンドウの右下にキー待ちアイコンをつけることができます。
	詳しくは [[メッセージウィンドウ枠個別の設定]] を参照して下さい。

+ メッセージウィンドウボタンを配置する

	セーブ／ロード、メッセージバック、声を再生する、といったシステムボタンを配置できます。

	詳しくは [[メッセージウィンドウ枠個別の設定]] を参照して下さい。

+ 顔グラフィックを表示する

	メッセージごとに顔グラフィックをつけることができます。
	詳しくは [[メッセージウィンドウ枠個別の設定]] および [[顔グラフィック]] を参照して下さい。

+ メッセージログを表示する

	メッセージウィンドウに表示したメッセージは、メッセージログに自動的に保存され、
	PageUp / PageDown キーでメッセージバック機能で読み戻すことができます。
	メッセージバックのデザインは自由に変更することができます。
	詳しくは Gameexe.ini の[[メッセージバックの設定]] を参照して下さい。


■ メッセージウィンドウを操作する

	メッセージウィンドウには、
	「現在のメッセージウィンドウを操作する」「特定のメッセージウィンドウを操作する」の２通りの使い方があります。
	例えば、メッセージウィンドウを開くには、

<pre class="source">
open               // 現在のメッセージウィンドウを表示する
front.mwnd[0].open // メッセージウィンドウ０番を表示する
</pre>

	のように指定します。

	通常は上の方法を使います。
	メッセージウィンドウを複数使う場合は、下の方法を使うと便利です。
	上の方法を「省略形」と言います。

+ 省略形が使えるコマンド

	set_waku, open, open_wait, open_nowait, close, close_wait, close_nowait, 
	clear, print, wait_msg, pp, r, nl, nli, clear_indent, size, sel, koe, clear_face, set_face, …

+ メッセージウィンドウを変更する／番号を取得する

<pre class="exp">
set_mwnd(0)                // メッセージウィンドウを０番に設定する
set_mwnd(front.mwnd[0])    // メッセージウィンドウを front.mwnd[0] に設定する
a[0] = get_mwnd            // 現在のメッセージウィンドウの番号を取得する
</pre>


+ メッセージウィンドウを開く

<pre class="exp">
open                       // メッセージウィンドウを開き、開き終わるまで待つ
open_wait                  // メッセージウィンドウを開き、開き終わるまで待つ
open_nowait                // メッセージウィンドウを開き、開き終わるのを待たずに次に進む
</pre>

	メッセージウィンドウを開きます。
	通常は、文字が表示されると自動的にウィンドウが開くので、あまり使うことのない命令です。
	open と open_wait は同じ命令です。

+ メッセージウィンドウを閉じる

<pre class="exp">
close                      // メッセージウィンドウを閉じ、閉じ終わるまで待つ
close_wait                 // メッセージウィンドウを閉じ、閉じ終わるまで待つ
close_nowait               // メッセージウィンドウを閉じ、閉じ終わるのを待たずに次に進む
</pre>

	メッセージウィンドウを閉じます。
	close と close_wait は同じ命令です。

+ メッセージウィンドウの閉じアニメを終了する

<pre class="exp">
end_close                  // メッセージウィンドウの閉じアニメを終了する
</pre>

	close_nowait で、非同期にメッセージウィンドウを閉じたとします。
	処理が終わって、強制的にメッセージウィンドウを閉じ終えたい場合、このコマンドを使って下さい。
	close / close_wait の場合はこのコマンドを使うことはないと思います。








■ メッセージウィンドウの位置と大きさを変更する

<pre class="exp">
front.mwnd[0].set_window_pos($x, $y)        // 位置を変更する
front.mwnd[0].set_window_size($x, $y)       // 大きさを変更する
front.mwnd[0].set_window_moji_cnt($x, $y)   // 文字数を変更する

a[0] = front.mwnd[0].get_window_pos_x       // 位置（Ｘ）を取得する
a[0] = front.mwnd[0].get_window_pos_y       // 位置（Ｙ）を取得する
a[0] = front.mwnd[0].get_window_size_x      // 大きさ（Ｘ）を取得する
a[0] = front.mwnd[0].get_window_size_y      // 大きさ（Ｙ）を取得する
a[0] = front.mwnd[0].get_window_moji_cnt_x  // 文字数（Ｘ）を取得する
a[0] = front.mwnd[0].get_window_moji_cnt_y  // 文字数（Ｙ）を取得する

front.mwnd[0].init_window_pos($x, $y)       // 位置を初期値に戻す
front.mwnd[0].init_window_size($x, $y)      // 大きさを初期値に戻す
front.mwnd[0].init_window_moji_cnt($x, $y)  // 文字数を初期値に戻す
</pre>

	メッセージウィンドウの位置や大きさ、文字数を取得／設定します。
	サンプルプロジェクトの「メッセージの位置や大きさを変更する」を参照して下さい。

+ 注意点

	メッセージウィンドウの大きさを変えても、可変枠の場合に枠の大きさが変わるだけです。
	固定枠の場合の枠の大きさや、文字数などは変わりません。文字数を一緒に変えて下さい。




■ メッセージウィンドウの枠を変更する

+ 枠番号を指定する

<pre class="exp">
front.mwnd[0].set_waku
front.mwnd[0].set_waku($msg_waku_no)
front.mwnd[0].set_waku($msg_waku_no, $name_waku_no)

※簡易版もあります。
set_waku
set_waku($msg_waku_no)
set_waku($msg_waku_no, $name_waku_no)
</pre>

	メッセージウィンドウ、および名前ウィンドウに使う枠番号を設定します。
	枠番号は、Gameexe.ini の「メッセージウィンドウ枠個別の設定」で登録したものです。

	-1 で「枠なし」になります。
	省略すると、Gameexe.ini で設定したデフォルトの枠番号が使われます。

<pre class="source">
set_waku(1, 2)         // メッセージウィンドウの枠を１番、名前ウィンドウの枠を２番に設定する
</pre>

+ 枠の画像だけを初期化／取得／変更する

<pre class="exp">
front.mwnd[0].init_waku_file
front.mwnd[0].set_waku_file($waku_file)
s[0] = front.mwnd[0].get_waku_file
</pre>

	枠の画像のみを初期化、設定、変更します。
	付随するボタンやキー待ちアイコンなどには影響しません。

+ 枠のフィルター画像だけを初期化／取得／変更する

<pre class="exp">
front.mwnd[0].init_filter_file
front.mwnd[0].set_filter_file($filter_file)
s[0] = front.mwnd[0].get_filter_file
</pre>

	枠のフィルター画像のみを初期化、設定、変更します。



■ メッセージウィンドウボタン制御

+ メッセージウィンドウのボタンを禁止／解除する

<pre class="exp">
syscom.set_mwnd_btn_disable                  // メッセージウィンドウのボタンを禁止する
syscom.set_mwnd_btn_disable($mwnd_btn_no)    // メッセージウィンドウのボタンを禁止する（個別）
syscom.set_mwnd_btn_enable                   // メッセージウィンドウのボタンの禁止を解除する
syscom.set_mwnd_btn_enable($mwnd_btn_no)     // メッセージウィンドウのボタンを禁止を解除する（個別）
</pre>

	メッセージウィンドウのボタンを禁止状態にします。
	ボタンアクションの「DISABLE」の設定が使われます。 
	<font color="red">通常は使わないコマンドです。</font>「注意」を参照して下さい。

++ $mwnd_btn_no

	Gameexe.ini で登録したボタンの番号です。

<pre>
#WAKU.000.BTN.000.TYPE = "close_mwnd"          // ボタンの種類（メッセージウィンドウを閉じる）
             ^^^^^ ←ココ
</pre>

++ 注意

	通常は使わないコマンドです。
	システムコマンドのオンオフコマンドなどを使って下さい。

<ul>
- 例：セーブを禁止したい → システムコマンドの「セーブ」を禁止するべき（[[システムコマンド]] 参照）
- 例：早送りを禁止したい → システムコマンドの「早送り」を禁止するべき（[[早送り制御]] 参照）
</ul>

+ メッセージウィンドウのボタンを触れなくする／解除する

<pre class="exp">
syscom.set_mwnd_btn_touch_disable            // メッセージウィンドウのボタンを触れなくする
syscom.set_mwnd_btn_touch_enable             // メッセージウィンドウのボタンの触れなくするを解除する
</pre>

	メッセージウィンドウのボタンを触れなくします。
	ボタンの見かけは「有効」ですが、マウスを当てても反応しなくなります。













■ メッセージウィンドウ開閉アニメ

+ メッセージウィンドウが開閉するときのアニメを変更する

<pre class="exp">
front.mwnd[0].init_open_anime_type                  // 開くアニメのタイプを初期化する
front.mwnd[0].set_open_anime_type($type)            // 開くアニメのタイプを設定する
a[0] = front.mwnd[0].get_open_anime_type            // 開くアニメのタイプを取得する
a[0] = front.mwnd[0].get_default_open_anime_type    // 開くアニメのデフォルトのタイプを取得する

front.mwnd[0].init_open_anime_time                  // 開くアニメの時間を初期化する
front.mwnd[0].set_open_anime_time($time)            // 開くアニメの時間を設定する
a[0] = front.mwnd[0].get_open_anime_time            // 開くアニメの時間を取得する
a[0] = front.mwnd[0].get_default_open_anime_time    // 開くアニメのデフォルトの時間を取得する

front.mwnd[0].init_close_anime_type                 // 閉じるアニメのタイプを初期化する
front.mwnd[0].set_close_anime_type($type)           // 閉じるアニメのタイプを設定する
a[0] = front.mwnd[0].get_close_anime_type           // 閉じるアニメのタイプを取得する
a[0] = front.mwnd[0].get_default_close_anime_type   // 閉じるアニメのデフォルトのタイプを取得する

front.mwnd[0].init_close_anime_time                 // 閉じるアニメの時間を初期化する
front.mwnd[0].set_close_anime_time($time)           // 閉じるアニメの時間を設定する
a[0] = front.mwnd[0].get_close_anime_time           // 閉じるアニメの時間を取得する
a[0] = front.mwnd[0].get_default_close_anime_time   // 閉じるアニメのデフォルトの時間を取得する
</pre>

	デフォルトを取得：Gameexe.ini の設定を取得します。

	アニメタイプについては [[メッセージウィンドウ開閉アニメタイプ一覧]] を参照して下さい。

+ 一時的にメッセージウィンドウのアニメをオンにする／オフにする／解除する

<pre class="exp">
script.set_mwnd_anime_on_flag($onoff)         // 一時的にアニメを行うフラグを設定する（0=解除する、1=設定する）
a[0] = script.get_mwnd_anime_on_flag($onoff)  // 一時的にアニメを行うフラグを取得する（0=解除する、1=設定する）
script.set_mwnd_anime_off_flag($onoff)        // 一時的にアニメを行わないフラグを設定する（0=解除する、1=設定する）
a[0] = script.get_mwnd_anime_off_flag($onoff) // 一時的にアニメを行わないフラグを取得する（0=解除する、1=設定する）
</pre>

	環境設定の「メッセージウィンドウのアニメを無効にする」機能に関するコマンドです。
	このコマンドは、一時的に機能をオンにする／オフにする／解除するコマンドです。

++ set_mwnd_anime_on_flag(1)

	環境設定を無視して、強制的にメッセージウィンドウのアニメを行うようにします。
	set_mwnd_anime_on_flag(0) で元に戻します。

++ set_mwnd_anime_off_flag(1)

	環境設定を無視して、強制的にメッセージウィンドウのアニメを行わないようにします。
	set_mwnd_anime_off_flag(0) で元に戻します。

	この２つは別々のフラグなので注意して下さい。


■ メッセージウィンドウパラメータ

+ 子供オブジェクト

<pre class="exp">
front.mwnd[0].object
</pre>

	メッセージウィンドウも子供としてオブジェクトを持っています。
	個数は [[メッセージウィンドウ枠の設定]] で設定します。変更はできません。
	オブジェクトについては [[オブジェクト]] を参照して下さい。

+ ワールドを指定する

<pre class="exp">
front.mwnd[0].world = 0
</pre>

+ レイヤー値を指定する

<pre class="exp">
front.mwnd[0].layer = 0
</pre>



■顔グラフィック

	メッセージウィンドウに顔グラ（顔グラフィック）を設定できます。
	設定した顔グラは、r コマンドや clear コマンドによって、メッセージと一緒に消えます。

	顔グラは標準では１つだけ使えます。
	２つ以上使いたい場合は、設定ファイルの設定を変更して下さい。
	（[[メッセージウィンドウ枠個別の設定]] 参照）

+ 顔グラの個数を設定する

++ 設定ファイル

<pre class="source">
#WAKU.FACE.CNT = 1      // 顔グラフィックの個数
</pre>

+ 顔グラのレイヤーを設定する

++ 設定ファイル

<pre class="source">
#MWND.FACE_LAYER_REP = 20       // 顔グラのレイヤー値補正
</pre>

	メッセージウィンドウ自体のレイヤーに、この値が加算されます。

+ 顔グラの初期設定

	顔グラは、メッセージウィンドウ枠につけることになります。
	[[メッセージウィンドウ枠個別の設定]] を参照して下さい。



■顔グラフィックを設定する

<h4>顔グラを設定する</h4>

<pre class="exp">
set_face($file_name)
set_face($face_no, $file_name)
</pre>

	顔グラを指定します。
	$face_no には顔グラの番号を指定します。省略すると、顔グラ 0 番が使われます。

<h4>顔グラフィックを消去する</h4>

<pre class="exp">
clear_face
</pre>

	顔グラを消去します。

	メッセージをクリアすると顔グラも同時に消去されるので、
	あまり使うことのないコマンドだと思います。


■ 顔グラ（詳細）

	顔グラを簡単に扱うには [[顔グラフィック]] を参照して下さい。

	顔グラは、オブジェクトの一種です。
	オブジェクトと同様に扱うことができます。
	詳しくは [[オブジェクト]] を参照して下さい。

<pre class="exp">
front.mwnd[0].face[0]
</pre>

+ サンプル：顔グラを設定し、半透明にする

<pre class="source">
set_face(FC001)                        // 顔グラフィックを読み込む
front.mwnd[0].face[0].tr = 128         // 顔グラフィックの不透明度を設定する
</pre>

+ サンプル：顔グラを設定し、トーンカーブをかける

<pre class="source">
set_face(FC001)                        // 顔グラフィックを読み込む
front.mwnd[0].face[0].tonecurve_no = 0 // 顔グラフィックにトーンカーブを設定する
</pre>

	トーンカーブについては [[トーンカーブ]] を参照して下さい。

+ サンプル：顔グラを設定し、位置を動かす

<pre class="source">
set_face(FC001)                        // 顔グラフィックを読み込む
front.mwnd[0].face[0].x_rep.resize(1)  // 修正座標Ｘを１つ作る
front.mwnd[0].face[0].x_rep[0] = 100   // 修正座標Ｘを 100 にする
</pre>

	<font color="red">顔グラのＸ座標、Ｙ座標はシステムに予約されています。</font>
	座標を動かすには、修正座標を使って下さい。
	修正座標については [[オブジェクトパラメータ（座標関連）]] を参照して下さい。

+ サンプル：顔グラを設定し、イベント位置を動かす

<pre class="source">
set_face(FC001)                        // 顔グラフィックを読み込む
front.mwnd[0].face[0].x_rep.resize(1)  // 修正座標Ｘを１つ作る
front.mwnd[0].face[0].x_rep_eve[0].set(0, 1000, 0, 2, start=20)
                // 修正座標Ｘのイベントで、-20～0 に、1000ﾐﾘ秒かけて移動する
</pre>

	オブジェクトなので、イベントなども使えます。
	イベントについては [[イベント]] を参照して下さい。



■ メッセージバック

	メッセージバックは、システムが自動制御します。
	メッセージが表示されると、メッセージバックにメッセージが追加されます。

	メッセージバックの設定に関しては [[メッセージバックの設定]] を参照して下さい。

	メッセージバックは、キーボードの [PageUp] またはマウスのホイール上で開きます。
	スクリプトからメッセージバックを呼び出すには、syscom.open_msg_back を使います。
	[[システムコマンド]] を参照して下さい。
	ただし、メッセージバックが空の場合は、メッセージバックを開くことはできません。

	メニュー画面やスタッフロール中など、
	メッセージバックを一時的に開かせなくするには、script.set_msg_back_disable を使います。
	[[その他のメッセージバック制御]] を参照して下さい。

	選択画面での情報表示など、メッセージバックに追加したくないメッセージを表示するには、
	script.set_msg_back_off を使います。
	[[その他のメッセージバック制御]] を参照して下さい。

	<font color="red">New!</font> メッセージバックにロードボタンが置けるようになりました。
	[[メッセージバックセーブについて]] を参照して下さい。



■ メッセージバックセーブについて

	メッセージバックセーブは、メッセージバックの好きな位置からロードできる機能です。
	ただし、制限がいくつかあります。

	メッセージバックセーブは、メモリを多く使います。
	タスクマネージャより使用メモリ量を確認しながら個数を設定して下さい。
	ゲームを起動し、Ctrl スキップを続けると、使用メモリ量があがっていくのが確認できると思います。
	目安としては、通常パートで 300MB を超えないくらいがいいと思います。

	設定した個数以上はさかのぼることができません。古いセーブから自動で消えていきます。

	メッセージバックセーブ自体はセーブされません。
	別のシーンをロードすると、メッセージバックセーブはクリアされます。

	メッセージバックセーブを有効にするには、
	[[メッセージバックセーブの設定]] よりメッセージバックセーブの個数を 1 以上に設定して下さい。
	また、[[メッセージバックの設定]] よりメッセージバック上にロードボタンを配置して下さい。

	メッセージをクリックしたときの挙動を「ロードする」に変更することもできます。
	[[メッセージバックの設定]] を参照して下さい。
	デフォルトは「声を再生する」です。

	メッセージバックロードでは、デフォルトの確認ダイアログが表示されます。
	グラフィカルにダイアログを表示したい場合は、[[メッセージバックロードについて]] を参照して下さい。




■ メッセージバックロードについて

	メッセージバックロードでは、デフォルトの確認ダイアログが表示されます。
	グラフィカルにダイアログを表示したい場合は、
	メッセージバックからロードが選ばれた場合に呼ばれるコマンドを設定して下さい。
	[[メッセージバックの設定]] を参照して下さい。

	以下のサンプルを参考にして下さい。


+ サンプル：メッセージバックからロードが選ばれた場合に呼ばれるコマンド

<pre class="source">
command $msgbk_btn_load
{
	// システムコールを準備します。
	excall.alloc

	excall.front.object[0].create_rect(0, 0, 1280, 720, 0, 0, 0, 128, 1)
	excall.front.object[1].create_string("ロードする", 1, 500, 300)
	excall.front.object[1].set_string_param(48, 0, 0, 0, 0, 1, -1)
	excall.front.object[1].set_button(0, 0, 2, 0)
	excall.front.object[2].create_string("ロードしない", 1, 500, 400)
	excall.front.object[2].set_string_param(48, 0, 0, 0, 0, 1, -1)
	excall.front.object[2].set_button(1, 0, 2, 0)

	L[0] = excall.front.objbtngroup[0].sel
	switch (L[0])	{
	case (0)	syscom.msg_back_load(0, 1, 1)
	case (1)	// 何もしない
	}

	// システムコールを解放します。
	excall.free
}
</pre>

+ 実際にメッセージバックロードを行うコマンド

<pre class="exp">
syscom.msg_back_load($warning, $se_play, $fade_out)
</pre>

	実際にメッセージバックロードを行うコマンドです。
	「メッセージバックからロードが選ばれた場合に呼ばれるコマンド」の中で、
	実際にロードを行うときに呼んで下さい。









■ メッセージバックをクリアする

<pre class="exp">
clear_msgbk
</pre>

	メッセージバックをクリアします。

	ゲームの終了時や、回想モード終了時などは returnmenu で戻るのが普通です。
	returnmenu を使わない場合、このコマンドを使ってメッセージバックをクリアしてあげるのがいいと思います。



■ メッセージバックに文章を追加する

+ メッセージバックに文章を追加する

<pre class="exp">
// 簡易版
msgbk.insert_msg($msg)              // メッセージを１つ進めてメッセージを追加

// 詳細版
msgbk.go_next_msg                   // メッセージを１つ進める
msgbk.add_koe($koe_no, $chara_no)   // 声を設定
msgbk.add_namae($name)              // 名前を設定
msgbk.add_msg($msg)                 // メッセージを設定
</pre>

	メッセージバックに文章を追加することができます。
	文章をグラフィカルに演出した後、バックログでも読み返せるといいなってときに使うと効果的です。

+ サンプル：声、名前、メッセージを設定したメッセージバックを１つ追加する

<pre class="source">
msgbk.go_next_msg                   // メッセージを１つ進める
msgbk.add_koe(101900033,004)        // 声を設定
msgbk.add_namae(静流)               // 名前を設定
msgbk.add_msg(じむの間違いでは)     // メッセージを追加
msgbk.add_msg(なかったのか…！)     // メッセージを追加
</pre>

	go_next_msg を忘れないようにして下さい。

+ 名前付き引数

	デバッグモード時、メッセージバック中に 'O' キーを押すと、該当のシーンがエディタで開きます。
	開くシーン名と行番号は自動的に決まりますが、指定することもできます。

<pre class="source">
// 簡易版
msgbk.insert_msg("sample.ss の100行目を開きます。", debug_scene = "sample", debug_line = 100)

// 詳細版
msgbk.go_next_msg
msgbk.add_koe(0, 0, debug_scene = "sample", debug_line = 100)
msgbk.add_namae("なまえ", debug_scene = "sample", debug_line = 100)
msgbk.add_msg("sample.ss の100行目を開きます。", debug_scene = "sample", debug_line = 100)
</pre>

	詳細版の場合は、最後に指定したシーン名と行番号が適用されます。

	debug_line を省略するか 0 を指定すると、現在の行が開きます。










■ メッセージバックに画像を挟む

<div align="center">
<img src="msgbk_sep.png">
</div>

+ メッセージバックに画像を挟む

<pre class="exp">
insert_msgbk_img($file_name)
insert_msgbk_img($file_name, $x)
</pre>

	メッセージバック中に画像を挟むことができます。

	区切り棒や章タイトルを入れるのに使って下さい。

++ 画像のマージンについて

	メッセージと画像の間は詰められます（スペースは空けられません）。
	スペースを空けたい場合は、画像のサイズを工夫して下さい。


■ その他のメッセージバック制御

+ 一時的にメッセージバックに入る機能を禁止する／解除する

<pre class="exp">
script.set_msg_back_disable         // 一時的にメッセージバックに入るのを禁止する
script.set_msg_back_enable          // 解除する
</pre>

	PageUp キーやホイールの上回転でメッセージバックに入る機能を、一時的にオフにします。

+ 一時的にメッセージバックにメッセージを追加する機能を禁止する／解除する

<pre class="exp">
script.set_msg_back_off             // 一時的にメッセージバックにメッセージを追加しなくする
script.set_msg_back_on              // 解除する
</pre>

	メッセージは基本的に、自動的にメッセージバックに追加されていきます。
	一時的にその機能をオフにするコマンドです。



■選択肢

	選択肢を表示するには、sel コマンドを使います。

	選択は、デフォルトではメッセージウィンドウ１番が使われます。
	Gameexe.ini の以下の設定で変更できます。

<pre class="source">
#MWND.DEFAULT_SEL_MWND_NO = 1   // デフォルトのメッセージウィンドウ番号（選択肢用）
</pre>

<h4>選択肢を表示する</h4>

<pre class="exp">
a[0] = sel(*, *, *, ...)
a[0] = sel_cancel(*, *, *, ...)     // 右クリックでキャンセルできる

(*) = $str
(*) = $str, $state
(*) = $str, $state, $color
</pre>

	$state, $color については [[選択肢の制御コード]] を参照して下さい。

<h5>選択肢による分岐の例</h5>

<pre class="source">
l[0] = sel(
    "かいにきた",         // 選択肢０番
    "うりにきた",         // 選択肢１番
    "やめる"              // 選択肢２番
)
switch (l[0])   {
    case (00)   goto #kainikita
    case (01)   goto #urinikita
    case (02)   goto #yameru
}
</pre>

<h5>戻り値</h5>

	選ばれた選択肢によって、上から順に 0, 1, 2 ... が返ってきます。
	上の例では、選択によって #kainikita、#urinikita、#yameru にジャンプしています。

<h5>キャンセル</h5>

	sel_cancel の場合、右クリックで選択をキャンセルできます。
	キャンセルした場合の戻り値は -1 です。
	選択中は右クリックでシステムコマンドメニューが呼び出せなくなるので、
	注意して使って下さい。

<h4>選択肢直前のメッセージ</h4>

<pre class="source">
選択してください。<font color="red">r</font>      // ここの r 命令を色々置き換えてください。

l[0] = sel(～)

print(l[0])番を選択しました。r
</pre>

	選択肢直前のメッセージには r 命令を入れてもいいですが、
	他の命令を入れてもいいです。

<div class="table-container">
<table>
<tr><td>clear</td><td>キー待ちを行わずに選択を行う</td></tr>
<tr><td>r</td><td>キー待ち後に選択を行う</td></tr>
<tr><td>r + close</td><td>キー待ち後、メッセージウィンドウを閉じてから選択を行う</td></tr>
</table>
</div>



■ 選択肢に使うウィンドウを変更する

+ 選択肢に使うウィンドウを変更する

<pre class="exp">
set_sel_mwnd($mwnd)
set_sel_mwnd($mwnd_no)
</pre>

++ 使い方の例

<pre class="source">
// メッセージウィンドウ２番を選択肢で使うウィンドウに設定する
set_sel_mwnd(2)              

// メッセージウィンドウを直接指定することも可能
set_sel_mwnd(front.mwnd[2])
</pre>

	選択肢に使うデフォルトのメッセージウィンドウを変更するには、
	Gameexe.ini で設定して下さい。
	詳しくは [[メッセージウィンドウの設定]] を参照して下さい。


■現在のウィンドウで選択肢を表示する

	sel コマンドでは、選択肢用のウィンドウを使って選択を行いました。
	現在のウィンドウで選択を行うには、selmsg を使います。

<h4>選択肢を表示する</h4>

<pre class="exp">
a[0] = selmsg(*, *, *, ...)
a[0] = selmsg_cancel(*, *, *, ...)

(*) = $str
(*) = $str, $state
(*) = $str, $state, $color
</pre>

	$state, $color については [[選択肢の制御コード]] を参照して下さい。

	その他の使い方については sel コマンドと同じです。[[選択肢]] を参照して下さい。


■ ボタン選択肢

	画像を使ったボタンで選択を行います。
	設定ファイルで [[ボタン選択肢の設定]] をする必要があります。

+ ボタン選択肢を表示する

<pre class="exp">
a[0] = selbtn(*, *, *, ...)
a[0] = selbtn($selbtn_no, *, *, *, ...)
a[0] = selbtn_cancel(*, *, *, ...)
a[0] = selbtn_cancel($selbtn_no, *, *, *, ...)

(*) = $str
(*) = $str, $state
(*) = $str, $state, $color
</pre>

	$selbtn_no で ini の登録番号を指定します。
	省略すると登録番号０番が使われます。

	$state, $color については [[選択肢の制御コード]] を参照して下さい。

	その他の使い方については sel コマンドと同じです。[[選択肢]] を参照して下さい。


■選択肢の制御コード

<h4>制御コード</h4>

	制御コードを使って、特定の選択肢を選べなくしたり、非表示にしたりできます。

<div class="table-container">
<table>
<tr><td rowspan="4">$state</td><td>0</td><td>非表示、空きを詰める</td></tr>
|1|表示、選択可|
|2|表示、選択不可|
|3|非表示、空きを詰めない|
|$color</td><td colspan="2">Gameexe.ini で指定した色番号|
</table>
</div>

<h5>制御コードの使用例</h5>

<pre class="source">
l[0] = sel(
    "選択肢１（選択可）",   1, 2,  // 表示、選択可、色は２番
    "選択肢２",             0, 0,  // 非表示、空きを詰める、色は０番
    "選択肢３（選択不可）", 2, 3,  // 表示、選択不可、色は３番
    "選択肢４（非表示）",   3, 4,  // 非表示、空きを詰めない、色は４番
    "選択肢５（選択可）",   1, 0   // デフォルトの選択肢
)

switch (l[0])	{
    case (0)    選択肢１を選択しました。r
    case (1)    選択肢２を選択しました。r
    case (2)    選択肢３を選択しました。r
    case (3)    選択肢４を選択しました。r
    case (4)    選択肢５を選択しました。r
}
</pre>

<pre class="result">
<font color="red">選択肢１</font>        // state が 1 なので選択できます
<font color="green">選択肢３</font>        // state が 2 なので選択できません
                // state が 3 なので表示されません（選択もできません）
選択肢５        // state が 1 なので通常の選択肢です。

// 選択肢２は state が 0 なので表示されず、空きも詰められます。
</pre>


■ ステージ

	ステージは、画面に表示される１枚のプレーンです。
	オブジェクト、メッセージウィンドウなど、画面に表示されるものは、ステージ上に配置されます。

	通常時は「フロントステージ」が画面に表示されています。
	対して「バックステージ」は、画面に表示されません。
	「バックステージ」は、「ワイプ」を行うのに使います。
	「バックステージ」にオブジェクトを準備し、「ワイプ」を行うことで、
	徐々に「フロントステージ」から「バックステージ」に画面が切り替わります。

	通常、ゲームは次のように進みます。

<ul>
<li>「バックステージ」にオブジェクトを準備する</li>
<li>「ワイプ」を行う。バックステージがフロントステージにコピーされ、オブジェクトが画面に表示される</li>
<li>「フロントステージ」にメッセージを表示する</li>
</ul>

+ ステージ

	それぞれのステージは back、front、next で指定します。
	stage[0]、stage[1]、stage[2] でも指定できます。

+ オブジェクト

<pre class="exp">
back.object
front.object
next.object
</pre>

	オブジェクトについては [[オブジェクト]] を参照して下さい。

+ オブジェクトボタングループ（オブジェクトボタングループ）

<pre class="exp">
back.objbtngroup
front.objbtngroup
next.objbtngroup
</pre>

	オブジェクトボタングループについては [[オブジェクトボタングループ]] を参照して下さい。

+ メッセージウィンドウ

<pre class="exp">
back.mwnd
front.mwnd
next.mwnd
</pre>

	メッセージウィンドウについては [[メッセージウィンドウ]] を参照して下さい。

+ エフェクト

<pre class="exp">
back.effect
front.effect
next.effect
</pre>

	エフェクトについては [[エフェクト]] を参照して下さい。

+ クエイク

<pre class="exp">
back.quake
front.quake
next.quake
</pre>

	クエイクについては [[クエイク]] を参照して下さい。



■ オーダー

	各 [[ステージ]] は、オーダーに分かれています。
	オブジェクトはオーダー０に、メッセージウィンドウはオーダー１に描画されます。
	（メッセージウィンドウのオーダーについては [[メッセージウィンドウの設定]] で変更できます。）

	オーダーは、番号の大きいほうが上に表示されます。
	つまり、オーダー０のオブジェクトよりオーダー１のメッセージウィンドウの方が上に表示されます。

	メッセージウィンドウより上にオブジェクトを表示したい場合は、
	オブジェクトのオーダーを指定します。

++ オブジェクトのオーダーを変更する

<pre class="source">
front.object[0].order = 2   // オブジェクトのオーダーを２にする
                            // （メッセージウィンドウより上に表示される）
</pre>

	ワイプやクエイクなどの演出は、範囲をオーダー単位で指定できます。
	例えば、オーダー０のみをクエイクした場合、オブジェクトのみが揺れます。
	オーダー０～１をクエイクした場合は、メッセージウィンドウごと揺れます。

++ クエイクのオーダーを指定する

<pre class="source">
// オーダー１のみを揺らす（メッセージウィンドウのみを揺らす）
// タイプ＝０（片方向）、時間＝1000ﾐﾘ秒、揺れ回数＝２＋１回、向き＝４（下）
screen.quake[0].start(0, 1000, 2, 1, <font color="red">1</font>, <font color="red">1</font>, [100, 4])

// オーダー０～１を揺らす（オブジェクトとメッセージウィンドウを揺らす）
// タイプ＝０（片方向）、時間＝1000ﾐﾘ秒、揺れ回数＝３回、向き＝０（上）
screen.quake[0].start(0, 1000, 3, 0, <font color="red">0</font>, <font color="red">1</font>, [100, 0])

// 全てのオーダーを揺らす
// タイプ＝０（片方向）、時間＝1000ﾐﾘ秒、揺れ回数＝３回、向き＝０（上）
screen.quake[0].<font color="red">start_all</font>(0, 1000, 3, 0, [100, 0])
</pre>

++ ワイプのオーダーを指定する

	ワイプは名前つき引数を使ってオーダーを指定します。
	（クエイクなどと引数の名前が違うので注意して下さい。）

<pre class="source">
// オーダー０のみをワイプ（オブジェクトのみをワイプ）
back.object[0].create(BG001, 1)
wipe(start_order=0, end_order=0)
てすと。r

// オーダー０～１をワイプ（メッセージウィンドウごとワイプ）
back.object[0].create(BG002, 1)
wipe(start_order=0, end_order=1)

// 全てのオーダーをワイプする
back.object[0].create(BG003, 1)
wipe_all
</pre>




■ ワイプ

	ワイプを行います。

+ ワイプを行う

<pre class="exp">
wipe
wipe($type)
wipe($type, $time)
wipe($type, $time, $speed_mode)
wipe($type, $time, $speed_mode, [$opt00, $opt01, ...])
</pre>

++ 使い方の例

<pre class="source">
// ワイプ番号０番（クロスフェード）でワイプする
wipe(0)

// ワイプ番号１５番（元絵も一緒にスクロール）で、
// 右から（オプション＝３番）、500 ﾐﾘ秒かけてワイプする
wipe(15, 500, [3])

// ワイプ番号４番（じわだし）のサイズは 32×32 で、
// 1000 ﾐﾘ秒かけて、加速するように（speed_mode = 1）ワイプする
wipe(4, 1000, 1, [0, 32, 32])
</pre>

++ 引数

<div class="table-container">
<table>
<tr><td>$type</td>

<td>
ワイプタイプを指定します。
ワイプタイプを変更すると、「クロスフェード」させたり「スラインドイン」させたりできます。
詳しくは [[ワイプタイプ一覧]] を参照してください。
フェード効果については説明が難しいですが、実際に動かして目で確認してください。
</td>
</tr>

<tr><td>$time</td>

<td>ワイプにかける時間を指定します。省略すると500ﾐﾘ秒でワイプします。</td>
</tr>

<tr><td>$speed_mode</td>

<td>スピードモードを指定します。0=等速、1=加速、2=減速</td>
</tr>

</table>
</div>

+ 高度な設定

	より高度な設定については [[ワイプの高度な設定]] を参照して下さい。




■マスクワイプ

	マスク用の画像を作ることで、オリジナルのワイプパターンを作ることができます。

	ワイプ番号には 900 番台以降を指定してください。（900=マスクワイプ、901=マスク拡大ワイプ）

<pre class="exp">
mask_wipe($mask_file)
mask_wipe($mask_file, $type)
mask_wipe($mask_file, $type, $time)
mask_wipe($mask_file, $type, $time, $speed_mode)
mask_wipe($mask_file, $type, $time, $speed_mode, [$opt00, $opt01, ...])
</pre>

<h4>マスク画像の作り方</h4>

	マスク画像は、通常の画像と同じ 32bit カラーで作ります。このうち、Ｒ値がマスクとして使われます。

<h4>高度な設定</h4>

	より高度な設定については [[ワイプの高度な設定]] を参照して下さい。


■ ワイプを止める／待つ／判定する

+ ワイプを終了する

<pre class="exp">
wipe_end
</pre>

	ワイプを終了します。

+ ワイプが終了するのを待つ

<pre class="exp">
a[0] = wait_wipe

名前つき引数 = {key_skip}
</pre>

	ワイプが終了するのを待ちます。
	環境設定で「画面暗転効果をマウスクリックで飛ばす。」がオンの場合、決定キーで処理をスキップできます。
	決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

	環境設定を無視して「必ずキーで飛ばせるように、または飛ばせなく」するには、
	名前つき引数の key_skip を使って下さい。

++ key_skip

	ワイプをマウスクリックで飛ばせるかを指定します。（0=飛ばせない、1=飛ばせる、-1=環境設定に従う）
	指定しない場合は環境設定に従います。

	key_skip=0 を指定すると、環境設定に関係なく、クリックで飛ばせなくなります。
	また、key_skip=1 を指定すると、環境設定に関係なく、クリックで飛ばせるようになります。

<pre class="source">
// ワイプが終了するのを待ちます。環境設定に関係なく、クリックで飛ばせません。
wait_wipe(key_skip=0)

// ワイプが終了するのを待ちます。環境設定に関係なく、クリックで飛ばせます。
wait_wipe(key_skip=1)
</pre>


+ ワイプ中かを判定する

<pre class="exp">
a[0] = check_wipe
</pre>

	ワイプ中かどうかを判定します。0=ワイプ中でない、1=ワイプ中


■ オーダーを指定する

	ワイプする範囲を指定します。

	wipe コマンドは、デフォルトではオーダー０のみがワイプされます。
	オーダーを指定することで、メッセージウィンドウごとワイプしたりできます。

	オーダーについては [[オーダー]] を参照して下さい。

	オーダーは [[ワイプの高度な設定]] で指定します。

	全てのオーダーをワイプするコマンドもあります。

	[[ワイプコピー]] も参照して下さい。

+ ワイプされる条件

	ワイプされる条件は少しややこしいです。
	以下のいずれかが満たされていた場合、ワイプされます。

<ul>
- フロントのオーダーが、ワイプで指定したオーダー内にある
- バックが準備されている（create されている、または子供を持っている）
</ul>

+ 全てのオーダーをワイプする

<pre class="exp">
wipe_all
wipe_all($type)
wipe_all($type, $time)
wipe_all($type, $time, $speed_mode)
wipe_all($type, $time, $speed_mode, [$opt00, $opt01, ...])

mask_wipe_all($mask_file)
mask_wipe_all($mask_file, $type)
mask_wipe_all($mask_file, $type, $time)
mask_wipe_all($mask_file, $type, $time, $speed_mode)
mask_wipe_all($mask_file, $type, $time, $speed_mode, [$opt00, $opt01, ...])
</pre>



■ ワイプ（高度な設定）

	wipe, wipe_all, mask_wipe, mask_wipe_all コマンドは、名前つき引数が使えます。
	名前つき引数を使うことで、より高度な設定ができます。

<pre class="exp">
名前つき引数 = {type, time, start_time, speed_mode, option, wait, key_skip, start_order, end_order, start_layer, end_layer, with_low_order}
</pre>

++ 名前つき引数の使い方の例

<pre class="source">
// ワイプする、ワイプの終了を待たない（wait=0）
wipe(wait=0)

// ワイプ番号４番（じわだし）（type=4）、サイズは 32×32（option=[0, 32, 32]）でワイプする
wipe(type=4, option=[0, 32, 32])

// ワイプ番号１５番（元絵も一緒にスクロール）で、1000ﾐﾘ秒でワイプする
// キーを押してもスキップできない（key_skip=0）
wipe(15, 1000, key_skip=0)
</pre>

++ 名前つき引数

<div class="table-container">
<table>
|type|引数の $type と同じです。|
|time|引数の $time と同じです。|
|start_time|ワイプの開始時刻を設定します。例えば start_time=1000 の場合、1000ﾐﾘ秒進んだ状態からワイプが始まります。|
|speed_mode|引数の $speed_mode と同じです。|
|option|引数の [$opt00, $opt01, ...] の部分と同じです。|
<tr><td>wait</td>
<td>
ワイプが終わるのを待つかどうかを指定します。（0=待たない、1=待つ）<br />
省略した場合は 1 が使われます。
</td></tr>
<tr><td>key_skip</td>
<td>
wait=1 の時に、ウェイトをキーで飛ばせるかを指定します。（0=飛ばせない、1=飛ばせる、-1=環境設定に従う）<br />
省略した場合は -1 が使われます。
</td></tr>
<tr><td>start_order, end_order</td>
<td>
ワイプするオーダーの範囲を指定します。
オーダーについては [[オーダー]] を参照して下さい。
</td></tr>
<tr><td>start_layer, end_layer</td>
<td>
ワイプするレイヤーの範囲を指定します。
詳しくは [[オーダー]] を参照して下さい。
</td></tr>
|with_low_order|ワイプ時に下のオーダーごと動かします。詳しくは [[下のオーダーも一緒に動かす]] を参照して下さい。|
</div>












■ 下のオーダーも一緒に動かす

	200～300 番台の移動系ワイプを使うとき、
	普通にワイプする場合は問題ありませんが、オーダーを指定したり、
	システムコール中にワイプするときは注意が必要です。

	例えば、システムコール（右クリックメニューなど）で excall を使っているとします。
	このときにワイプを行うと、excall の部分のみがワイプされます。
	ゲーム部分の背景などはワイプされずに残ったままになります。

	移動系ワイプの場合、ゲーム部分も含めて動いてほしいことがあると思います。
	その場合は with_low_order を使います。

<pre class="source">
// ３Ｄ回転ワイプ、1000ﾐﾘ秒、視野角＝45度、インアウト両方
wipe(300, 1000, 0, [1, 450, 0], <font color="red">with_low_order = 1</font>)
</pre>

<div class="table-container">
<table>
|<img src="with_low_order_off.png" />|<img src="with_low_order_on.png" />|
|with_low_order=0|with_low_order=1<br />（分かりやすくするため、画面を赤くしています。）|
</table>
</div>

	with_low_order=0 の場合は excall 部分のみが動いています。
	一方、with_low_order=1 の場合はゲーム部分も動きます。

	with_low_order=1 を指定しても、ゲーム部分がワイプされるわけではありません。
	つまり、back→front、front→next へのコピーは行われません。
	あくまで見た目上、ワイプされているように動くだけです。

	文章では分かりにくいと思います。実際に動かして見て下さい。



■ ３Ｄ回転ワイプ

	３Ｄ回転ワイプ（ワイプタイプ=300～）に関する注意です。

<pre class="exp">
３００　３Ｄで回転
	[Op0]: 0, 1    （回転の向き 0=時計回り 1=反時計回り）
	[Op1]: 1 - 1799（視野角（1=0.1度、1799=179.9度）小さいと視点が遠ざかります）
	[Op2]: 0 - 2   （0=通常、1=インのみ、2=アウトのみ）

３０１　３Ｄでページをめくる
	[Op0]: 0, 1    （回転の向き 0=時計回り 1=反時計回り）
	[Op1]: 1 - 1799（視野角（1=0.1度、1799=179.9度）小さいと視点が遠ざかります）
	[Op2]: 0 - 2   （0=通常、1=インのみ、2=アウトのみ）
</pre>

++ 視野角について

	サンプル準備中…。

	100～1500 くらいの間で動かして違いを見比べて下さい。
	300～450 あたりがちょうどいいと思います。

++ インのみ／アウトのみを行う

	300 番特有の話です。

	例えば、1000 ﾐﾘ秒で３Ｄ回転ワイプを行ったとします。
	前半の 500 ﾐﾘ秒で前の絵が消え、後半の 500 ﾐﾘ秒で次の絵が出てきます。

	前の絵が「黒」だったとすると、最初の 500 ﾐﾘ秒は何も表示されないことになります。
	この場合、最初の 500 ﾐﾘ秒は無視して 後半の 500 ﾐﾘ秒だけを行ってほしいと思います。

	Op2 を指定することでこれを実現できます。

	Op2 に 1 を指定した場合、後半の「次の絵を出す」のみが行われます。
	「黒→背景」にワイプするときに使って下さい。

	Op2 に 2 を指定した場合、前半の「前の絵を消す」のみが行われます。
	「背景→黒」にワイプするときに使って下さい。

	ただし、ワイプ時間が半分になるわけではなく、速度が半分になります。
	速度を等しくしたい場合は、時間に２倍の値を指定して下さい。



■オブジェクト

<h4>オブジェクトを初期化する</h4>

<pre class="exp">
front.object[0].init
</pre>

	オブジェクトを完全に初期化します。

<h4>オブジェクトのパラメータを初期化する</h4>

<pre class="exp">
front.object[0].init_param
</pre>

	オブジェクトのパラメータだけ（座標、不透明度など）を初期化します。読み込んだ画像などはそのままです。

<h5>初期化されるもの</h5>

<ul>
<li>表示フラグ、座標、不透明度、トーンカーブ番号などのパラメータ</li>
<li>イベント、フレームアクション、ＧＡＮ、ボタン</li>
</ul>

<h5>初期化されないもの</h5>

<ul>
<li>画像ファイル名、文字列、フィルタ、数値、など各タイプ固有のもの</li>
<li>ワイプコピーフラグ、ワイプ消去フラグ、子供</li>
</ul>

<h4>オブジェクトを解放する</h4>

<pre class="exp">
front.object[0].free
</pre>

<h5>初期化されるもの</h5>

<ul>
<li>画像、文字列、フィルタ、数値、など各タイプ固有のもの</li>
</ul>

<h5>初期化されないもの</h5>

<ul>
<li>表示フラグ、座標、不透明度、トーンカーブ番号などのパラメータ</li>
<li>イベント、フレームアクション、ＧＡＮ、ボタン</li>
<li>ワイプコピーフラグ、ワイプ消去フラグ、子供</li>
</ul>




■ オブジェクトを作成する

<h4>オブジェクトに画像を読み込む</h4>

<pre class="exp">
front.object[0].create($file_name)
front.object[0].create($file_name, $disp)
front.object[0].create($file_name, $disp, $x, $y)
front.object[0].create($file_name, $disp, $x, $y, $patno)
</pre>

	オブジェクトに画像を読み込みます。
	自動的にオブジェクトは初期化されます。

<h4>矩形オブジェクトを作成する</h4>

<pre class="exp">
front.object[0].create_rect($left, $top, $right, $bottom, $color_r, $color_g, $color_b, $color_tr)
front.object[0].create_rect($left, $top, $right, $bottom, $color_r, $color_g, $color_b, $color_tr, $disp)
front.object[0].create_rect($left, $top, $right, $bottom, $color_r, $color_g, $color_b, $color_tr, $disp, $x, $y)
</pre>

	矩形オブジェクトを作成します。
	自動的にオブジェクトは初期化されます。



■ 文字列オブジェクト

+ 文字列オブジェクトを作成する

<pre class="exp">
front.object[0].create_string($string)
front.object[0].create_string($string, $disp)
front.object[0].create_string($string, $disp, $x, $y)
</pre>

	文字列オブジェクトを作成します。
	自動的にオブジェクトは初期化されます。

+ 文字列オブジェクトの文字列を設定／取得する

<pre class="exp">
front.object[0].set_string($string)
s[0] = front.object[0].get_string
</pre>

+ 文字列オブジェクトのパラメータを設定する

<pre class="exp">
front.object[0].set_string_param($size, $space_x, $space_y, $moji_cnt, $moji_color, $shadow_color, $shdow_mode)
front.object[0].set_string_param($size, $space_x, $space_y, $moji_cnt, $moji_color, $shadow_color, $shdow_mode, $fuchi_color)
</pre>

<div class="table-container">
<table>
|$size|文字サイズ|
|$space_x|文字間の幅（通常は 0）|
|$space_y|行間の高さ（通常は 0）|
|$moji_cnt|文字数（全角文字数で指定）（自動改行のため。0=改行なし）|
|$moji_color|文字の色（カラーテーブルの番号で指定）|
|$shadow_color|影の色（カラーテーブルの番号で指定）|
|$shadow_mode|影の種類（-1=フォントの設定に従う、0=影なし、1=影あり、2=縁取り）|
|$fuchi_color|縁の色（カラーテーブルの番号で指定）|
</table>
</div>

+ 制御文字列

	以下の文字列は制御コマンドとして扱われます。

<div class="table-container">
<table>
|#D|改行する|
|#??S|文字サイズを ?? に変更する|
|#??C|文字の色を ?? に変更する（カラーテーブルの番号で指定）|
|#??X|現在のＸ座標を ?? に移動する|
|#??Y|現在のＹ座標を ?? に移動する|
|#??RX|現在のＸ座標に ?? を加算する|
|#??RY|現在のＹ座標に ?? を加算する|
|##|'#' を表示する|
</table>
</div>

++ 制御文字列の例

<div class="table-container">
<table>
<tr>
<td>&quot;あいう#24Sえおか#2Cきくけ#Dこさし##すせそ&quot;</td>
<td>あいう<font size="4">えおか<font color="red">きくけ<br />こさし#すせそ<font></font></td>
</tr>
</table>
</div>




■ 数値オブジェクト

+ 数値オブジェクト

	数値を表示するオブジェクトです。
	「０１２３４５６７８９－＋±」の順に切り出された g00 画像を使います。
	「◇サンプル開発環境」の number.g00 を参照して下さい。

+ 数値オブジェクトを作成する

<pre class="exp">
front.object[0].create_number($file)
front.object[0].create_number($file, $disp)
front.object[0].create_number($file, $disp, $x, $y)
</pre>

	数値オブジェクトを作成します。
	自動的にオブジェクトは初期化されます。

+ 数値オブジェクトの数値を設定／取得する

<pre class="exp">
front.object[0].set_number($num)
a[0] = front.object[0].get_number
</pre>

+ 数値オブジェクトのパラメータを設定する

<pre class="exp">
front.object[0].set_number_param($keta, $zero_mode, $sign_mode, $sign_pos_mode, $x_offset_mode, $x_offset)
</pre>

<div class="table-container">
<table>
|$keta|桁数|
|$zero_mode|桁数まで０で埋めるかどうか（0=埋めない、1=埋める）|
|$sign_mode|＋、±をつけるかどうか（0=つけない、1=つける）|
|$sign_pos_mode|$zero_mode が 0 のとき、符号と数値を詰めるかどうか（0=詰めない、1=詰める）|
|$x_offset_mode|桁と桁の距離を画像サイズに合わせるかどうか（0=合わせる、1=合わせない）|
|$x_offset|桁と桁の距離（$x_offset_mode が 0 のとき、この値に画像サイズが加算されます）|
</table>
</div>

+ サンプル：数値オブジェクトを表示する

<pre class="source">
// ５桁で、符号あり（符号を詰める）で数値オブジェクトを表示する
front.object[0].create_number(number, 1)
front.object[0].set_number_param(5, 0, 1, 1, 0, 0)
front.object[0].set_number(123)

// メッセージ
数値オブジェクトを表示しました。r
</pre>






■ 環境オブジェクト

	雪を降らしたり、花びらを散らしたりできます。

<div align="center">
<img src="snow320.jpg">
</div>

+ 環境オブジェクトを作成する

<pre class="exp">
front.object[0].create_weather($file)
front.object[0].create_weather($file, $disp)
</pre>

	create_weather だけでは環境は表示されません。
	set_weather_param_type_A などを使い、パラメータ詳細を設定して下さい。

+ 環境オブジェクトのタイプを設定する（タイプＡ）

<pre class="exp">
front.object[0].set_weather_param_type_A(
	$cnt,
	$pat_mode, $pat_no_1, $pat_no_2, $pat_time,
	$move_time_x, $move_time_y,
	$sin_time_x, $sin_power_x, $sin_time_y, $sin_power_y,
	$scale_x, $scale_y, 
	$real_time
	)
</pre>

	このコマンドは名前つき引数のみ対応しています。

++ 名前つき引数を使った例

<pre class="source">
	front.object[0].set_weather_param_type_A(
		cnt = 200,
		move_time_x = 5000,
		move_time_y = 2000,
		pat_mode = 0,
		pat_no_1 = 6,
		sin_time_x = 2000,
		sin_power_x = 20
		)
</pre>

	見やすいように途中で改行していますが、改行は無くてもいいです。

++ パラメータ詳細

<div style="table-container">
<table>
|cnt|粒の個数を指定します。<br />特に制限はありませんが、多すぎると処理が重たくなります。スペックの低いマシンで動かして見て下さい。|
<td>pat_mode, pat_no_1, pat_no_2, pat_time</td><td>
パターンモード<br />
0 = 固定（pat_no_1 のみが使われます）<br />
1 = ループ（pat_no_1 ～ pat_no_2 の範囲でループします。ループタイムは pat_time で指定します。）<br />
2 = ランダム（pat_no_1 ～ pat_no_2 の範囲でランダムで表示します。）</td></tr>
|move_time_x, move_time_y|x, y に対して、1000 ピクセル動くのにかかる時間をﾐﾘ秒で指定します。マイナスを指定すると逆方向に動きます。|
|sin_time_x, sin_power_x|横に揺れるのにかかる時間をﾐﾘ秒で、揺れ幅をピクセルで指定します。|
|sin_time_y, sin_power_y|縦に揺れるのにかかる時間をﾐﾘ秒で、揺れ幅をピクセルで指定します。|
|scale_x, scale_y|１粒１粒を拡大します（1000=等倍）。|
|real_time|実時間フラグ（0=ゲーム時間、1=実時間）<br />実時間で再生すると、Ctrl キーなどで早送りできなくなります。デフォルトではゲーム時間で再生されます。|
</table>
</div>

++ RealLive とのパラメータの違い

<ul>
- pat_mode について、3（固定、２つ表示）がなくなりました。
- move について、縦横が別々に指定できるようになりました。
- sin について、縦横が別々に指定できるようになりました。
- sin_power の計算式が変更されました。大きいほど揺れが大きくなります。（RealLive と逆）
- wind の指定がなくなりました。
</ul>

++ 途中でパラメータを変更する

	途中で粒の量を変えたり、速度を変えたりする場合は、set_weather_param_type_A を続けて使って下さい。
	自然な感じでタイプが切り替わりますが、およそ３秒ほどかかります。
	実際に使って確認して下さい。

++ 色んな大きさの粒を同時に表示する

	複数のオブジェクトを使って重ねて下さい。
	雪などの効果を作る場合は、大きい粒ほど手前に表示し、個数を減らすと効果的です。

++ サンプル：雪を降らす

<pre class="source">
// 背景とバストショットを準備する
back.object[0].create(BG001, 1)
back.object[1].create(CGM_KT10, 1, 640, 0)
back.object[1].layer = 20

// 雪（奥）
back.object[10].create_weather(snow, 1)
back.object[10].layer = 10                  // バストショットより奥
back.object[10].set_weather_param_type_A(   // 小さめの粒をたくさん降らす
	cnt = 300,
	move_time_x = 30000,
	move_time_y = 10000,
	pat_mode = 0,
	pat_no_1 = 0,
	sin_time_x = 2000,
	sin_power_x = 5
	)

// 雪（手前）
back.object[11].create_weather(snow, 1)
back.object[11].layer = 30                  // バストショットより手前
back.object[11].set_weather_param_type_A(   // 大きめの粒を少しだけ降らす
	cnt = 10,
	move_time_x = 5000,
	move_time_y = 2000,
	pat_mode = 0,
	pat_no_1 = 6,
	sin_time_x = 2000,
	sin_power_x = 20
	)

// ワイプして表示する
wipe
</pre>


+ 環境オブジェクトのタイプを設定する（タイプＢ）

<pre class="exp">
front.object[0].set_weather_param_type_B(
	$cnt,
	$pat_mode, $pat_no_1, $pat_no_2, $pat_time,
	$center_x, $center_y, $appear_range,
	$move_time,
	$sin_time_x, $sin_power_x, $sin_time_y, $sin_power_y,
	$center_rotate,
	$zoom_x, $zoom_y,
	$real_time
	)
</pre>

	見上げたような効果が得られます。実際にサンプルを動かして見て下さい。
	タイプＡと同様、名前つき引数のみ対応しています。

++ 名前つき引数を使った例

<pre class="source">
	front.object[0].set_weather_param_type_B(
		cnt = 1000,
		pat_mode = 0,
		pat_no_1 = 6,
		center_x = 100,
		center_y = 100,
		appear_range = 70,
		move_time = 5000,
		sin_time_x = 2000,
		sin_power_x = 10,
		zoom_min = 0,
		zoom_max = 2000
		)
</pre>

	見やすいように途中で改行していますが、改行は無くてもいいです。

++ パラメータ詳細

<div style="table-container">
<table>
|cnt|粒の個数を指定します。<br />特に制限はありませんが、多すぎると処理が重たくなります。スペックの低いマシンで動かして見て下さい。|
<td>pat_mode, pat_no_1, pat_no_2, pat_time</td><td>
パターンモード<br />
0 = 固定（pat_no_1 のみが使われます）<br />
1 = ループ（pat_no_1 ～ pat_no_2 の範囲でループします。ループタイムは pat_time で指定します。）<br />
2 = ランダム（pat_no_1 ～ pat_no_2 の範囲でランダムで表示します。）</td></tr>
|center_x, center_y|降り始めの中心を指定します。|
|appear_range|出現する範囲をパーセントで指定します。70 くらいがちょうどいいと思います。|
|move_time|1000 ピクセル動くのにかかる時間をﾐﾘ秒で指定します。マイナスを指定すると逆方向に動きます。|
|sin_time_x, sin_power_x|進行方向に垂直に揺れるのにかかる時間をﾐﾘ秒で、揺れ幅をピクセルで指定します。|
|sin_time_y, sin_power_y|進行方向に揺れるのにかかる時間をﾐﾘ秒で、揺れ幅をピクセルで指定します。|
|center_rotate|center_x, center_y で指定した中心を基準に回転します。1000px 進んだときの回転角を指定します。（3600=360°）|
|zoom_min, zoom_max|中心にいるときと、端にいるときの拡大率を指定します。（1000=当倍）|
|real_time|実時間フラグ（0=ゲーム時間、1=実時間）<br />実時間で再生すると、Ctrl キーなどで早送りできなくなります。デフォルトではゲーム時間で再生されます。|
</table>
</div>

++ RealLive とのパラメータの違い

<ul>
- pat_mode について、3（固定、２つ表示）がなくなりました。
- sin について、縦横が別々に指定できるようになりました。
- sin_power の計算式が変更されました。大きいほど揺れが大きくなります。（RealLive と逆）
- center_rotate が追加されました。
</ul>

++ 途中でパラメータを変更する

	途中で粒の量を変えたり、速度を変えたりする場合は、set_weather_param_type_B を続けて使って下さい。
	自然な感じでタイプが切り替わりますが、およそ３秒ほどかかります。
	実際に使って確認して下さい。

++ 色んな大きさの粒を同時に表示する

	複数のオブジェクトを使って重ねて下さい。
	雪などの効果を作る場合は、大きい粒ほど手前に表示し、個数を減らすと効果的です。

++ サンプル：見上げるような雪を降らす

<pre class="source">
// 背景を準備する
front.object[0].create(BG001, 1)

front.object[10].create_weather(snow, 1)
front.object[10].set_weather_param_type_B(
	cnt = 200,
	pat_mode = 0,
	pat_no_1 = 6,
	center_x = 300,
	center_y = 100,
	move_time = 5000,
	sin_time_x = 2000,
	sin_power_x = 20,
	zoom_min = 0,
	zoom_max = 1000
	)
</pre>














■ その他のオブジェクト

<h4>セーブサムネイルオブジェクトを作成する</h4>

<pre class="exp">
front.object[0].create_save_thumb($save_no)
front.object[0].create_save_thumb($save_no, $disp)
front.object[0].create_save_thumb($save_no, $disp, $x, $y)
</pre>

	セーブサムネイルオブジェクトを作成します。
	自動的にオブジェクトは初期化されます。
	詳細は [[セーブサムネイル]] を参照して下さい。


<div class="mada">

<h4>メッシュオブジェクト（３Ｄオブジェクト）を作成する</h4>

<pre class="exp">
front.object[0].create_mesh($file_name)
front.object[0].create_mesh($file_name, $disp)
front.object[0].create_mesh($file_name, $disp, $x, $y)
</pre>

	x ファイルを読み込み、メッシュオブジェクト（３Ｄオブジェクト）を作成します。
	自動的にオブジェクトは初期化されます。

<h4>ビルボードオブジェクトを作成する</h4>

<pre class="exp">
front.object[0].create_billboard($file_name)
front.object[0].create_billboard($file_name, $disp)
front.object[0].create_billboard($file_name, $disp, $x, $y)
</pre>

	画像ファイルを読み込み、ビルボードオブジェクトを作成します。
	自動的にオブジェクトは初期化されます。

<h5>ビルボードとは？</h5>

	２Ｄの画像を、３Ｄ空間に立たせる技術です。
	３Ｄを使わない場合は使いません。

</div> <!-- mada -->

<h4>オブジェクトのコピーを作成する</h4>

<pre class="exp">
front.object[0].create_copy_from($object)
</pre>

	オブジェクトをコピーします。

<h5>バックのオブジェクトをフロントにコピーする</h5>

<pre class="source">
front.object[0].create_copy_from(back.object[0])
</pre>

<h4>その他のオブジェクト</h4>

	RealLive にあったフィルタオブジェクトは削除されました。
	[[スクリーン]] や [[ステージ]] のパラメータで代用して下さい。


■ オブジェクトを重ねて読み込む

+ オブジェクトに画像を読み込む

	オブジェクトを重ねて読み込む機能です。

	<img src="lib01.png">
	<img src="lib02.png">

	上のように、立ち絵と顔差分を分けて作成し、重ねて表示することがよくあると思います。

<pre class="source">
front.object[0].create("bg003", 1)
front.object[1].create("bs2_mh01101", 1, 640, 200)
front.object[2].create("bs2_mh001_f", 1, 640, 200)
front.object[2].patno = 2
</pre>

	<img src="kasane01.png">

	普通に重ねるだけなら問題ありません。

	ところが、これを半透明で表示したいとします。

<pre class="source">
front.object[0].create("bg003", 1)
front.object[1].create("bs2_mh01101", 1, 640, 200)
front.object[2].create("bs2_mh001_f", 1, 640, 200)
front.object[2].patno = 2
front.object[1].tr = 128
front.object[2].tr = 128
</pre>

	<img src="kasane02.png">

	失敗例です。
	下地、差分それぞれを半透明にするので、下地の表情が透けてしまっています。

	これを防ぐには、「あらかじめ重ねた状態で読み込む」必要があります。

<pre class="source">
front.object[0].create("bg003", 1)
front.object[1].create("bs2_mh01101 | bs2_mh001_f(0, 0, 2)", 1, 640, 200)
front.object[1].tr = 128
</pre>

	<img src="kasane03.png">

	重ねて読み込んでから半透明にしました。

+ 使い方

	画像を重ねて読み込むには、"file1 | file2" のようにファイル名を続けて指定します。

<pre class="source">
front.object[0].create("bs2_mh01101 | bs2_mh001_f", 1, 0, 0)
</pre>

	文字列変数を使っている場合は以下のようになります。

<pre class="source">
s[0] = "bs2_mh01101"
s[1] = "bs2_mh001_f"
front.object[0].create(s[0] + "|" + s[1], 1, 0, 0)

// s[0] | s[1] としてしまう間違いが多いです。注意して下さい。
</pre>

	重ねる位置やパターン番号を指定することもできます。
	ファイル名の後ろに "(x, y, patno)" をつけます。

<pre class="source">
front.object[0].create("bs2_mh01101 | bs2_mh001_f(0, 0, 2)", 1, 0, 0)
</pre>

	こちらも、例えばパターン番号を変数にしている場合は以下のようになります。

<pre class="source">
s[0] = "bs2_mh01101"
s[1] = "bs2_mh001_f"
a[0] = 2
front.object[0].create(s[0] + "|" + s[1] + "(0, 0, " + math.tostr(a[0]) + ")", 1, 0, 0)
</pre>

	文字列をこのように使う例はあまりなかったので少し難しいですが、
	「"bs2_mh01101 | bs2_mh001_f(0, 0, 2)" のような文字列を作る」という感覚でやってみて下さい。


























■ オブジェクトパラメータ（基本）

<h4>オブジェクトを表示する／非表示にする</h4>

<pre class="exp">
front.object[0].disp = 1    // オブジェクトを表示する
front.object[0].disp = 0    // オブジェクトを非表示にする
</pre>

	表示状態を設定／取得します。0=表示しない、1=表示する

<h4>オブジェクトのパターン番号を設定／取得する</h4>

<pre class="exp">
front.object[0].patno = 0
</pre>

	パターン番号を設定／取得します。
	パターン番号は、g00 に含まれるカットデータの番号です。

<div class="mada">

<h4>ワールドを設定／取得する</h4>

<pre class="exp">
front.object[0].world = 0
</pre>

	所属するワールド番号を設定／取得します。
	３Ｄの演出に使用します。

</div>

<h4>レイヤーを設定／取得する</h4>

<pre class="exp">
front.object[0].layer = 0
</pre>

	レイヤー値を設定／取得します。値が大きいほど前面に表示されます。




■ オブジェクトパラメータ（座標関連）

+ 座標を設定／取得する

<pre class="exp">
front.object[0].x = 0
front.object[0].y = 0
front.object[0].z = 0
front.object[0].set_pos($x, $y)
front.object[0].set_pos($x, $y, $z)
</pre>

	表示座標を設定／取得します。２Ｄオブジェクトの場合、z は使いません。

+ 修正座標を設定／取得する

<pre class="exp">
front.object[0].x_rep
front.object[0].y_rep
front.object[0].z_rep
</pre>

	修正座標は「整数配列」です。
	詳しい使い方は [[整数配列]] を参照して下さい。

	修正座標を使うには、修正座標を確保する必要があります。

	修正座標のイベントを使うには注意が必要です。
	詳しくは [[オブジェクトイベント]] を参照して下さい。

<pre class="source">
front.object[0].x = 100            // Ｘを１００にする
front.object[0].x_rep.resize(2)    // 修正座標Ｘを２個確保する
front.object[0].x_rep[0] = 10      // 修正座標Ｘの０番を１０に設定
front.object[0].x_rep[1] = 20      // 修正座標Ｘの１番を２０に設定

disp     // 100+10+20 = 130 の位置にオブジェクトが表示される
</pre>

+ 中心座標を設定／取得する

<pre class="exp">
front.object[0].center_x = 0
front.object[0].center_y = 0
front.object[0].center_z = 0
front.object[0].set_center($x, $y)
front.object[0].set_center($x, $y, $z)
</pre>

	中心座標を設定／取得します。
	RealLive の「中心修正座標」に当たります。
	２Ｄオブジェクトの場合、z は使いません。

	通常はこの値を変更することはないと思います。
	なぜなら g00 画像の場合、G00Pack.exe で画像を作成する時点で中心座標を設定できるからです。
	詳しくは G00Pack.exe のマニュアルを参照して下さい。

	中心座標は、画像の中心をあらわします。
	例えば中心が (100, 100) で位置が (20, 20) の場合、
	画像の (100, 100) が画面の (20, 20) に来るように表示されます。
	結果、左上に 80 ほど動いた位置に表示されることになります。

	中心座標は拡縮や回転の中心にもなります。
	通常、画像を回転させると、画像の左上を基準に回転すると思います。
	中心座標を設定すると、その中心を基準に回転するようになります。

	似たパラメータとして「中心補正座標」があります。そちらも参照して下さい。

+ 中心補正座標を設定／取得する

<pre class="exp">
front.object[0].center_rep_x = 0
front.object[0].center_rep_y = 0
front.object[0].center_rep_z = 0
front.object[0].set_center_rep($x, $y)
front.object[0].set_center_rep($x, $y, $z)
</pre>

	拡縮、回転の中心を設定／取得します。
	２Ｄオブジェクトの場合、z は使いません。

	「中心補正座標」は「中心座標」と違い、位置は動きません。
	位置はそのままで、拡縮や回転の基準位置のみ変えたい場合に使って下さい。

+ 拡大／縮小する

<pre class="exp">
front.object[0].scale_x = 1000
front.object[0].scale_y = 1000
front.object[0].scale_z = 1000
front.object[0].set_scale($x, $y)
front.object[0].set_scale($x, $y, $z)
</pre>

	オブジェクトを拡縮します。（1000=等倍、2000=２倍、500=半分）
	２Ｄオブジェクトの場合、z は使いません。

+ 左右／上下に反転させる

	専用パラメータはありません。
	scale にマイナスを指定することで、上下左右に反転できます。

<pre class="source">
front.object[0].scale_x = -1000   // 左右に反転させる
</pre>


+ 回転する

<pre class="exp">
front.object[0].rotate_x = 0
front.object[0].rotate_y = 0
front.object[0].rotate_z = 0
front.object[0].set_rotate($x, $y)
front.object[0].set_rotate($x, $y, $z)
</pre>

	時計回りに回転を行います。（10 = 1°、3600 = 360°）
	２Ｄオブジェクトを回転させる場合は、rotate_z を使います。


■オブジェクトパラメータ（色関連）

<h4>不透明度を設定／取得する</h4>

<pre class="exp">
front.object[0].tr = 255
</pre>

	不透明度を 0～255 の範囲で設定／取得します。
	0 にすると完全な透明になります。

<h4>修正不透明度を設定／取得する</h4>

<pre class="exp">
front.object[0].tr_rep
</pre>

	修正不透明度は「整数配列」です。
	詳しい使い方は [[整数配列]] を参照して下さい。

	修正不透明度を使うには、修正不透明度を確保する必要があります。

	修正不透明度のイベントを使うには注意が必要です。
	詳しくは [[オブジェクトイベント]] を参照して下さい。

	修正不透明度は、255 を 100% として掛け算されます。
	例えば、tr = 128（50%）は半透明です。
	tr_rep[0] = 128、tr_rep[1] = 128 にすると、50% × 50% = 25%（半分の半分）の透明度になります。

	つまり、１つでも値が 0 なら、他が全て 255 でも完全な透明になってしまいます。
	注意して下さい。

<pre class="source">
front.object[0].tr_rep.resize(2)    // 修正不透明度を２個確保する
front.object[0].tr_rep[0] = 128     // 修正不透明度の０番を１２８に設定
front.object[0].tr_rep[1] = 64      // 修正不透明度の１番を６４に設定

disp     // 50% * 25% = 12.5% の透明度になる
</pre>

<h4>モノクロ度を設定／取得する</h4>

<pre class="exp">
front.object[0].mono = 0
</pre>

	モノクロ度を 0～255 の範囲で設定します。
	255 にすると完全なモノクロになります。

<h4>反転度を設定／取得する</h4>

<pre class="exp">
front.object[0].reverse = 0
</pre>

	色合いの反転度を 0～255 の範囲で設定します。
	255 にすると完全に反転します。128 にすると、完全にグレーになってしまいます。

<h4>明るさを設定／取得する</h4>

<pre class="exp">
front.object[0].bright = 0
front.object[0].dark = 0
</pre>

	明度／暗度を 0～255 の範囲で設定します。
	明度を 255 にすると真っ白になります。暗度を 255 にすると真っ黒になります。

<h4>色を設定／取得する</h4>

<pre class="exp">
front.object[0].color_r = 0
front.object[0].color_g = 0
front.object[0].color_b = 0
front.object[0].color_rate = 0
</pre>

	color_r, color_g, color_b で指定した色に変化させます。
	color_rate=0 で変化なし、color_rate=255 で完全にその色になります。

<h4>色味を設定／取得する</h4>

<pre class="exp">
front.object[0].color_add_r = 0
front.object[0].color_add_g = 0
front.object[0].color_add_b = 0
</pre>

	画像の r, g, b 値に、指定した値を加算します。
	赤っぽくする、青っぽくする、などの演出に使います。

<h4>合成方法を指定する</h4>

<pre class="exp">
front.object[0].blend = 0
</pre>

	合成方法を指定します。
	加算合成を使うと、光のような効果を与えれます。炎の演出などに使って下さい。

<div class="table-container">
<table>
|値|合成方法|
|0|通常|
|1|加算合成|
|2|減算合成|
|3|乗算合成|
</table>
</div>


■ 表示矩形と使用矩形

<div class="chips">
オブジェクトに表示矩形／使用矩形を設定した場合、ボタンの当たり判定も表示矩形内に収まるようになりました。（2012/3/13 Ver.1.0.13.7 より）
</div>

+ 画面上での表示矩形を設定する

<pre class="exp">
front.object[0].clip_use = 0
front.object[0].clip_left = 0
front.object[0].clip_top = 0
front.object[0].clip_right = 0
front.object[0].clip_bottom = 0
front.object[0].set_clip($use, $left, $top, $right, $bottom)
</pre>

	指定された矩形の中のみにオブジェクトを表示します。
	オブジェクト自身の範囲ではありません。画面上の範囲で指定します。
	例えば left = 320, top = 180, right = 960, bottom = 540 とした場合、
	画面上の (320, 180) - (960, 540) の範囲にのみオブジェクトが表示されます。

<div class="table-container">
<table>
|clip_use|1=表示矩形を使う、0=使わない|
|clip_left|left（左端）|
|clip_top|top（上端）|
|clip_right|right（右端）|
|clip_bottom|bottom（下端）|
</table>
</div>

++ 注意１

	右端と下端の値に注意して下さい。
	例えば 800×600 の画面全体に表示する場合、RealLive では (0,0,799,599) と指定していました。
	Siglus では (0,0,800,600) と指定する必要があります。１ピクセルずれているので注意して下さい。

++ 注意２

	RealLive と違い、左端と右端、もしくは上端と下端が入れ替わった場合、何も表示されなくなります。

+ オブジェクト自体の使用矩形を設定する

<pre class="exp">
front.object[0].src_clip_use = 0
front.object[0].src_clip_left = 0
front.object[0].src_clip_top = 0
front.object[0].src_clip_right = 0
front.object[0].src_clip_bottom = 0
front.object[0].set_src_clip($use, $left, $top, $right, $bottom)
</pre>

	clip と違い、オブジェクト自体の使用矩形を設定します。

	例えば下の 200×200 の画像の場合、中央部分（6 7 10 11）を表示するには、次のように指定します。

	<b>left = 50, top = 50, right = 150, bottom = 150</b>

<div class="table-container">
<table>
<tr>
<td style="border: none;"><img src="clip_00.png" /></td>
<td style="border: none; vertical-align: middle;">→</td>
<td style="border: none;"><img src="clip_03.png" /></td>
</tr>
</table>
</div>

	下のように、使用矩形を設定したまま拡縮、回転させることもできます。

<div class="table-container">
<table>
<tr>
<td style="border: none;"><img src="clip_03.png" /></td>
<td style="border: none; vertical-align: middle;">→</td>
<td style="border: none;"><img src="clip_05.png" /></td>
</tr>
</table>
</div>

++ 中心座標について

	中心座標が設定されている場合、使用矩形もそれに合わせて設定する必要があります。

	上の例で、(100,100) に中心座標が設定されている場合、次のように指定しなければいけません。

	<b>left = -50, top = -50, right = 50, bottom = 50</b>

++ 拡大時の端の色について

	<font color="red">使用矩形をカット番号のように使ってはいけません。</font>

	使用矩形を設定した画像を拡大したとき、端部分に、矩形外の色がはみでることがあります。詳しくは下の図を参照して下さい。
	これは DirectX の仕様となります。カット番号のように使ってしまうと、他のカットの色がはみ出てしまいます。

	これを理解した上で、端に色を置かないように画像を作れば、カット番号のように使うこともできます。ただし、お勧めはしません。

<div class="table-container">
<table>
<tr>
<td><img src="clip_00.png" /></td>
<td><img src="clip_03.png" /></td>
<td><img src="clip_01.png" /></td>
<td><img src="clip_02.png" /></td>
</tr>
<tr>
<td>元画像です。サイズは 200×200 です。</td>
<td>使用矩形を中央 100×100 に限定しました。</td>
<td>scale_x = 2000, scale_y = 2000 とし、２倍に拡大しました。</td>
<td>端に、矩形外の色がはみ出ているのが分かると思います。</td>
</tr>
</table>
</div>





■ オブジェクトパラメータ（特殊）

+ 使い方のヒントを設定／クリアする（高速化）

<pre class="exp">
front.object[0].clear_hints()            // ヒントを初期化する
front.object[0].add_hints(no_event = 0)  // ヒントを追加する
</pre>

	「このオブジェクトはこんな風に使います」ということを予め教えておくことで、処理を高速化します。

	通常は使う必要ありません。
	ミニゲームなど、オブジェクトが千個単位で存在するような場合に、適切に設定して下さい。

	<div class="chips">ヒントは子供オブジェクトにも影響するので、親に設定するのが手軽です。</div>

++ パラメータイベントを使わない

<pre class="source">
front.object[0].add_hints(no_event = 1)
</pre>

	オブジェクトのイベントを使わないことを教えます。
	このパラメータを設定した場合、各種パラメータイベントが使用できなくなります。

	オブジェクトは、存在するだけで、「各種パラメータイベントが設定されていないか」の判定を常に行います。
	その処理をスキップすることで、処理を高速化します。


■ オブジェクトの情報を設定／取得する

+ オブジェクトが存在するかを判定する

<pre class="exp">
a[0] = front.object[0].exist_type             // オブジェクトが存在するかを判定する
</pre>

	オブジェクトが存在するかを判定します。

	create、create_string など、"create～" で始まるコマンドでオブジェクトを作成した場合、
	オブジェクトが存在することになります。

	子供を持っていても、オブジェクトが存在することにはなりません。
	front.object[0].child.get_size などを合わせて利用して下さい。

<pre class="source">
	front.object[0].init
	front.object[0].create("unit00", 1, 100, 100)
	a[0] = front.object[0].exist_type

	print(a[0])r

	front.object[0].init
	front.object[0].child.resize(10)
	a[0] = front.object[0].exist_type

	print(a[0])r
</pre>

<pre class="result">
1
0
</pre>


+ オブジェクトの個数を取得／設定する

<pre class="exp">
front.object.resize($cnt)             // オブジェクトの個数を変更する（動きません！）
a[0] = front.object.get_size($cnt)    // オブジェクトの個数を取得する
</pre>

	<font color="red"><b>オブジェクトの個数は変更できません。</b></font>
	なぜ変更するコマンドがあるかと言いますと、子供オブジェクトのためです。
	（子供オブジェクトの個数は変更できます。）

++ 子供オブジェクトの個数を変更する

<pre class="source">
	front.object[0].child.resize(100)    // オブジェクト０番に子供オブジェクトを 100 個作る
</pre>

+ オブジェクトに読み込んだファイル名を取得する

<pre class="exp">
s[0] = front.object[0].get_file_name
</pre>

	オブジェクトに読み込んだファイル名を取得します。

+ オブジェクトに読み込んだファイルを変更する

<pre class="exp">
front.object[0].change_file($file_name)
</pre>

	オブジェクトに読み込んだファイルを変更します。

+ オブジェクトのサイズを取得する

<pre class="exp">
a[0] = front.object[0].get_size_x
a[0] = front.object[0].get_size_x($cut_no)
a[0] = front.object[0].get_size_y
a[0] = front.object[0].get_size_y($cut_no)
a[0] = front.object[0].get_size_z
a[0] = front.object[0].get_size_z($cut_no)
</pre>

	オブジェクトに読み込んだ画像の大きさを取得します。
	画像自体の大きさなので、拡縮などを行っても値は変わりません。

+ オブジェクトのピクセルの色を取得する

<pre class="exp">
a[0] = front.object[0].get_pixel_color_r($x, $y)
a[0] = front.object[0].get_pixel_color_r($x, $y, $cut_no)
a[0] = front.object[0].get_pixel_color_g($x, $y)
a[0] = front.object[0].get_pixel_color_g($x, $y, $cut_no)
a[0] = front.object[0].get_pixel_color_b($x, $y)
a[0] = front.object[0].get_pixel_color_b($x, $y, $cut_no)
a[0] = front.object[0].get_pixel_color_a($x, $y)
a[0] = front.object[0].get_pixel_color_a($x, $y, $cut_no)
</pre>

	オブジェクトに読み込んだ画像のピクセルの色を取得します。

+ オブジェクトのパターン数を取得する

<pre class="exp">
a[0] = front.object[0].get_pat_cnt
</pre>

	オブジェクトに読み込んだ画像のパターン数を取得します。

<ul>
- 単純な画像オブジェクトにのみ有効です。
- 矩形オブジェクトや環境オブジェクトその他には対応していません。現状では 0 を返しますが、今後変更されるかも知れません。
- 初期状態（画像を読み込んでいない場合）では 0 を返します。
</ul>













■ オブジェクトボタン

	オブジェクトをボタンにすることができます。

<h4>オブジェクトをボタンにする／解除する</h4>

<pre class="exp">
front.object[0].set_button($button_no)
front.object[0].set_button($button_no, $group_no)
front.object[0].set_button($button_no, $group_no, $action_no, $se_no)
front.object[0].clear_button
</pre>

<div class="table-container">
<table>
|$button_no|ボタン番号。|
|$group_no|選択肢のグループ番号を指定します。省略するとグループ０番が使われます。|
|$action_no|Gameexe.ini で作成したボタンアクションの番号を指定します。省略すると０番が使われます。|
|$se_no|Gameexe.ini で作成したボタン効果音の番号を指定します。省略すると０番が使われます。|
</table>
</div>

	オブジェクトにボタン属性を持たせます。
	詳細は [[オブジェクトボタングループ]] を参照して下さい。

<h4>ボタンコールを指定する／解除する</h4>

<pre class="exp">
front.object[0].set_button_call($cmd_name)
front.object[0].clear_button_call
</pre>

	ボタンを押したときに呼ばれるコマンドを指定します。

<h4>ボタンの状態を取得／設定する</h4>

<pre class="exp">
front.object[0].set_button_state_normal    // ボタンの状態を「通常」にする
front.object[0].set_button_state_select    // ボタンの状態を「選択されている」にする
front.object[0].set_button_state_disable   // ボタンの状態を「無効」にする
a[0] = front.object[0].get_button_state        // ボタンの状態を取得する
a[0] = front.object[0].get_button_real_state   // ボタンの実際の状態を取得する
a[0] = front.object[0].get_button_hit_state    // ボタンの当たり状態を取得する
</pre>

++ ボタンの状態について

<ul>
- normal 状態：マウスを当てると hit （当たっている）状態に、マウスを押すと push （押している）状態になります。
- select 状態：マウスを当てても状態は変更されません。
- disable 状態：マウスを当てても状態は変更されません。
</ul>

	Gameexe.ini の [[ボタンアクションの設定]] では、
	normal / hit / push / select / disable の５つの状態について動きを設定できます。

++ get_button_state

	set_button_state でボタンに与えた状態を取得します。

<div class="table-container">
<table>
|値|状態|
|0|normal|
|1|select（選択されている）|
|2|disable（無効）|
</table>
</div>

++ get_button_real_state

	normal（通常）状態のボタンは、
	マウスを当てると hit （当たっている）状態に、マウスを押すと push （押している）状態になります。
	それらを含んだ最終的な値を取得したい場合は、get_button_real_state を使って下さい。

<div class="table-container">
<table>
|値|状態|
|0|normal|
|1|hit（当たっている）|
|2|push（押している）|
|3|select（選択されている）|
|4|disable（無効）|
</table>
</div>

++ get_button_hit_state

	button_state が select や disable であった場合、マウスを当てても状態は変更されません。
	ところが、disable であってもマウスが当たっている情報を取得したい場合があります。
	その場合は get_button_hit_state を使って下さい。

<div class="table-container">
<table>
|値|状態|
|0|normal|
|1|hit（当たっている）|
|2|push（押している）|
</table>
</div>





■ オブジェクトボタン（当たり判定）

+ 透明な部分は当たらないようにする

	画像のうち、透明な部分を当たり判定から除き、画像の見た目通りの当たり判定にします。

<pre class="exp">
front.object[0].set_button_alpha_test(1)       // 機能を有効にする
front.object[0].set_button_alpha_test(0)       // 機能を解除する
a[0] = front.object[0].get_button_alpha_test   // 値を取得する
</pre>



■ オブジェクトボタン（プッシュキープ）

+ プッシュキープ属性

	通常のボタンは、押したままマウスを外に出すと、押されていない状態になります。
	そのままマウスのボタンを放しても決定状態にはなりません。

	スライドバーのつまみなどのボタンは、マウスを外に出しても押した状態をキープして欲しいと思います。
	これをボタンのプッシュキープ属性と言います。

+ ボタンにプッシュキープ属性を与える

<pre class="exp">
front.object[0].set_button_pushkeep(1)       // プッシュキープ属性を与える
front.object[0].set_button_pushkeep(0)       // プッシュキープ属性を解除する
a[0] = front.object[0].get_button_pushkeep   // プッシュキープ属性を取得する
</pre>



■ オブジェクトトーンカーブ

	オブジェクトにトーンカーブを設定できます。
	詳しくは [[トーンカーブ]] を参照して下さい。

+ トーンカーブ番号を指定する

<pre class="exp">
// オブジェクトのトーンカーブを０番に設定する
front.object[0].tonecurve_no = 0

// オブジェクトのトーンカーブを初期化する
front.object[0].tonecurve_no = -1
</pre>


■ オブジェクトマスク

	オブジェクトにマスクを設定できます。
	詳しくは [[マスクについて]] を参照して下さい。

+ マスク番号を指定する

<pre class="exp">
// オブジェクトのマスクを０番に設定する
front.object[0].mask_no = 0

// オブジェクトのマスクを初期化する
front.object[0].mask_no = -1
</pre>



■オブジェクトイベント

<h4>オブジェクトイベント</h4>

	処理時間を指定できるパラメータ設定命令です。
	たとえば「オブジェクトの座標をＡ地点からＢ地点へ１秒間で移動する」と言う事が簡単にできます。

<pre class="exp">
front.object[0].patno_eve
front.object[0].x_eve
front.object[0].y_eve
front.object[0].z_eve
front.object[0].x_rep_eve
front.object[0].y_rep_eve
front.object[0].z_rep_eve
front.object[0].center_x_eve
front.object[0].center_y_eve
front.object[0].center_z_eve
front.object[0].center_rep_x_eve
front.object[0].center_rep_y_eve
front.object[0].center_rep_z_eve
front.object[0].scale_x_eve
front.object[0].scale_y_eve
front.object[0].scale_z_eve
front.object[0].rotate_x_eve
front.object[0].rotate_y_eve
front.object[0].rotate_z_eve
front.object[0].clip_left_eve
front.object[0].clip_top_eve
front.object[0].clip_right_eve
front.object[0].clip_bottom_eve
front.object[0].src_clip_left_eve
front.object[0].src_clip_top_eve
front.object[0].src_clip_right_eve
front.object[0].src_clip_bottom_eve
front.object[0].tr_eve
front.object[0].tr_rep_eve
front.object[0].mono_eve
front.object[0].reverse_eve
front.object[0].bright_eve
front.object[0].dark_eve
front.object[0].color_r_eve
front.object[0].color_g_eve
front.object[0].color_b_eve
front.object[0].color_rate_eve
front.object[0].color_add_r_eve
front.object[0].color_add_g_eve
front.object[0].color_add_b_eve
</pre>

	※RealLive にあった OBJFRONTEVE_DISP（表示イベント）はありません。

	詳しくは [[イベント]] を参照ください。

<h5>１秒かけてオブジェクトを移動させる</h5>

<pre class="source">
// オブジェクトを(100,100)に表示
front.object[0].create("UNIT00", 1, 100, 100)

オブジェクトを移動します。r

// object[0] のＸ座標を300に、1000ﾐﾘ秒かけて、遅延時間0、速度変化0 = 等速　で移動
front.object[0].x_eve.set(300, 1000, 0, 0)

// object[0] のＹ座標を500に、1000ﾐﾘ秒かけて、遅延時間500ﾐﾘ秒、速度変化0 = 等速　で移動
front.object[0].y_eve.set(500, 1000, 500, 0)

// 上記２つの動作自体は同時に開始されますが、Ｙ方向の移動に500ﾐﾘ秒の遅延指定がさ
//　Ｘ方向の移動が 500ﾐﾘ秒先に終了します。
//　最終的に object[0] は (300, 500) の位置に移動します。</span>

// Ｙ座標の移動が終了するまで待つ
front.object[0].y_eve.wait

オブジェクトを移動しました。r
</pre>

<h4>修正座標のイベント</h4>

	修正座標を確保すると、修正座標イベントも確保されます。

<pre class="source">
// object[0] の修正座標を１０個確保する
front.object[0].x_rep.resize(10)

// 上の行と、↓この行は全く同じです。
front.object[0].x_rep_eve.resize(10)

// object[0] の修正座標Ｘの０番を100に、1000ﾐﾘ秒かけて、遅延時間0、速度変化0 = 等速　で移動
front.object[0].x_rep_eve[0].set(100, 1000, 0, 0)

// object[0] の修正座標Ｘの１番を-300に、2000ﾐﾘ秒かけて、遅延時間0、速度変化1 = 加速　で移動
front.object[0].x_rep_eve[1].set(-300, 2000, 0, 1)
</pre>

<h4>オブジェクト全体イベント</h4>

<pre class="exp">
front.object[0].all_eve
</pre>

	全てのオブジェクトをまとめて停止したりするときに使います。
	詳しくは [[イベントの一括操作]] を参照して下さい。



■ オブジェクトフレームアクション

<pre class="exp">
front.object[0].frame_action        // 汎用チャンネル
front.object[0].frame_action_ch     // 専用チャンネル
</pre>

	オブジェクトごとのフレームアクションです。

	詳細は、[[オブジェクトのフレームアクション]] を参照して下さい。




■オブジェクト g00 アニメ（gan）

	gan データを使って、オブジェクトに gan を設定できます。

+ gan データを作成する

	gan データは G00anm_edit.exe で作成できます。
	詳しくは G00anm_edit.exe のマニュアルを参照して下さい。
	できた gan データは、gan フォルダに入れて下さい。

<pre class="source">
SampleGame
  +- exe
  |   +- <font color="red">gan</font>
  |      +- <font color="red">sample00.gan</font>
  |   +- SiglusEngine.exe
  |
  +- SiglusCompiler.exe
</pre>

<h4>gan ファイルを設定する</h4>

<pre class="exp">
front.object[0].load_gan($file_name)
</pre>

	オブジェクトに gan を設定します。

<h4>gan を開始する</h4>

<pre class="exp">
front.object[0].start_gan($set_no, $loop)
</pre>

	gan をスタートします。

<ul>
- $set_no : gan ファイル内で作成したセット番号を指定します。
- $loop : 0=ループしない（ワンショット）、1=ループする
</ul>


■ ムービーオブジェクトについて

	オブジェクトで omv 形式のムービーを再生できます。

+ omv ムービーについて

	OMVPack.exe を使って作ることができます。
	詳しくは OMVPack.txt のマニュアルを参照して下さい。

	他のムービーと同様、[ mov ] フォルダに入れて下さい。

<pre class="source">
SampleGame
  +- exe
  |   +- <font color="red">mov</font>
  |      +- <font color="red">sample00.omv</font>
  |   +- SiglusEngine.exe
  |
  +- SiglusCompiler.exe
</pre>

<div class="chips">
2011/8/25 Ver.1.0.9.8 より、透過度なし（RGB）のムービーも扱えるようになりました。
透過が必要ない場合、こちらの方が動作が速いです。
</div>

++ 注意点

<s>

	1280×720 などの高解像度のゲームで、フルサイズのムービーを扱う場合、
	または複数のムービーを同時に再生する場合、ある程度のＶＲＡＭが必要となります。
	ゲームの必要スペックを１段階あげて下さい。

<ul>
- ＶＲＡＭ：必要64MB　推奨128MB<br />↓
- ＶＲＡＭ：必要128MB　推奨256MB
</ul>

	小さいムービーを拡大して使う場合（例：640×360 のムービーを、scale を2000（２倍）に拡大して使う）、
	ＶＲＡＭは 640×360 分しか必要ありませんので、スペックをあげる必要はありません。

</s>

<div class="chips">
2011/06/01 ムービーに関係なく、必要スペックが「ＶＲＡＭ：必要128MB　推奨256MB」になりました。
</div>

++ omv の長所

<ul>
- 透過度を持つムービーに対応している（透過度なしも扱えるようになりました。2011/8/25）
- オブジェクトに読み込むことができるため、オブジェクトに対する操作（拡縮回転、透過、加算、色変化、ワイプなど）を全て行うことができる
- ムービーの上に他のオブジェクトやメッセージウィンドウなどを乗せることもできる
- ループ再生ができる
- 独自に再生するため、環境に依存しない
</ul>

++ omv の短所

<ul>
- 既存の形式に比べて処理が重い
- 音声を再生できない
</ul>

++ omv の使いどころ

	魔法などのエフェクトに使えると思います。
	RealLive では gan やシリアル pdt でやっていたと思いますが、
	ムービーが作れるならこちらの方が圧倒的に楽です。

	ＯＰムービーなどには適していません。（重い、音が再生できない）





■ ムービーオブジェクトを作成する

<pre class="exp">
front.object[0].create_movie($file)
front.object[0].create_movie($file, $disp)
front.object[0].create_movie($file, $disp, $x, $y)

front.object[0].create_movie_loop($file)
front.object[0].create_movie_loop($file, $disp)
front.object[0].create_movie_loop($file, $disp, $x, $y)

// 名前つき引数
{auto_free, real_time, ready_only}
</pre>

++ 引数

<div class="table-container">
<table>
|file|omv のファイル名|
|disp|表示フラグ（0=表示しない、1=表示する）|
|x, y|x 座標、y 座標|
|real_time|実時間フラグ（0=ゲーム時間、1=実時間）<br />実時間で再生すると、Ctrl キーなどで早送りできなくなります。デフォルトでは実時間で再生されます。|
|auto_free|自動解放フラグ（0=自動解放しない、1=自動解放する）<br />自動解放する場合、ムービーが終わると自動的にオブジェクトが解放されます。自動解放しない場合は、最後のフレームが表示され続けます。デフォルトでは自動解放されます。|
|ready_only|準備フラグ（0=普通に再生する、1=準備のみ行う）|
</table>
</div>

++ 名前つき引数の使い方の例

++ ムービーをゲーム時間で再生する

<pre class="source">
front.object[0].create_movie(mov00, 1, 0, 0, <font color="red">real_time = 0</font>)
</pre>

++ ムービーを再生する、自動解放しない

<pre class="source">
front.object[0].create_movie(mov00, 1, 0, 0, <font color="red">auto_free = 0</font>)
</pre>

	ready_only については、[[ムービーオブジェクトを準備する（再生遅延を抑える）]] を参照して下さい。

+ サンプル：ムービーオブジェクトを再生する

<pre class="source">
// 背景を表示します。
front.object[0].create(BG001, 1, 0, 0)

// バストショットを表示します。
front.object[1].create(BS0101, 1, 0, 0)

// ムービーその１を表示します。
// create_movie_loop を使い、ループ再生します。
front.object[2].create_movie_loop(w_cutter01, 1, 320, 120)

// その上にムービーその２を表示します。
// create_movie_loop を使い、ループ再生します。
front.object[3].create_movie_loop(m_light01, 1, 320, 120)

// ムービーその２は加算合成を行います。
front.object[3].blend = 1
</pre>



■ ムービーオブジェクトを操作する

+ ムービーを一時停止する

<pre class="exp">
front.object[0].pause_movie
</pre>

+ ムービーの一時停止を解除する

<pre class="exp">
front.object[0].resume_movie
</pre>

+ ムービーの再生位置を設定する

<pre class="exp">
front.object[0].seek_movie($time)
</pre>

	ムービの再生位置をﾐﾘ秒で設定します。途中から始めたりしたい場合に使って下さい。

+ ムービーの再生位置を取得する

<pre class="exp">
a[0] = front.object[0].get_movie_seek_time
</pre>

	ムービーの再生位置をﾐﾘ秒で取得します。

+ ムービーが再生中かを判定する

<pre class="exp">
a[0] = front.object[0].check_movie
</pre>

	0=再生中でない、1=再生中

+ ムービーの再生終了を待つ

<pre class="exp">
front.object[0].wait_movie
a[0] = front.object[0].wait_movie_key
</pre>

	wait_movie_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

+ ムービーのループを終了させる

<pre class="exp">
front.object[0].end_movie_loop
</pre>

	ムービーのループを終了します。
	次にムービーが最後まで来たときに解放されます。

+ ムービーの自動解放フラグを設定する

<pre class="exp">
front.object[0].set_movie_auto_free($flag)   // 0=自動解放しない、1=自動解放する
</pre>

	ムービーが最後まで来た場合、自動解放するかどうかを設定します。
	自動解放しない場合、最後のフレームが表示されたままになります。

	ループ再生の場合は、このフラグは無視されます。










■ ムービーオブジェクトを準備する（再生遅延を抑える）

	上級者向けのコマンドです。

	ムービーをあらかじめ準備しておくことで、再生遅延を少なくすることができます。
	画面演出と合わせるなど、１フレームのずれを気にする場合に使って下さい。

+ ムービーオブジェクトを準備する

	準備専用のコマンドはありません。
	create コマンドに名前つき引数 ready_only を設定することで、準備ができます。

++ ムービーオブジェクトを準備する

<pre class="source">
front.object[0].create_movie(mov00, 1, 0, 0, <font color="red">ready_only = 1</font>)
</pre>

++ 注意

	ムービーオブジェクトは、準備しただけでも１フレーム目が表示されてしまいます。
	表示したくない場合は、disp = 0 を設定して下さい。

+ 準備したムービーオブジェクトを再生する

	準備した状態は、「再生してすぐに一時停止した状態」になります。
	なので、一時停止を解除する resume_movie コマンドで再生できます。

++ ムービーオブジェクトを準備し、再生する

<pre class="source">
// ムービーオブジェクトを準備する（まだ表示しない）
front.object[0].create_movie(mov00, 0, 0, 0, <font color="red">ready_only = 1</font>)
ムービーオブジェクトを準備しました。クリックで再生します。r close

// 準備したムービーオブジェクトを表示し、再生する
front.object[0].disp = 1
front.object[0].<font color="red">resume_movie</font>
</pre>







■ 汎用フラグ

+ 汎用フラグ

<pre class="exp">
front.object[0].f
</pre>

	汎用フラグです。自由に使って下さい。

	汎用フラグを使うには、汎用フラグを確保する必要があります。
	詳しくは [[整数配列]] を参照して下さい。

+ 汎用フラグを使った例

<pre class="source">
front.object[0].f.resize(10)  // オブジェクト０番の汎用フラグを１０個確保する
front.object[0].f[5] = 30     // オブジェクト０番の汎用フラグ５番に３０を代入する
</pre>




■ 子供オブジェクト

	オブジェクトに子供を作ることができます。

	子供オブジェクトは、親のパラメータを引き継いで動きます。
	例えば親の座標を動かすと、子供もそれに連れて動きます。

	子供オブジェクトは object 型です。
	つまり、通常のオブジェクトと同じように使うことができます。

<h5>RealLive との違い</h5>

	RealLive では、子供を持てるのは「子持ちオブジェクト」だけでした。
	Siglus では、例えば文字オブジェクトが子供を持つこともできます。
	また、子供オブジェクトもセーブ／ロードの対象になります。

<h4>子供オブジェクトを作る</h4>

<pre class="exp">
front.object[0].child.resize($child_cnt)
</pre>

	<font color="red"><b>
	親オブジェクトは別に初期化する必要があることに注意してください。
	親が必要ない場合は以下のように作成してください。
	</b></font>

<pre class="source">
front.object[0].init               // オブジェクト０番を初期化します。（必須！）
front.object[0].disp = 1           // オブジェクト０番を表示します。（これを忘れると子供も表示されません！）
front.object[0].child.resize(10)   // オブジェクト０番に子供を１０個作成します。
</pre>

<h4>子供オブジェクトを使う</h4>

	子供オブジェクトは、通常のオブジェクトと同じように使うことが出来ます。

<pre class="source">
front.object[0].child[0].create(BG001, 1, 0, 0)       // 子供オブジェクトに画像を読み込む
front.object[0].child[0].tr = 128                     // 子供オブジェクトの不透明度を設定する
front.object[0].child[0].child.resize(10)             // 子供オブジェクトに子供を作る（孫！）
</pre>

<h4>パラメータの引継ぎ</h4>

	子供オブジェクトは、親のパラメータを引き継ぎます。
	<br />例：親のＸ座標が 100、子のＸ座標が 200 のとき、子は合計で 300 の位置に表示されます。
	<br />例：親の不透明度が 128、子の不透明度が 128 のとき、子は合計で 64 の不透明度で表示されます。

<h5>親に影響されるパラメータ</h5>

	表示フラグ、ワイプコピーフラグ、ワイプ消去フラグ、表示順位、表示位置、表示矩形、不透明度、モノクロ度、反転度、明度、暗度、色加算、合成方法

<h5>影響されないパラメータ</h5>

	パターン番号、ワールド

<h5>未実装</h5>

	中心座標、拡縮、回転、色変化




■ ワイプコピー

<pre class="exp">
front.object[0].wipe_copy = 0        // ワイプコピーフラグ
front.object[0].wipe_erase = 0       // ワイプ消滅フラグ
</pre>

<h4>ワイプコピー／ワイプ消滅フラグ（特定のオブジェクトをワイプさせない）</h4>

	ワイプ時に、フロントを自動的にバックにコピーする機能です。
	「特定のオブジェクトをワイプさせない」ことができます。
	非常に便利な機能です。

	フロントのワイプコピーフラグがオンになっていると、そのオブジェクトは wipe コマンドでワイプされません。
	ただし、以下の条件のどれかに該当した場合、ワイプされます。

<ul>
- フロントのワイプコピーをオフにした
- バックのオブジェクトに画像が読み込まれた
- バックのオブジェクトのワイプ消滅フラグをオンにした
</ul>

	ワイプされると、ワイプコピーフラグはオフに戻ります。

<h5>ワイプコピーフラグを使わない場合</h5>

<pre class="source">
// オブジェクト０番に背景を読み込んでいます。
back.object[0].create(BG001, 1)

// ワイプします。
wipe(0)

// オブジェクト０番に背景を読み込んでいます。
// オブジェクト１番にバストショットを読み込んでいます。
back.object[0].create(BG001, 1)
back.object[1].create(BST001, 1)

// ワイプします。
wipe(0)
</pre>

	このように、ワイプするたびに画像を全て読み直す必要がありました。

<h5>ワイプコピーフラグを使う場合</h5>

<pre class="source">
// オブジェクト０番に背景Ａを読み込んでいます。
// ワイプコピーフラグを立てています。
back.object[0].create(BG001, 1)
back.object[0].wipe_copy = 1

// ワイプします。フロントオブジェクト０番のワイプコピーがオンになります。
wipe(0)

// オブジェクト１番にバストショットを読み込んでいます。
back.object[1].create(BST001, 1)

// ワイプします。
// 背景はワイプコピーがオンなので、ワイプされません！
// つまり、背景が残ったまま、バストショットだけがワイプされます。
wipe(0)

// オブジェクト０番に背景Ｂを読み込んでいます。
back.object[0].create(BST002, 1)
back.object[0].wipe_copy = 1

// ワイプします。
// オブジェクトに画像が読み込まれたのでワイプされます！
// ワイプコピーフラグをオンにしなおさないといけません。
wipe(0)

// ワイプ消滅フラグをオンにします。
back.object[0].wipe_erase = 1

// ワイプします。
// ワイプ消滅フラグがオンなので、ワイプされます！
wipe(0)

// ワイプするには、フロントのワイプコピーフラグをオフにする方法もあります。
// front.object[0].wipe_copy = 0
//
</pre>



■ グループ（オブジェクトボタングループ）

<div class="chips">
オブジェクトに表示矩形を設定した場合、ボタンの当たり判定も表示矩形内に収まるようになりました。（2012/3/13 Ver.1.0.13.7 より）
</div>

	ボタン属性を持たせたオブジェクトを使い、独自の選択肢を作るには、グループを使います。
	詳細はサンプルを参照して下さい。

	グループの個数は Gameexe.ini で設定できます。

<pre class="source">
// *************************************************************
// ■オブジェクトボタングループの設定
// =============================================================
#OBJBTNGROUP.CNT = 16
</pre>

	以下の手順で、オブジェクトを用いた選択肢を作ることができます。

<ul>
- Gameexe.ini で「ボタンの動作」と「ボタンの効果音」を設定する
- オブジェクトにボタン属性を持たせる
- グループを用いて選択を行う
</ul>

+ 「ボタンの動作」と「ボタンの効果音」を設定する

++ ボタンアクションの登録

	Gameexe.ini の「■ボタンアクションの設定」を参照して下さい。

++ ボタン効果音の登録

	Gameexe.ini の「■ボタン効果音の設定」を参照して下さい。

+ オブジェクトにボタン属性を持たせる

	オブジェクトにボタン番号、グループ番号、アクション番号、効果音番号を設定します。
	設定方法については [[オブジェクトボタン]] を参照して下さい。

<ul>
- ボタン番号：決定したときに sel コマンドなどで取得できる値です。
- グループ番号：使用するグループの番号です。たとえば 0 を指定した場合、グループ０番（front.objbtngroup[0]）が使われます。
- アクション番号：Gameexe.ini で登録したボタンアクションの番号を指定します。
- 効果音番号：Gameexe.ini で登録したボタン効果音の番号を指定します。
</ul>

+ 指定したグループ番号のグループを開始する

	[[オブジェクトボタングループを開始する]] を参照して下さい。

■ グループ（オブジェクトボタングループ）を開始する

+ 選択を初期化する

<pre class="exp">
front.objbtngroup[0].init
</pre>

	グループの選択状態を初期化します。
	オブジェクトにボタン属性を持たせる前に、必ず初期化してください。

	グループは、一度選択すると「選択状態」になり、
	init で初期化を行うまで二度と選択できなくなります。

+ 選択を開始する（簡易版）

<pre class="exp">
a[0] = front.objbtngroup[0].sel
a[0] = front.objbtngroup[0].sel_cancel
a[0] = front.objbtngroup[0].sel_cancel($cancel_se_no)
</pre>

	このグループで選択を開始します。
	選択が終わるまでスクリプトは進みません。
	選択したオブジェクトのボタン番号が戻り値になります。

	sel_cancel の場合、右クリックで選択をキャンセルできます。
	キャンセルした場合、戻り値は -1 になります。
	$cancel_se_no には、キャンセルを行ったときの効果音番号を指定します。
	（ボタンを選択したときの効果音は、各ボタンごとに設定します。）

+ 選択を開始する（制御版）

<pre class="exp">
front.objbtngroup[0].start
front.objbtngroup[0].start_cancel
front.objbtngroup[0].start_cancel($cancel_se_no)
</pre>

	このグループで選択を開始します。
	選択中も、スクリプトは進み続けます。
	選択状態は、get_hit_no, get_pushed_no, get_decided_no で取得できます。

	start_cancel の場合、右クリックで選択をキャンセルできます。
	$cancel_se_no には、キャンセルを行ったときの効果音番号を指定します。
	（ボタンを選択したときの効果音は、各ボタンごとに設定します。）

+ 選択を終了する

<pre class="exp">
front.objbtngroup[0].end
</pre>

	start で開始した選択を終了します。
	普通は、決定またはキャンセルされた時点で終了するので、
	あまり使うことはないと思います。

+ マウスが当たっているボタンのボタン番号を取得する

<pre class="exp">
a[0] = front.objbtngroup[0].get_hit_no
</pre>

	選択中の場合、現在マウスが当たっているボタンのボタン番号を取得します。
	当たっていない場合、-1 になります。

+ 押されているボタンのボタン番号を取得する

<pre class="exp">
a[0] = front.objbtngroup[0].get_pushed_no
</pre>

	選択中の場合、現在押されているボタンのボタン番号を取得します。
	押されていない場合、-1 になります。

+ 決定されたボタンのボタン番号を取得する

<pre class="exp">
a[0] = front.objbtngroup[0].get_decided_no
</pre>

	選択中の場合、決定されたボタンのボタン番号を取得します。
	キャンセルされた場合は -1 になります。
	<font color="red">決定もキャンセルもされていない場合は -2 になります。</font>

	start コマンドの場合はキャンセル不可のため、-1 になることはありません。
	ただし、システムコマンドメニューの呼び出しが禁止されている場合は -1 になることがあります。


+ 選択されているボタンを取得する

	制御版の選択肢コマンド start_cancel において、どのボタンで決定／キャンセルされたかを取得します。
	こちらを使用することでボタンの上で右クリックしたときの処理を作ることができます。
	※タッチスクリーンの場合、長押しすると右クリックしたことになるので、そのときの処理が追加できます。

<pre class="exp">
a[0] = front.objbtngroup[0].get_result
</pre>

	選択肢の状態を取得します。
		 0 : まだ選択中です。
		 1 : 決定されました。
		-1 : キャンセルされました。

	ほとんどの場合 get_result とセット使用します。


<pre class="exp">
a[0] = front.objbtngroup[0].get_result_button_no
</pre>

	get_resultの値が 1 または -1 ときのみ正常な値を返しますので、あらかじめ get_result で値を取得しておいてください。

	get_result が 1 のときは、決定されたボタン番号が返ります。

	get_result が -1 のときは、キャンセルされたときにマウスが当たっていたボタンのボタン番号が返ります。
	もし、ボタンのないところでキャンセルしていた場合は -1 が返ります。


<pre>
	■サンプル

		// *************************************************************
		// 新しいボタン選択肢の結果の取得
		// =============================================================

		syscom.set_syscom_menu_disable

		front.object[0].create("unit00", 1, 100, 100)
		front.object[0].set_button(0)
		front.object[1].create("unit01", 1, 200, 100)
		front.object[1].set_button(1)
		front.objbtngroup[0].start_cancel

		while (1)	{

			L[0] = front.objbtngroup[0].get_result
			if (L[0] == 1)	{
				L[0] = front.objbtngroup[0].get_result_button_no
				switch (L[0])	{
				case (00)	"０番が選ばれました。"r
				case (01)	"１番が選ばれました。"r
				}
			}
			elseif (L[0] == -1)	{
				L[0] = front.objbtngroup[0].get_result_button_no
				switch (L[0])	{
				case (00)	"０番の上でキャンセルされました。"r
				case (01)	"１番の上でキャンセルされました。"r
				case (-1)	"ボタンのないところでキャンセルされました。"r
				}
			}

			disp
		}
</pre>









■ スクリーン

	画面全体に効果を与えます。
	画面全体をモノクロにしたり、揺らしたりできます。
	イベントを使って、「１秒かけて画面をモノクロにする」などの演出もできます。

+ エフェクト

<pre class="exp">
screen.effect
</pre>

	エフェクトについては [[エフェクト]] を参照して下さい。

<div class="chips">
(2010/9/3) 旧バージョンでは、screen.x や screen.mono などのように直接パラメータを指定していました。
ステージやオーダー制御を行うため、screen.effect の中に移動されました。
</div>

+ シェイク

<pre class="exp">
screen.shake
</pre>

	シェイクについては [[シェイク]] を参照して下さい。

+ クエイク

<pre class="exp">
screen.quake
</pre>

	クエイクについては [[クエイク]] を参照して下さい。












■ エフェクト

	画面に効果を与えます。
	画面を動かしたり、モノクロにしたりできます。
	イベントを使って、「１秒かけて画面をモノクロにする」などの演出もできます。

	画面全体に効果を与えるには screen.effect 使います。
	バック／フロント／ネクストのみに効果を与えることもできます（back.effect / front.effect / next.effect）。
	ワイプ制御をしたい場合はこちらを使って下さい。 

	デフォルトで４個あります（effect[0]～effect[3]）（少し処理が重いため、少なめです）。
	個数は Gameexe.ini で変更できます。

+ パラメータ

<pre class="exp">
screen.effect[0].x = 0
screen.effect[0].y = 0
screen.effect[0].z = 0
screen.effect[0].mono = 0
screen.effect[0].reverse = 0
screen.effect[0].bright = 0
screen.effect[0].dark = 0
screen.effect[0].color_r = 0
screen.effect[0].color_g = 0
screen.effect[0].color_b = 0
screen.effect[0].color_add_r = 0
screen.effect[0].color_add_g = 0
screen.effect[0].color_add_b = 0
</pre>

	パラメータ詳細については、 [[オブジェクト]] などを参照して下さい。

+ イベント

<pre class="exp">
screen.effect[0].x_eve
screen.effect[0].y_eve
screen.effect[0].z_eve
screen.effect[0].mono_eve
screen.effect[0].reverse_eve
screen.effect[0].bright_eve
screen.effect[0].dark_eve
screen.effect[0].color_r_eve
screen.effect[0].color_g_eve
screen.effect[0].color_b_eve
screen.effect[0].color_rate_eve
screen.effect[0].color_add_r_eve
screen.effect[0].color_add_g_eve
screen.effect[0].color_add_b_eve
</pre>

	イベントについては [[イベント]] を参照して下さい。

+ エフェクトを初期化する

<pre class="exp">
screen.effect[0].init
</pre>

+ エフェクトの個数を取得／設定する

<pre class="exp">
screen.effect.resize($cnt)       // 個数を設定する
a[0] = screen.effect.get_size    // 個数を取得する
</pre>

	コマンドはありますが、エフェクトの個数は変更できません。（エラーになります。）

+ オーダーを指定する（メッセージウィンドウにも効果を与えるなど）

<pre class="exp">
screen.effect[0].begin_order = 0
screen.effect[0].end_order = 0
</pre>

	効果を適用するオーダーの範囲を指定できます。
	メッセージウィンドウにも効果を与えたい時などに使います。
	オーダーについては [[オーダー]] を参照して下さい。
	省略すると オーダー 0 のみに効果を与えます。

+ レイヤーを指定する（細かく効果範囲を制御する）

<pre class="exp">
screen.effect[0].begin_layer = (int_min)
screen.effect[0].end_layer = (int_max)
</pre>

	効果を適用するレイヤーの範囲を指定できます。
	背景以外のオブジェクトに効果を与えたい、など細かく範囲を制御するときに使って下さい。

	初期値は、レイヤーの最小値～最大値になっています。
	初期化するときは init コマンドを使って下さい。

+ ワイプコピーを行う

<pre class="exp">
screen.effect[0].wipe_copy = 0        // ワイプコピーフラグ
screen.effect[0].wipe_erase = 0       // ワイプ消滅フラグ
</pre>

	ワイプコピーを行うこともできます。
	ワイプコピーについては [[ワイプコピー]] を参照して下さい。

+ サンプル：ワイプして画面をモノクロにする

<pre class="source">

// バックに背景を読み込みます。
back.object[0].create(BG001, 1)

// バックをモノクロにします。
back.effect[0].mono = 255

// ワイプします。
wipe
</pre>

+ サンプル：ワイプして画面をセピアにする

<pre class="source">

// バックに背景を読み込みます。
back.object[0].create(BG001, 1)

// バックをセピアにします。
back.effect[0].mono = 255
back.effect[0].color_add_r = 107
back.effect[0].color_add_g = 74
back.effect[0].color_add_b = 43

// ワイプします。
wipe
</pre>



■ シェイク

	画面を簡単に揺らします。
	複雑なことをする場合は [[クエイク]] を使ってください。

+ 画面を揺らす

<pre class="exp">
screen.shake($shake_no)
</pre>

	$shake_no には、Gameexe.ini で指定したシェイク番号を指定します。

<pre class="source">
// *************************************************************
// ■シェイクの設定
// =============================================================
#SHAKE.CNT = 32
#SHAKE.000 = (0,8,64)(0,-8,64)(0,8,64)(0,-8,48)(0,8,32)
#SHAKE.001 = (-32,32,64)(-32,-32,64)(32,-32,64)(32,32,64)(16,-16,64)(-8,-8,64)(-4,4,48)(2,2,32)
</pre>

++ 補足

<ul>
- 揺れが終わるまで待ちます。待たないバージョンはありません。
- 途中で止めることはできません。
- フロント／バックの概念はありません。
- オーダーを指定することはできません。
- バッファは１つしかありません。
</ul>


■ クエイク

	画面を揺らすには quake を使います。

	画面全体を揺らしたい場合は screen.quake 使います。
	バック／フロント／ネクストのみを揺らすこともできます（back.quake / front.quake / next.quake）。
	ワイプ制御をしたい場合はこちらを使って下さい。 

	デフォルトで１６個あります（quake[0]～quake[15]）。
	（設定ファイルで変更できます。[[クエイクの設定]] 参照）


+ クエイクを開始する

<pre class="exp">
screen.quake[0].start($type, $time, $cnt, [$opt1, $opt2, ...])
screen.quake[0].start($type, $time, $cnt, $end_cnt, [$opt1, $opt2, ...])
screen.quake[0].start($type, $time, $cnt, $end_cnt, $begin_order, $end_order, [$opt1, $opt2, ...])

screen.quake[0].start_wait($type, $time, $cnt, [$opt1, $opt2, ...])
screen.quake[0].start_wait($type, $time, $cnt, $end_cnt, [$opt1, $opt2, ...])
screen.quake[0].start_wait($type, $time, $cnt, $end_cnt, $begin_order, $end_order, [$opt1, $opt2, ...])

screen.quake[0].start_wait_key($type, $time, $cnt, [$opt1, $opt2, ...])
screen.quake[0].start_wait_key($type, $time, $cnt, $end_cnt, [$opt1, $opt2, ...])
screen.quake[0].start_wait_key($type, $time, $cnt, $end_cnt, $begin_order, $end_order, [$opt1, $opt2, ...])

screen.quake[0].start_nowait($type, $time, $cnt, [$opt1, $opt2, ...])
screen.quake[0].start_nowait($type, $time, $cnt, $end_cnt, [$opt1, $opt2, ...])
screen.quake[0].start_nowait($type, $time, $cnt, $end_cnt, $begin_order, $end_order, [$opt1, $opt2, ...])
</pre>


++ 引数

<div class="table-container">
<table>
|引数|意味|
|$type|タイプを指定します。|
|$time|クエイクにかける時間を指定します。1000 = 1秒|
|$cnt|揺らす回数を指定します。0 にすると止めるまで揺らし続けます。|
|$end_cnt|揺れがだんだん小さくなる回数を指定します。|
|[$opt1, ...]|オプションです。タイプによって意味が異なります。|
</table>
</div>

++ タイプ

<div class="table-container">
<table>
|値|効果|
|0|片方向に揺らします。（例：上→現在位置→上→現在位置→…）<br />$opt1 = 揺れ幅<br />$opt2 = 揺れ方向（0=上、1=右上、2=右、3=右下、4=下、5=左下、6=左、7=左上）|
|1|両方向に揺らします。（例：上→現在位置→下→現在位置→…）<br />$opt1 = 揺れ幅<br />$opt2 = 揺れ開始方向（0=上、1=右上、2=右、3=右下、4=下、5=左下、6=左、7=左上）|
|2|ズームします。<br />$opt1 = 拡大率（0 - 255）（128 で２倍）<br />$opt2 = 中心Ｘ<br />$opt3 = 中心Ｙ|
</table>
</div>

++ 揺れる時間

	$time には「１回の揺れにかける時間」を指定します。
	例えば $time が 1000 で５回揺らすと、合計で 5000 ﾐﾘ秒揺れ続けます。

++ 揺れる回数

	$end_cnt を指定することで、揺れをだんだん小さくできます。

<div class="table-container">
<table>
|$cnt, $end_cnt||
|3, 0|普通に３回揺れます。|
|1, 5|普通に１回揺れて、だんだんと揺れが小さくなりながら５回揺れます。合計６回揺れます。|
|0, 0|揺れ続けます。止めるには quake[0].end を使って下さい。|
</table>
</div>

++ 両方向に揺れるタイプの注意

	タイプ = 1 で両方向に揺らした場合、原点からのずれはタイプ 0 の半分になります。
	例えば揺れ開始方向 = 上、揺れ幅 = 100 とすると、上に 50、下に 50 の幅で揺れます。

++ wait, wait_key, nowait

	_wait がつくコマンドは、揺れが終了するまで待ちます。
	_wait_key がつくコマンドは、揺れが終了するまで待ちますが、キーを押すと揺れを停止します。
	_nowait がつくコマンドは、揺れが終了するのを待たずに次に進みます。

++ オーダーを指定する（メッセージウィンドウごと揺らすなど）

	揺らす対象を、オーダーで指定することもできます（$begin_order, $end_order）。
	メッセージウィンドウごと揺らしたい時などに使います。
	オーダーについては [[オーダー]] を参照して下さい。
	省略すると オーダー 0 のみを揺らします。

	コマンドに _all をつけると、全てのオーダーを揺らします。

<pre class="exp">
screen.quake[0].start_all($type, $time, $cnt, [$opt1, $opt2, ...])
screen.quake[0].start_all($type, $time, $cnt, $end_cnt, [$opt1, $opt2, ...])

screen.quake[0].start_all_wait($type, $time, $cnt, [$opt1, $opt2, ...])
screen.quake[0].start_all_wait($type, $time, $cnt, $end_cnt, [$opt1, $opt2, ...])

screen.quake[0].start_all_wait_key($type, $time, $cnt, [$opt1, $opt2, ...])
screen.quake[0].start_all_wait_key($type, $time, $cnt, $end_cnt, [$opt1, $opt2, ...])

screen.quake[0].start_all_nowait($type, $time, $cnt, [$opt1, $opt2, ...])
screen.quake[0].start_all_nowait($type, $time, $cnt, $end_cnt, [$opt1, $opt2, ...])
</pre>




■ クエイクを止める／待つ／判定する

+ クエイクを停止する

<pre class="exp">
screen.quake[0].end
screen.quake[0].end($time)
</pre>

	クエイクを停止します。
	time を指定すると、time ﾐﾘ秒かけて停止します。

+ クエイクが終了するのを待つ

<pre class="exp">
screen.quake[0].wait
screen.quake[0].wait_key    // 決定キーでスキップできる
</pre>

	クエイクをが終了するのを待ちます。

+ クエイクの状態を取得する

<pre class="exp">
a[0] = screen.quake[0].check
</pre>

	クエイクの状態を取得します。
	0=クエイク中でない、1=クエイク中、2=終了中

++ 終了中とは？

	end コマンドで時間を指定して終了したとき、
	実際に終了するまでの間が「終了中」です。
	（check の結果は 2 になります）

	start コマンドでの end_cnt で指定した揺れは「終了中」には含まれません。
	（check の結果は 1 になります）


■ イベント

+ イベントについて

	イベントを使えば、「画面を１秒かけてモノクロにする」
	「オブジェクトをＡ地点からＢ地点の間をループさせる」などが簡単にできます。

	画面全体にイベントを与えるには、スクリーンやステージの「エフェクトイベント」を使います。
	オブジェクトにイベントを与えるには、「オブジェクトイベント」を使います。
	その他、いろいろなイベントがありますが、どれも使い方は同じです。
	イベントの種類については、それぞれ [[オブジェクトイベント]]、[[エフェクト]] などを参照して下さい。

++ 代表的なイベント

<pre class="exp">
screen.effect[0].mono_eve  // スクリーンのモノクロイベント
front.effect[0].mono_eve   // フロントステージのモノクロイベント
front.object[0].x_eve      // オブジェクトのＸ座標イベント
front.object[0].tr_eve     // オブジェクトの不透明度イベント
</pre>

	以下、イベントを $event と書きます。

++ 使い方の例

	例えば「オブジェクトのＸ座標イベント（x_eve）」に対して「ループイベント(loop)」を実行したい場合は、次のように使います。

<pre class="source">
front.object[0].x_eve.loop(100, 200, 1000, 0, 0)
</pre>

+ イベントを開始する

<pre class="exp">
$event.set($value, $time, $rep_time, $speed_mode)                          // イベントを開始する
$event.set_real($value, $time, $rep_time, $speed_mode)                     // イベントを開始する（実時間）
$event.loop($start_value, $end_value, $time, $rep_time, $speed_mode)       // ループイベントを開始する
$event.loop_real($start_value, $end_value, $time, $rep_time, $speed_mode)  // ループイベントを開始する（実時間）
$event.turn($start_value, $end_value, $time, $rep_time, $speed_mode)       // ターンイベントを開始する
$event.turn_real($start_value, $end_value, $time, $rep_time, $speed_mode)  // ターンイベントを開始する（実時間）
</pre>

<div class="table-container">
<table>
|set|$time ﾐﾘ秒かけて、値を現在の値から $value に変化させます。|
|loop|$time ﾐﾘ秒かけて、値を $start_value から $end_value の間でループさせます。|
|turn|$time ﾐﾘ秒かけて、値を $start_value から $end_value の間で往復させます。|
</table>
</div>

++ 引数

++ $rep_time: 修正時刻

	$rep_time を指定すると、イベントを $rep_time ﾐﾘ秒遅らせて開始できます。

++ $speed_mode: 加速モード

	$spped_mode を指定すると、イベントを加速させたり減速させたりできます。0=等速、1=加速、2=減速。

++ 最終値についての注意

	イベントを停止した場合、値は最後の値になります。
	例えば、「１秒かけてＡ地点からＢ地点に移動する」イベントを途中で止めた場合、すぐにＢ地点に移動します。
	ただし、ループイベントやターンイベントの場合は、Ａ地点に戻ります。


++ 画面を１秒かけてモノクロにする

<pre class="source">
front.effect[0].mono_eve.set(255, 1000, 0, 0)
</pre>

++ オブジェクトのＸ座標を１秒かけて１００にする

<pre class="source">
front.object[0].x_eve.set(100, 1000, 0, 0)
</pre>

++ 実時間について

	_real のつくコマンドは、実時間で実行されます。
	早送りなどの制御を受け付けません。
	音楽と同期を取るときなどに使って下さい。

+ イベントの初期値設定

	名前つき引数を使って、初期値を与えることができます。

<div class="table-container">
<table>
|start|イベントの初期値|
</table>
</div>

++ オブジェクトをふわっと登場させる

<pre class="source">
front.object[0].create(UNIT00, 1)
front.object[0].x_eve.set(640, 200, 0, 2, start=740)
front.object[0].tr_eve.set(255, 200, 0, 2, start=0)
</pre>

	オブジェクトのＸ座標を、740から640に、200ﾐﾘ秒かけて、減速で動かします。
	オブジェクトの不透明度を、0から255に、200ﾐﾘ秒かけて、減速で動かします。
	この組み合わせで、オブジェクトがふわっと浮き出るように登場します。

	以下のように書くのと同じですが、名前つき引数を使った方が簡潔に書けます。

<pre class="source">
front.object[0].create(UNIT00, 1)
front.object[0].x = 740
front.object[0].x_eve.set(640, 200, 0, 2)
front.object[0].tr = 0
front.object[0].tr_eve.set(255, 200, 0, 2)
</pre>

+ イベントを終了させる

<pre class="exp">
$event.end                                     // イベントを終了する
</pre>

	イベントを終了させます。あまり使わないと思います。

+ イベントが終わるのを待つ

<pre class="exp">
$event.wait                                    // イベントが終了するのを待つ
a[0] = $event.wait_key                         // イベントが終了するのを待つ（キーで飛ばせる）
</pre>

	wait_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。 

+ イベントを判定する

<pre class="exp">
a[0] = $event.check                            // イベントを判定する（0=イベントなし、1=イベント中）
</pre>
























■イベントの一括操作

	「全体イベント」を使って、複数のイベントを一括して扱います。

<h5>代表的な全体イベント</h5>

<pre class="exp">
front.object[0].all_eve    // オブジェクトの全てのイベント
</pre>

<h4>全体イベントのコマンド</h4>

<pre class="exp">
$all_eve.end              // イベントを終了する
$all_eve.wait             // イベントが終了するのを待つ
a[0] = $all_eve.check     // イベントを判定する（0=イベントなし、1=イベント中）
</pre>

<h5>オブジェクトの全てのイベントを停止する</h5>

<pre class="source">
front.object[0].all_eve.end
</pre>

<h5>オブジェクトの全てのイベントが終わるまで待つ</h5>

<pre class="source">
front.object[0].all_eve.wait
</pre>


■ フレームアクション

	フレームアクションを使うと、指定したコマンドを常に呼び続けることができます。
	次のような処理を実装するときに使って下さい。

<ul>
- あるフラグを常に監視し、値によってメッセージウィンドウボタンのパターンを変更する
- カウンタを常に監視し、定期的に効果音などの演出を行う<
- オブジェクトなどを動きを細かく制御する
</ul>

<div class="chips">
正確には、フレームアクションは画面描画の度に呼び出されます。
</div>

+ フレームアクションを開始／終了する

<pre class="exp">
frame_action.start($end_time, $command_name)                   // フレームアクションを開始する
frame_action.start_real($end_time, $command_name)              // フレームアクションを開始する（実時間）
frame_action.start($end_time, $command_name, $param, ...)      // フレームアクションを開始する
frame_action.start_real($end_time, $command_name, $param, ...) // フレームアクションを開始する（実時間）
frame_action.end                                               // フレームアクションを終了する
</pre>

++ 引数

<div class="table-container">
<table>
|$end_time|フレームアクションの終了時間です。後述のエンドアクションに関係します。<br />-1 を指定すると、止めるまで呼び続けます。|
|$command_name|呼び続けるコマンドの名前を指定します。|
|$param|コマンドに渡す引数です。|
</table>
</div>

+ 簡単なフレームアクションの例

	フレームアクションはコマンドを呼び出し続ける機能ですので、コマンドを作る必要があります。

<pre class="source">
// フレームアクションを開始する
// 呼び出すコマンドは $screen_action_red
// 1000ﾐﾘ秒間呼び出し続ける
frame_action.start(1000, "$screen_action_red")

画面を赤くしています。r

// *************************************************************
// 画面を赤くするフレームアクション用のコマンド
// １つ目の引数は必ず frameaction 型である必要があります。
// =============================================================
command $screen_action_red(property $fa : frameaction)
{
    // フレームアクション専用のカウンタから現在の値を取得
    l[0] = $fa.counter.get
    // カウンタが 0～1000 の間、ゲーム画面の「色加算：赤」を 0～255 に変化させる
    screen.color_add_r = math.timetable(l[0], 0, 0, [0, 1000, 255])
}
</pre>

	$screen_action_red というコマンドを作成し、フレームアクションに設定しています。
	フレームアクションがクリアされるまで、$screen_action_red が呼び出され続けます。

	<font color="red">フレームアクションとして設定するコマンドの１つ目の引数は、
	必ず frameaction 型でなければいけません。</font>

	フレームアクションの中では、画面全体に赤味を設定しています。
	１つ目の引数 $fa のカウンタ（$fa.counter）はフレームアクション専用のカウンタで、
	フレームアクションを開始と同時に開始されます。
	詳しくは [[カウンタ]] を参照して下さい。

+ 実時間

	_real のつくコマンドは、カウンタを実時間で進めます。
	早送りなどの制御を受け付けません。
	音楽と同期を取るときなどに使って下さい。

+ フレームアクションの引数

	フレームアクション用のコマンドに、引数を渡すこともできます。

<pre class="source">
// フレームアクションを開始する
// 呼び出すコマンドは $screen_action_red
// 1000ﾐﾘ秒間呼び出し続ける
// 引数に 128 を渡す
frame_action.start(1000, "$screen_action_red", 128)

画面を赤くしています。r

// *************************************************************
// 画面を赤くするフレームアクション用のコマンド
// ２つ目の引数を $value で受け取っています。
// =============================================================
command $screen_action_red(property $fa : frameaction, property $value)
{
    // フレームアクション専用のカウンタから現在の値を取得
    l[0] = $fa.counter.get

    // カウンタが 0～1000 の間、ゲーム画面の「色加算：赤」を 0～$value に変化させる
    screen.color_add_r = math.timetable(l[0], 0, 0, [0, 1000, $value])
}
</pre>

	引数 $value を用意し、赤味を呼び出し側で設定できるようにしています。
	上の例では、赤味を 128 に設定しています。

+ エンドアクション

	上の例で、赤味が例えば 50 まで移動したところで、別のフレームアクションを設定したらどうなるでしょう。
	別のフレームアクションを設定すると、現在設定されているフレームアクションは上書きされます。
	赤味が 50 で止まったまま次の演出に進んでしまいます。
	この問題を解決するのがエンドアクションです。

	フレームアクションが何らかの理由で消された場合、
	フレームアクションのカウンタが $end_time まで進み、
	その後、フレームアクションが１度だけ呼ばれます。
	これをエンドアクションと呼びます。

++ フレームアクションが消されるのはいつ？

<ul>
- フレームアクションが初期化されたとき
- 別のフレームアクションで上書きしたとき
- ...
</ul>


<pre class="source">
// フレームアクション $screen_action_red を開始する
frame_action.start(1000, "$screen_action_red")

画面を赤くしています。r

<font color="red">// フレームアクション $screen_action_blue を開始する</font>
<font color="red">// 同時に、$screen_action_red のエンドアクションが呼ばれる</font>
frame_action.start(1000, "$screen_action_blue")

画面を青くしています。r

// *************************************************************
// 画面を徐々に赤くするフレームアクション
// =============================================================
command $screen_action_red(property $fa : frameaction)
{
    // フレームアクション専用のカウンタから現在の値を取得
    l[0] = $fa.counter.get
    // カウンタが 0～1000 の間、ゲーム画面の「色加算：赤」を 0～255 に変化させる
    screen.color_add_r = math.timetable(l[0], 0, 0, [0, 1000, 255])
}

// *************************************************************
// 画面を徐々に青くするフレームアクション
// =============================================================
command $screen_action_blue(property $fa : frameaction)
{
    // フレームアクション専用のカウンタから現在の値を取得
    l[0] = $fa.counter.get
    // カウンタが 0～1000 の間、ゲーム画面の「色加算：青」を 0～255 に変化させる
    screen.color_add_b = math.timetable(l[0], 0, 0, [0, 1000, 255])
}
</pre>


+ ループフレームアクション

	$end_time に -1 を指定すると、フレームアクションは無限に動き続けます。
	この場合も、フレームアクションを初期化した場合はエンドアクションは実行されますが、
	カウンタは $end_time ではなく 0 で呼び出されます。

<pre class="source">
// フレームアクション $screen_action_red_loop を開始する
// ループフレームアクションになので、時間を -1 にする
frame_action.start(-1, "$screen_action_red_loop")

画面を赤く明滅させています。r

// *************************************************************
// 画面を赤く明滅させるフレームアクション
// =============================================================
command $screen_action_red_loop(property $fa : frameaction)
{
    // フレームアクション専用のカウンタから現在の値を取得
    // 2000ﾐﾘ秒でループさせるため、2000 で割った余りを使います。
    l[0] = $fa.counter.get % 2000 
    // カウンタが 0～2000 の間、ゲーム画面の「色加算：赤」を 0→255→0 に変化させる
    screen.color_add_r = math.timetable(l[0], 0, 0, [0, 1000, 255], [1000, 2000, 0])
}
</pre>





■ フレームアクションチャンネル

	フレームアクションの専用チャンネルです。
	１つのチャンネルにつき１つのフレームアクションを設定できます。
	チャンネル単位でアクションを止めたりできます。

	チャンネルは初期値で４個あります。（Gameexe.ini で変更できます。）

+ フレームアクションを開始／終了する

<pre class="exp">
frame_action_ch[0].start($end_time, $command_name)                // フレームアクションを開始する
frame_action_ch[0].start($end_time, $command_name, $param, ...)   // フレームアクションを開始する
frame_action_ch[0].end                                            // フレームアクションを終了する
</pre>

	詳細については [[フレームアクション]] を参照して下さい。

+ サンプル：複数のフレームアクションを動かす

<pre class="source">
// フレームアクション０番に $frame_action_quake_loop を設定する
// 時間に -1 を指定することでループアクションにする
frame_action_ch[0].start(-1, "$frame_action_quake_loop")

画面を揺らしています。r

// フレームアクション１番に $screen_action_red_loop を設定する
// 時間に -1 を指定することでループアクションにする
frame_action_ch[1].start(-1, "$screen_action_red_loop")

画面を明滅させています。r

// *************************************************************
// 画面を揺らすフレームアクション
// =============================================================
command $frame_action_quake_loop(property $fa : frameaction)
{
    // フレームアクション専用のカウンタから現在の値を取得
    // 500ﾐﾘ秒でループさせるため、500 で割った余りを使います。
    l[0] = $fa.counter.get % 500

    // カウンタが 0～500 の間、揺れを -10～10 の範囲で動かす
    l[1] = math.timetable(l[0], 0, 0, [0, 500, 3600])   // l[1]: 角度（500ﾐﾘ秒で360度）
    l[2] = math.sin(l[1], 10)                           // l[2]: 揺れ

    // 画面のＸ座標の揺れを設定する
    screen.x = l[2]
}

// *************************************************************
// 画面を赤く明滅させるフレームアクション
// =============================================================
command $screen_action_red_loop(property $fa : frameaction)
{
    // フレームアクション専用のカウンタから現在の値を取得
    // 2000ﾐﾘ秒でループさせるため、2000 で割った余りを使います。
    l[0] = $fa.counter.get % 2000

    // カウンタが 0～2000 の間、ゲーム画面の「色加算：赤」を 0→255→0 に変化させる
    screen.color_add_r = math.timetable(l[0], 0, 0, [0, 1000, 255], [1000, 2000, 0])
}

</pre>


■オブジェクトのフレームアクション

<pre class="exp">
front.object[0].frame_action        // 汎用チャンネル
front.object[0].frame_action_ch     // 専用チャンネル
</pre>

	オブジェクト単位のフレームアクションです。
	コマンドの作り方に注意が必要です。

<pre class="source">
// オブジェクトに BS0101 を読み込む
front.object[0].create(BS0101, 1, 100, 100)

// オブジェクト０番にフレームアクション $object_action_slide を設定する
// 時間は1000ﾐﾘ秒、引数に 0, 255, 1000 を渡す
front.object[0].frame_action.start(1000, "$object_action_slide", 0, 255, 1000)

// *************************************************************
// オブジェクトをスライドさせるアクション
//   $start_x: スライド開始位置Ｘ
//   $end_x:   スライド終了位置Ｘ
//   $time:    スライドにかける時間
// =============================================================
command $object_action_slide(
    property $fa : frameaction, 
    <font color="red">property $obj : object</font>, 
    property $start_x, 
    property $end_x, 
    property $time)
{
    // フレームアクション専用のカウンタから現在の値を取得
    l[0] = $fa.counter.get
    // $time 秒かけて、値を $start_x から $end_x まで、減速で動かす
    l[1] = math.timetable(l[0], 0, $start_x, [0, $time, $end_x, 2])
    // オブジェクトのＸ座標を設定する
    <font color="red">$obj.x = l[1]</font>
}
</pre>

	オブジェクトにフレームアクションを設定する場合、そのコマンドの２つ目の引数は object 型である必要があります。
	この引数には、フレームアクションを実行したオブジェクトが設定されています。
	この引数を操作することで、オブジェクトを操作することができます。

	上の例では、２つ目の引数 $obj は front.object[0] を指しています。
	$obj.x を設定することで、front.object[0].x が設定されることになります。

+ 専用チャンネルを使う

	frame_action_ch は初期値で０個です。
	使う分だけ確保する必要があります。

<pre class="source">
// オブジェクトに BS0101 を読み込む
front.object[0].frame_action_ch.resize(2)      // 専用チャンネルを２つ確保する
front.object[0].frame_action_ch[0].start(...)  // 専用チャンネル０番を使う
front.object[0].frame_action_ch[1].start(...)  // 専用チャンネル１番を使う
</pre>

<h4>サンプル：オブジェクトをスライドさせる</h4>

<pre class="source">
// *************************************************************
// オブジェクトをスライドさせるコマンド
// =============================================================
command $object_slide_action(
    property $fa : frameaction, 
    property $obj : object, 
    property $start_x, 
    property $end_x, 
    property $time)
{
    // フレームアクション専用のカウンタから現在の値を取得
    l[0] = $fa.counter.get
    // カウンタが 0～$time の間、オブジェクトのＸ座標を、$start_x～$end_x に、減速で変化させる
    $obj.x = math.timetable(l[0], 0, $start_x, [0, $time, $end_x, 2])
}

// オブジェクト０番を、1000ﾐﾘ秒で、100～300までスライドさせる
front.object[0].create(UNIT00, 1, 100, 100)
front.object[0].frame_action.start(1000, "$object_slide_action", 100, 300, 1000)

// オブジェクト１番を、3000ﾐﾘ秒で、0～640 までスライドさせる
front.object[1].create(UNIT01, 1, 300, 300)
front.object[1].frame_action.start(3000, "$object_slide_action", 0, 640, 3000)

オブジェクトを移動させました。r
</pre>


<h4>サンプル：オブジェクトを回転させ続ける</h4>

<pre class="source">
// *************************************************************
// オブジェクトを回転させ続けるコマンド
// =============================================================
command $object_rotate_action(
    property $fa : frameaction, 
    property $obj : object)
{
    // フレームアクション専用のカウンタから現在の値を取得
    // 1000ﾐﾘ秒でループさせるため、1000 で割った余りを使います。
    l[0] = $fa.counter.get % 1000
    // 1000ﾐﾘ秒かけてオブジェクトを360度回転させる
    $obj.rotate_z = math.timetable(l[0], 0, 0, [0, 1000, 3600])
}

// オブジェクト０番を回転させ続ける
front.object[0].create(UNIT00, 1, 100, 100)
front.object[0].frame_action.start(-1, "$object_rotate_action")

オブジェクトを回転させています。r
</pre>




■ マスク

	画像にマスクをかけて、表示範囲を制限する機能です。

	サンプルの「その他の演出」→「マスク」に、実際にマスクを使った例があります。

<div align="center">
<img src="マスク.jpg" /><br />

	マスクによって漫画のようなコマ割り

</div>
<div align="center">
<img src="マスク2.jpg" /><br />

	マスクによって画面効果を与える

</div>

+ マスクの設定

	マスクはデフォルトで１６個まで作れます。詳しくは [[マスクの設定]] を参照して下さい。

+ マスク画像を作る

	マスクは、通常の g00 画像で作ります。
	表示する部分を白、抜きたい部分を<font color="red">透明</font>にした画像を作って下さい。
	（※マスクワイプとは画像の作り方が違うので注意して下さい。）

+ マスクの使い方

	[[マスク操作]] を参照して下さい。




■ マスク操作

	マスクの操作一覧です。
	マスクについては [[マスクについて]] を参照して下さい。

+ マスク画像を初期化する

<pre class="exp">
mask[0].init
</pre>

	マスク画像を初期化します。

+ マスク画像を設定する

<pre class="exp">
mask[0].create($file_name)
</pre>

	マスクに画像を読み込みんで、マスク画像を設定します。

+ マスクの位置を設定する

<pre class="exp">
mask[0].x = 0
mask[0].y = 0
</pre>

+ パラメータイベント

<pre class="exp">
mask[0].x_eve
mask[0].y_eve
</pre>

	詳しくは [[イベント]] を参照して下さい。

+ オブジェクトにマスクをかける

	オブジェクトにマスクをかけるには、mask_no プロパティにマスク番号を指定します。
	マスクをかけない場合は -1 を設定します。 

<pre class="source">
// マスク０番に _mask10 を読み込む
// マスク１番に _mask11 を読み込む
mask[0].create(_mask10)
mask[1].create(_mask11)
マスクを準備しました。r

// オブジェクト０番に背景を読み込む
front.object[0].create(BG001, 1)
オブジェクトに背景を読み込みました。r

// オブジェクト１番に画像を読み込む
front.object[1].create(cg_ev02_0801, 1)
オブジェクトに画像を読み込みました。r

// オブジェクト１番にマスク０番を設定する
front.object[1].mask_no = 0
オブジェクトにマスクをかけました。r

// オブジェクト１番にマスク１番を設定する
front.object[1].mask_no = 1
オブジェクトにマスクをかけました。r

// オブジェクト１番のマスクを外す
front.object[1].mask_no = -1
オブジェクトのマスクを外しました。r

// マスクを解放する
mask[0].init
mask[1].init
マスクを解放しました。r
</pre>






■トーンカーブ

	キャラクターなどを、夕方や夜っぽい色に変換する機能です。
	トーンカーブデータを作成する必要があります。

<h5>トーンカーブ機能を使った様子</h5>

<div class="table-container">
<table>
<tr><td><img src="昼.jpg" /></td><td><img src="夕方.jpg" /></td><td><img src="夜.jpg" /></td></tr>
<tr><td>昼</td><td>夕方<br />トーンカーブ０番</td><td>夜<br />トーンカーブ１番</td></tr>
</table>
</div>

	キャラクターの色が背景に合わせて変更されています。

<h4>トーンカーブデータを作成する</h4>

	ToneCurveEdit.exe を使って作成します。詳しくは ToneCurveEdit.exe のマニュアルを参照して下さい。
	出来上がった tcdata.tcr を dat フォルダに入れ、Gameexe.ini でファイルを指定します。

<pre class="source">
SampleGame
  +- exe
  |   +- <font color="red">dat</font>
  |      +- <font color="red">tcdata.tcr</font>
  |   +- SiglusEngine.exe
  |
  +- SiglusCompiler.exe
</pre>

<h5>Gameexe.ini</h5>

<pre class="source">
// *************************************************************
// ■トーンカーブ
// =============================================================
#TONECURVE_FILE = "tcdata.tcr"
</pre>

<h4>オブジェクトにトーンカーブを当てる</h4>

	サンプル環境の tcdata.tcr は、０番が夕方、１番が夜になっています。

<pre class="source">
// オブジェクト０番に昼の背景を読み込む
// オブジェクト１番にキャラクターを読み込む
back.object[0].create(BG005, 1)
back.object[1].create(BS0101, 1)
wipe

昼の背景です。r

// オブジェクト０番に夕方の背景を読み込む
// オブジェクト１番にキャラクターを読み込み、トーンカーブ０番（夕方）を設定する
back.object[0].create(BG005E, 1)
back.object[1].create(BS0101, 1)
back.object[1].tonecurve_no = 0
wipe

夕方の背景です。r

// オブジェクト０番に夜の背景を読み込む
// オブジェクト１番にキャラクターを読み込み、トーンカーブ１番（夜）を設定する
back.object[0].create(BG005N, 1)
back.object[1].create(BS0101, 1)
back.object[1].tonecurve_no = 1
wipe

夜の背景です。r
</pre>

	夕方や夜以外にも、曇り空や朝方など、背景に合わせて上手に作って下さい。
	その他にも、モノクロやセピア調などを表現することもできます。








■ Ｇ００先読みバッファ

	G00 画像を先読みする機能です。

	爆発エフェクトやアニメなど、複数の画像を使った演出を組むとします。
	画像を読み込むのは時間がかかるため、演出中に読み込んでいると、演出がカクついてしまいます。
	その場合は先読みバッファを使って、あらかじめ画像を読み込んでおきます。
	スムーズな演出が行えます。

	G00 先読みバッファを使うには、g00buf を使います。
	デフォルトで 16 個あります（g00buf[0]～g00buf[15]）。
	（設定ファイルで変更できます。[[Ｇ００先読みバッファの設定]] 参照）


+ サンプル

++ G00 先読みバッファを使わない場合

<pre class="source">
// メッセージを表示します。
Ｇ００先読みバッファのサンプルです。r

// ムービーを再生します。
front.object[1].create_movie_loop(aurora01, 1)
// 3000 ﾐﾘ秒待ちます。
timewait(3000)

// ★背景を読み込みます。
// ここで時間がかかるため、ムービーがカクついてしまいます。
back.object[0].create(BG001, 1)
// ワイプして背景を表示します。
wipe(0, 3000)
</pre>

++ G00 先読みバッファを使う場合

<pre class="source">
// G00 先読みバッファ０番に BG001.g00 をあらかじめ読み込んでおきます。
<font color="red">g00buf[0].load(BG001)</font>
// 次のメッセージ表示がカクつかないように、一度画面を更新しておきます。
// disp の代わりに frame を使うこともできます。
disp

// メッセージを表示します。
Ｇ００先読みバッファのサンプルです。r

// ムービーを再生します。
front.object[1].create_movie_loop(aurora01, 1)
// 3000 ﾐﾘ秒待ちます。
timewait(3000)

// ★背景を読み込みます。
// BG001 は先読みしているため、ムービーがカクつきません。
back.object[0].create(BG001, 1)
// ワイプして背景を表示します。
wipe(0, 3000)

// 先読みバッファはもう使わないので、忘れずに解放して下さい！
// 複数ある場合は、g00buf.free_all を使うと簡単です。
<font color="red">g00buf[0].free</font>
</pre>


+ G00 バッファに画像を先読みする

<pre class="exp">
g00buf[0].load($file_name)
</pre>

+ G00 バッファを解放する

<pre class="exp">
g00buf[0].free
</pre>

+ G00 バッファを全て解放する

<pre class="exp">
g00buf.free_all
</pre>

+ G00 バッファの個数を取得する

<pre class="exp">
a[0] = g00buf.get_cnt
</pre>


■ 時間や画面を更新する

+ 画面を更新する

<pre class="exp">
disp
</pre>

	フレーム処理を行い、画面を更新します。

	このコマンドは、メニュー画面などを自力で作成する場合は必須のコマンドです。
	このコマンドがなければ、オブジェクトを読み込んだり動かしたりした場合に、
	それをいつ画面に反映させていいのかが分かりません。

	通常時は、メッセージ表示や wipe コマンド、timewait コマンドなどで描画を行っています。
	それらを使わないメニュー画面などで使ってください。

	disp を行わずに処理をし続けると、いわゆる「応答なし」状態になってしまいます。

<pre class="source">
while (1)   {
    // オブジェクトなどの処理
    disp
}
</pre>

	時間を更新する場合にも使えます。

<pre class="source">
// 悪い例
front.object[0].create(BIG_CG)  // すごく大きな画像を読み込む
front.object[0].x_eve.set(100, 1000, 0, 0)
イベント中です…。r
</pre>

<pre class="source">
// 良い例
front.object[0].create(BIG_CG)  // すごく大きな画像を読み込む
disp
front.object[0].x_eve.set(100, 1000, 0, 0)
イベント中です…。r
</pre>

	disp がなければ時間も進みません。
	上の様に、重い処理の後には一度時間を進める、必要があります。

+ 時間を更新する

<pre class="exp">
frame
</pre>

	時間を更新します。disp に似ていますが、画面を更新しません。

+ 何もしない

<pre class="exp">
nop
</pre>

	何もしません。

++ どんな時に使うの？

	使わないと思います。マクロの展開などで、単語の区切りが上手く行かない場合があれば使ってください。



■ ＢＧＭ

+ ＢＧＭを再生する

<pre class="exp">
bgm.play($name)
bgm.play($name, $fade_in_time)
bgm.play($name, $fade_in_time, $fade_out_time)
bgm.play_oneshot($name)
bgm.play_oneshot($name, $fade_in_time)
bgm.play_oneshot($name, $fade_in_time, $fade_out_time)
bgm.play_wait($name)
bgm.play_wait($name, $fade_in_time)
bgm.play_wait($name, $fade_in_time, $fade_out_time)
</pre>

<div class="table-container">
<table>
|play|音楽をループ演奏します。|
|play_oneshot|音楽をワンショット演奏します。|
|play_wait|音楽をワンショット演奏し、音楽が終了するまで待ちます。|
</table>
</div>

	$name には、Gameexe.ini で登録した bgm の名前を入れます。
	$fade_in_time を指定すると、フェードインを行います。
	また、$fade_out_time を指定すると、クロスフェードを行います。指定した時間で、現在演奏中の曲がフェードアウトします。

+ ＢＧＭを停止する

<pre class="exp">
bgm.stop
bgm.stop($fade_out_time)
</pre>

	演奏中の曲を停止します。$fade_out_time を指定すると、指定した時間でフェードアウトを行います。

+ ＢＧＭが終了するのを待つ

<pre class="exp">
bgm.wait
a[0] = bgm.wait_key
</pre>

	演奏中の曲が終了するのを待ちます。ループ再生を行っている時に、このコマンドを使っては行けません。（無限ループになってしまいます！）

	wait_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

+ ＢＧＭのフェードアウトが終了するのを待つ

<pre class="exp">
bgm.wait_fade
a[0] = bgm.wait_fade_key
</pre>

	フェードアウト中に使うと、曲のフェードアウトが完了するのを待ちます。

	wait_fade_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

+ ＢＧＭの再生状態を取得する

<pre class="exp">
a[0] = bgm.check
</pre>

	演奏状態を取得します。（0=停止中、1=再生中、2=フェードアウト中）

+ 再生中のＢＧＭの登録名を取得する

<pre class="exp">
s[0] = bgm.get_regist_name
</pre>

	再生中のＢＧＭの登録名を取得します。ファイル名ではなく、Gameexe.ini で設定した登録名なことに注意して下さい。

+ ボリュームを設定する

<pre class="exp">
bgm.set_volume($volume)
bgm.set_volume($volume, $time)
</pre>

	曲のボリュームを 0～255 の範囲で設定します。
	0 にすると無音になります。
	$time を指定すると、指定した時間をかけてボリュームを変化させます。

	※実際の再生される音量は、環境設定で設定された音量と、この命令で設定された音量を掛け合わせたものになります。
	つまり、環境を設定を128、こちらを128にした場合、最大音量の25％程度の音量で再生されます。

+ ボリュームを最大／最小にする

<pre class="exp">
bgm.set_volume_max
bgm.set_volume_max($time)
bgm.set_volume_min
bgm.set_volume_min($time)
</pre>

	曲のボリュームを最大／最小にします。
	$time を指定すると、指定した時間をかけてボリュームを変化させます。

+ ボリュームを取得する

<pre class="exp">
a[0] = bgm.get_volume
</pre>

	曲のボリュームを取得します。


■ ＢＧＭ（フルパラメータ）

	ＢＧＭの play コマンドは、名前つき引数が使えます。

<pre class="exp">
bgm.play({名前つき引数})
bgm.play($name, {名前つき引数})
bgm.play($name, $fade_in_time, {名前つき引数})
bgm.play($name, $fade_in_time, $fade_out_time, {名前つき引数})

名前つき引数 = {name, loop, wait, start_pos, fade_in_time, fade_out_time}
</pre>

++ name

	Gameexe.ini で登録した bgm の名前を入れます。
	以下の２つのコマンドは、どちらも "学校１" を再生します。

<pre class="source">
bgm.play("学校１")          // Gameexe.ini に登録された "学校１" を再生する
bgm.play(name="学校１")     // Gameexe.ini に登録された "学校１" を再生する
</pre>

++ loop

	0=ループしない、1=ループする

	省略した場合、1（ループする）になります。

++ wait

	0=再生終了を待たない、1=再生終了を待つ

	省略した場合、0（再生終了を待たない）になります。

++ start_pos

	再生開始位置を指定できます。
	Gameexe.ini と同様、サンプル数で指定して下さい。（ﾐﾘ秒ではありません！）

	省略した場合、または -1 を指定した場合、Gameexe.ini で設定した開始位置が使われます。

++ fade_in_time

	フェードイン時間をﾐﾘ秒で指定します。

++ fade_out_time

	クロスフェードを行います。前の曲がフェードアウトする時間をﾐﾘ秒で指定します。

+ サンプル：ＢＧＭ「学校１」を、100000 サンプル目から、１秒でフェードインしながら、ループ再生する

<pre class="source">
bgm.play("学校１", start_pos = 100000, fade_in_time = 1000, loop = 1)
</pre>














■ ＢＧＭを準備する（再生遅延を抑える）

	上級者向けのコマンドです。

	ＢＧＭをあらかじめ準備しておくことで、再生遅延を少なくすることができます。
	画面演出と合わせるなど、１フレームのずれを気にする場合に使って下さい。

+ ＢＧＭを準備する

<pre class="exp">
bgm.ready($name)
bgm.ready($name, $fade_out_time)
bgm.ready_oneshot($name)
bgm.ready_oneshot($name, $fade_out_time)

bgm.ready({名前つき引数})
bgm.ready($name, {名前つき引数})
bgm.ready($name, $fade_out_time, {名前つき引数})

名前つき引数 = {name, loop, start_pos, fade_out_time}
</pre>

	使い方は play コマンドと同じです。
	ただし play_wait および引数の wait、fade_in_time はありません。
	次の resume コマンドを参照して下さい。

	<font color="red">※２番目の引数が $fade_in_time ではなく $fade_out_time になっていることに注意して下さい。</font>

+ 準備したＢＧＭを再生する

<pre class="exp">
bgm.resume
bgm.resume($fade_in_time)
bgm.resume_wait
bgm.resume_wait($fade_in_time)
</pre>

	ready コマンドで準備したＢＧＭを再生します。

+ サンプル：ＢＧＭを準備する

	ＯＭＶムービーとＢＧＭを準備し、同時に再生するサンプルです。

<pre class="source">
// ＯＭＶムービーとＢＧＭを準備します。
front.object[0].create_movie(mareop, 0, ready_only = 1, real_time = 1)
<font color="red">bgm.ready_oneshot(mareop)</font>
準備しました。クリックで再生します。r close

// ＯＭＶムービーとＢＧＭを開始します。
front.object[0].disp = 1
front.object[0].resume_movie
<font color="red">bgm.resume</font>

// ＢＧＭの終了を待ちます。
bgm.wait_key

// ＯＭＶムービーとＢＧＭを解放します。
bgm.stop
front.object[0].init
</pre>



















■ ＢＧＭの再生位置を取得する

<pre class="exp">
a[0] = bgm.get_play_pos
</pre>

	ＢＧＭの現在の再生位置を、サンプル数で取得します。




■ ＢＧＭフェードをかけっぱなしにする

	自動で文章が進んで行く演出を組んだとします。
	自動で声が流れますが、声を再生するタイミングによっては、
	ＢＧＭフェードによりＢＧＭの音量がころころと上下し、邪魔になることがあります。

	ＢＧＭフェードを切るのも手ですが、
	ＢＧＭの音量自体は下げたい場合、ＢＧＭフェードをかけっぱなしにするという手もあります。

<pre class="exp">
script.start_bgmfade       // ＢＧＭフェードかけっぱなしを開始する
script.end_bgmfade         // 終了する
</pre>

+ サンプル：自動演出中にＢＧＭフェードをかけっぱなしにする

<pre class="source">
// ＢＧＭフェードをかけっぱなしにする
script.start_bgmfade

// 声が自動で流れる演出（文章がないので exkoe を使うのが望ましい）
// ＢＧＭフェードのかけっぱなしがなければ、ＢＧＭの音量が上下しまくりで格好悪い
exkoe(100000001,001)    koe_wait    timewait(2000)
exkoe(100000002,001)    koe_wait    timewait(2000)
exkoe(100000003,001)    koe_wait    timewait(2000)
exkoe(100000004,001)    koe_wait    timewait(2000)
exkoe(100000005,001)    koe_wait    timewait(2000)

// ＢＧＭフェードのかけっぱなしを終了する
script.end_bgmfade
</pre>




■ 声

	声を再生するには koe コマンドを使います。
	通常 koe コマンドは、台本ツール一式により自動的に挿入されます。
	直接このコマンドを触ることは少ないです。
	詳しくは台本ツールのマニュアルを参照して下さい。

+ koe の特徴

	koe は特殊なコマンドです。以下のような特徴を持っています。

<ul>
- 環境設定の「声」のボリュームに従う
- 環境設定の「キャラクタ音声」のボリュームに従う
- 環境設定の「音声モード」に影響される
- 時短再生に影響される
- セリフの前につけることで「声リプレイ」ボタンで再生できる
- メッセージバックに登録される
- 声が再生されているとき、ＢＧＭの音量が「ＢＧＭフェード」に従って小さくなる
</ul>

	特殊なことをせずに単純に声を再生した場合は [[ＥＸ声]] を参照して下さい。

+ 声を再生する

<pre class="exp">
koe($koe_no)
koe($koe_no, $chara_no)
koe_play_wait($koe_no)                        // 再生終了待ち
koe_play_wait($koe_no, $chara_no)             // 再生終了待ち
a[0] = koe_play_wait_key($koe_no)             // 再生終了待ち（キーでスキップできる）
a[0] = koe_play_wait_key($koe_no, $chara_no)  // 再生終了待ち（キーでスキップできる）
</pre>

++ 引数

<ul>
- $koe_no: 声番号
- $chara_no: キャラクター番号
</ul>

++ 声番号

	再生される声の番号です。

++ キャラクター番号

	環境設定の「キャラクタ音声」などを制御します。
	「キャラクター１番の声のみをオフにする」と言ったことが可能になります。

++ 戻り値

	koe_play_wait_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

+ 声を停止する

<pre class="exp">
koe_stop
</pre>

	声を停止します。

+ 声の再生が終了するのを待つ

<pre class="exp">
koe_wait
a[0] = koe_wait_key                               // キーでスキップできる
</pre>

	声の再生が終了するのを待ちます。

	koe_wait_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

<div class="chips">
環境設定で声をオフにしていた場合、声が再生されないため、声を待たずに次に進んでしまいます。
</div>


+ 声の再生状態を取得する

<pre class="exp">
a[0] = koe_check
</pre>

	声の再生状態を取得します。（0=停止中、1=再生中、2=フェードアウト中）

<pre class="exp">
a[0] = koe_check_get_koe_no
a[0] = koe_check_get_chara_no
a[0] = koe_check_is_ex_koe
</pre>

	声が再生されている場合、その声の

- 声番号
- キャラクター番号
- ＥＸ声かどうか（0=通常の koe、1=exkoe）

	を取得します。

	声が再生されていない場合の値は不定です。
	必ず koe_check コマンドと合わせて使って下さい。

+ ボリュームを設定する

<pre class="exp">
koe_set_volume($volume)
koe_set_volume($volume, $time)
</pre>

	声のボリュームを 0～255 の範囲で設定します。
	0 にすると無音になります。
	$time を指定すると、指定した時間をかけてボリュームを変化させます。

+ ボリュームを最大／最小にする

<pre class="exp">
koe_set_volume_max
koe_set_volume_max($time)
koe_set_volume_min
koe_set_volume_min($time)
</pre>

	声のボリュームを最大／最小にします。
	$time を指定すると、指定した時間をかけてボリュームを変化させます。

+ ボリュームを取得する

<pre class="exp">
a[0] = koe_get_volume
</pre>

	声のボリュームを取得します。


■ ＥＸ声

	声を再生する場合、通常は koe コマンドを使います。
	単純に声を再生するには exkoe コマンドを使います。

+ exkoe の特徴

<ul>
- 環境設定の「声」のボリュームに従う
- 環境設定の「声」のチェックをオフにした場合も再生される
- 環境設定の「キャラクタ音声」のボリュームに従う
- 環境設定の「キャラクタ音声」をオフにした場合も再生される
- 環境設定の「音声なし」を選んでも再生される
- 時短再生を行わない
- 声リプレイに登録されない
- メッセージバックに登録されない
- <font color="red">ＢＧＭフェードは行われる</font>
</ul>

++ どういうときに使うの？

<ul>
- タイトル画面などでシステム音として声を再生するとき
- テキストを使わない声だけの演出を組むとき
</ul>

	基本的には、「メッセージの表示されない声」に使うといいです。

+ ＥＸ声を再生する

<pre class="exp">
exkoe($koe_no)
exkoe($koe_no, $chara_no)
exkoe_play_wait($koe_no)                         // 再生終了待ち
exkoe_play_wait($koe_no, $chara_no)              // 再生終了待ち
a[0] = exkoe_play_wait_key($koe_no)              // 再生終了待ち（キーでスキップできる）
a[0] = exkoe_play_wait_key($koe_no, $chara_no)   // 再生終了待ち（キーでスキップできる）
</pre>

	引数、戻り値については [[声]] の koe コマンドを参照して下さい。

+ ＥＸ声を停止する、待つ、…

	koe_stop、koe_wait などが使えます。詳しくは [[声]] を参照して下さい。


■効果音

	単純な効果音を再生します。RealLive の汎用バッファに当たります。
	連続して使うことで、複数の効果音を同時に鳴らすこともできます。
	ループなど高度なことをするためには、pcmch（[[効果音チャンネル]]）を使ってください。

<h4>効果音を再生する</h4>

<pre class="exp">
pcm.play($file_name)
</pre>

	効果音を鳴らします。

<h4>stop</h4>

<pre class="exp">
pcm.stop
</pre>

	pcm.play で再生された全ての効果音を停止します。
	pcmch で再生された効果音は停止されません。個別に停止して下さい。


■ 効果音チャンネル

	効果音を鳴らします。
	RealLive の専用バッファにあたります。
	ループ再生など高度な処理を行うことが出来ますが、
	１つのチャンネルにつき、同時に１つまでしか効果音を鳴らすことが出来ません。
	単純な効果音を鳴らすだけの場合は、pcm（[[効果音]]）を使ってください。

+ 効果音を再生する

<pre class="exp">
pcmch[0].play($name)
pcmch[0].play($name, $fade_in_time)
pcmch[0].play_wait($name)
pcmch[0].play_wait($name, $fade_in_time)
pcmch[0].play_loop($name)
pcmch[0].play_loop($name, $fade_in_time)
</pre>

<div class="table-container">
<table>
|play|効果音を鳴らします。|
|play_wait|効果音を鳴らし、鳴り終えるまで待ちます。|
|play_loop|効果音をループさせます。|
</table>
</div>

	$fade_in_time を指定すると、フェードインを行います。

+ 効果音を停止する

<pre class="exp">
pcmch[0].stop
pcmch[0].stop($fade_time)
</pre>

	効果音を停止します。$fade_time を指定すると、指定した時間でフェードアウトを行います。

+ 効果音が終了するのを待つ

<pre class="exp">
pcmch[0].wait
a[0] = pcmch[0].wait_key         // 決定キーでスキップできる
</pre>

	効果音が終了するのを待ちます。ループ再生を行っている時に、このコマンドを使っては行けません。（無限ループになってしまいます！）

	wait_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

+ 効果音のフェードアウトが終了するのを待つ

<pre class="exp">
pcmch[0].wait_fade
a[0] = pcmch[0].wait_fade_key    // 決定キーでスキップできる
</pre>

	フェードアウト中に使うと、効果音のフェードアウトが完了するのを待ちます。

	wait_fade_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

+ 効果音の再生状態を取得する

<pre class="exp">
a[0] = pcmch[0].check
</pre>

	演奏状態を取得します。（0=停止中、1=再生中、2=フェードアウト中）

+ ボリュームを設定する

<pre class="exp">
pcmch[0].set_volume($volume)
pcmch[0].set_volume($volume, $time)
</pre>

	効果音のボリュームを 0～255 の範囲で設定します。
	0 にすると無音になります。
	$time を指定すると、指定した時間をかけてボリュームを変化させます。

+ ボリュームを最大／最小に設定する

<pre class="exp">
pcmch[0].set_volume_max
pcmch[0].set_volume_max($time)
pcmch[0].set_volume_min
pcmch[0].set_volume_min($time)
</pre>

	効果音のボリュームを最大／最小にします。
	$time を指定すると、指定した時間をかけてボリュームを変化させます。

+ ボリュームを取得する

<pre class="exp">
a[0] = pcmch[0].get_volume
</pre>

	効果音のボリュームを取得します。


■ 効果音チャンネル（フルパラメータ）

	効果音チャンネルの play コマンドは、名前つき引数が使えます。

<pre class="exp">
pcmch[0].play({名前つき引数})
pcmch[0].play($file_name, {名前つき引数})
pcmch[0].play($file_name, $fade_in_time, {名前つき引数})

名前つき引数 = {file_name, bgm_name, koe_no, se_no, loop, wait, fade, volume_type, chara_no, bgm_fade_target}
</pre>

<ul>
- file_name

	再生する効果音のファイル名を指定します。
	以下の２つのコマンドは、どちらも "punch" を再生します。

<pre class="source">
pcmch[0].play("punch")               // "punch" を再生する
pcmch[0].play(file_name="punch")     // "punch" を再生する
</pre>

++ bgm_name

	Gameexe.ini で登録した BGM の登録名を使って効果音を再生することができます。
	<font color="red">ボリュームを BGM チャンネルに割り当てるには、volume_type=0 を同時に指定して下さい。</font>

++ koe_no（初期値=-1）

	声ファイルを使って効果音を再生することができます。
	<font color="red">ボリュームを声チャンネルに割り当てるには、volume_type=1 を同時に指定して下さい。</font>
	さらにボリュームをキャラクター音声に合わせるには、chara_no を指定して下さい。

<pre class="source">
// 声番号 101900040 の声を再生する
// 環境設定の「声」ボリュームに、「キャラクター音声」を１番に割り当てる
pcmch[0].play(koe_no=101900040, volume_type=1, chara_no=1)
</pre>

++ se_no（初期値=-1）

	設定ファイルで設定したシステム音番号から、効果音を再生することができます。
	<font color="red">ボリュームをシステム音チャンネルに割り当てるには、volume_type=3 を同時に指定して下さい。</font>

<pre class="source">
// システム音番号 2 番の音（キャンセル音）を再生する
// 環境設定の「システム音」ボリュームに割り当てる
pcmch[0].play(se_no=2, volume_type=3)
</pre>

++ loop（初期値=0）

	0=ループしない、1=ループする

++ wait（初期値=0）

	0=再生終了を待たない、1=再生終了を待つ

++ fade（初期値=0）

	フェードイン時間（0=フェードインしない）

++ volume_type（初期値=2）

	効果音は普通、環境設定の「効果音」のボリュームに従います。
	volume_type を設定すると、他のボリュームに従うことができます。
	ミニゲームの効果音として音声を鳴らす、
	各ボリュームのサンプル音を再生する、などに使って下さい。

	-1=全体、0=BGM、1=KOE（音声）、2=PCM（効果音）、3=SE（システム音）、4=MOV（ムービー）、16～31（汎用ボリューム）

	-1 を指定した場合、BGM、KOE、PCM、SE、MOV のいずれのボリュームにも従わず、全体ボリュームの設定にのみ従います。
	「全体ボリュームのサンプル音」を鳴らすのに使えます。それ以外に使うことはないと思います。

	汎用ボリュームについては [[汎用ボリューム]] を参照して下さい。

<pre class="source">
// 「全体ボリューム」のサンプル音を鳴らす
pcmch[0].play("sample", volume_type=-1)
</pre>

<pre class="source">
// 「声ボリューム」のサンプル音を鳴らす
pcmch[0].play("sample", volume_type=1)
</pre>

	サンプル音として「音声」を再生する場合は、[[ＥＸ声]] を使うほうが良いと思います。
	ＢＧＭフェードなどが適切に効きます。

++ chara_no（初期値=-1）

	キャラクター番号を指定します。
	設定すると、該当するキャラクター音声のボリュームに従います。

++ bgm_fade_source（初期値=0）

	1 を指定した場合、BGM フェードのソースとなります。
	この音が再生されている間、BGM フェードの設定に従って、BGM のボリュームが小さくなります。
	デフォルト値は 0 です。

++ bgm_fade_target（初期値=0）

	1 を指定した場合、BGM フェードのターゲットとなります。
	声が再生されている間、BGM フェードの設定に従ってこの音のボリュームが小さくなります。
	デフォルト値は 0 です。

++ bgm_fade2_target（初期値=0）

	1 を指定した場合、BGM フェードのターゲットとなります。
	声が再生されている間、無音になります。
	※ほとんどBGV用の設定となります。

</ul>


■ 効果音を準備する（再生遅延を抑える）

	上級者向けのコマンドです。

	効果音をあらかじめ準備しておくことで、再生遅延を少なくすることができます。
	画面演出と合わせるなど、１フレームのずれを気にする場合に使って下さい。

+ 効果音を準備する

<pre class="exp">
pcmch[0].ready($name)
pcmch[0].ready_loop($name)

pcmch[0].ready({名前つき引数})
pcmch[0].ready($file_name, {名前つき引数})

名前つき引数 = {file_name, koe_no, se_no, loop, volume_type, chara_no, bgm_fade_target}
</pre>

	使い方は play コマンドと同じです。
	ただし play_wait および引数の wait、fade はありません。
	次の resume コマンドを参照して下さい。

+ 準備した効果音を再生する

<pre class="exp">
pcmch[0].resume
pcmch[0].resume($fade_in_time)
pcmch[0].resume_wait
pcmch[0].resume_wait($fade_in_time)
</pre>

	ready コマンドで準備した効果音を再生します。

+ サンプル：効果音を準備する

	ＯＭＶムービーと効果音を準備し、同時に再生するサンプルです。

<pre class="source">
// ＯＭＶムービーと効果音を準備します。
front.object[0].create_movie(magic_wind01, 0, ready_only = 1, real_time = 1)
<font color="red">pcmch[0].ready(punch)</font>
準備しました。クリックで再生します。r close

// ＯＭＶムービーと効果音を開始します。
front.object[0].disp = 1
front.object[0].resume_movie
<font color="red">pcmch[0].resume</font>

// 効果音の終了を待ちます。
pcmch[0].wait_key

// ＯＭＶムービーと効果音を解放します。
pcmch[0].stop
front.object[0].init
</pre>



















■ 効果音イベント

	指定したイベント通りに効果音を再生する機能です。
	非同期で再生するので、再生を続けたまま次の処理に進むことが出来ます。

	効果音イベントは、初期値で１６個あります。<span class="mada">（Gameexe.ini で変更できます。）</span>

+ 効果音イベントを開始する

<pre class="exp">
pcmevent[0].start_oneshot([*], [*], ...)
pcmevent[0].start_oneshot($pcm_buf_no, [*], [*], ...)
    [*] = [$file_name, $wait_time]
    [*] = [$file_name, $min_wait_time, $max_wait_time]

pcmevent[0].start_loop([*], [*], ...)
pcmevent[0].start_loop($pcm_buf_no, [*], [*], ...)
    [*] = [$file_name, $wait_time]
    [*] = [$file_name, $min_wait_time, $max_wait_time]

pcmevent[0].start_random([*], [*], ...)
pcmevent[0].start_random($pcm_buf_no, [*], [*], ...)
    [*] = [$file_name, $probability, $wait_time]
    [*] = [$file_name, $probability, $min_wait_time, $max_wait_time]
</pre>

++ 使用例

<pre class="source">
pcmevent[0].start_oneshot(
    [sound00, 1000],               // sound00 を再生して、１秒待つ
    [sound01, 1000],               // sound01 を再生して、１秒待つ
    [sound02, 5000]                // sound02 を再生して、５秒待つ
)

pcmevent[0].start_random(
    0,                             // 効果音バッファ０番を使う
    [sound00, 40, 1000, 2000],     // sound00 を再生して、１～２秒の間ランダムで待つ（確率=40）
    [sound01, 40, 1000, 2000],     // sound01 を再生して、１～２秒の間ランダムで待つ（確率=40）
    [sound02, 20, 5000, 6000]      // sound02 を再生して、５～６秒の間ランダムで待つ（確率=20）
)
</pre>

++ 引数

<div class="table-container">
<table>
|$pcm_buf_no|使用する効果音バッファ番号（省略すると、汎用バッファを使用）|
|$file_name|ファイル名|
|$probability|再生確率|
|$min_wait_time|待ち時間（最小値）（ﾐﾘ秒）|
|$max_wait_time|待ち時間（最大値）（ﾐﾘ秒）|
</table>
</div>

++ oneshot, loop, random

	start_oneshot は、指定された効果音を、上から順に再生します。
	<br />start_loop は、指定された効果音を、上から順に繰り返し再生します。
	<br />start_random は、指定された効果音を、ランダムに繰り返し再生します。

++ バッファ番号

	バッファ番号を指定すると、指定した効果音バッファで効果音を再生します。
	省略すると、汎用バッファで再生します。

++ 待ち時間

	待ち時間は、「再生を開始してから、次の再生が始まるまでの待ち時間」です。
	最小値と最大値を指定した場合は、その範囲でランダムに待ち時間が決定されます。

	「再生が終わってから次の再生が始まるまでの待ち時間」を指定したい場合は、
	[[効果音イベント（フルパラメータ）]] を参照して下さい。

++ 再生確率

	start_random は、効果音ごとに再生確率を設定することが出来ます。
	ランダムで効果音が選ばれるとき、再生確率が大きいほど、選ばれる確率が高くなります。

+ 効果音イベントを停止する

<pre class="exp">
pcmevent[0].stop($pcm_stop)
</pre>

	効果音イベントを停止します。ただし、既に再生されている効果音は止まりません。
	$pcm_stop に 1 を指定すると、効果音ごと止めます。

<div class="chips">
oneshot 再生において stop(1) を使う場合は、最後の待ち時間を、効果音の長さよりも長く設定して下さい。
短くすると、音が終わる前にイベントが終わってしまうことがあります。
この場合、stop(1) を実行しても、効果音が止まりません。
<br /><br />ループ再生やランダム再生、またはフルパラメータ版で wait_type = 1 としている場合はこの問題は起きません。
</div>

+ 効果音イベントを待つ

<pre class="exp">
pcmevent[0].wait
a[0] = pcmevent[0].wait_key
</pre>

	効果音イベントが終了するまで待ちます。
	wait_key の場合、決定キーで処理をスキップできます。決定キーでスキップした場合は 1 が返ります。それ以外の場合は 0 が返ります。

+ 効果音イベントが再生中かどうかを調べる

<pre class="exp">
a[0] = pcmevent[0].check
</pre>

	効果音イベントが再生中かどうかを判定します。0=再生中でない、1=再生中



■ 効果音イベント（フルパラメータ）

	効果音イベントも、[[効果音チャンネル（フルパラメータ）]] に似た名前つき引数が使えます。

<pre class="exp">
pcmevent[0].start_oneshot($pcm_buf_no, [*], [*], ...)
    [*] = [$file_name, $wait_time]
    [*] = [$file_name, $min_wait_time, $max_wait_time]

pcmevent[0].start_loop($pcm_buf_no, [*], [*], ...)
    [*] = [$file_name, $wait_time]
    [*] = [$file_name, $min_wait_time, $max_wait_time]

pcmevent[0].start_random($pcm_buf_no, [*], [*], ...)
    [*] = [$file_name, $probability, $wait_time]
    [*] = [$file_name, $probability, $min_wait_time, $max_wait_time]

名前つき引数 = {volume_type, bgm_fade_target}
</pre>

	※名前つき引数を使う場合は、必ず専用バッファを使って下さい。
	$pcm_buf_no に -1 を指定して汎用バッファを使う場合は、名前つき引数は無視されます。

+ サンプル：ボリュームを BGM に合わせた効果音を順番に鳴らす

<pre class="source">
pcmevent[0].start_loop(
	0,                     // 必須です。専用バッファを使う必要があります。
	volume_type = 0,       // ボリュームを BGM に合わせます。
	bgm_fade_target = 1,   // BGM フェードのターゲットになります。
	["punch", 1000],
	["knock001", 1000], 
	["neko_damage", 1000]
</pre>

+ 名前つき引数

++ volume_type（初期値=2）

	-1=全体、0=BGM、1=KOE（音声）、2=PCM（効果音）、3=SE（システム音）、4=MOV（ムービー）、16～31（汎用ボリューム）

	デフォルト値は 2 です。詳しくは [[効果音チャンネル（フルパラメータ）]] を参照して下さい。

++ chara_no（初期値=-1）

	キャラクター番号を指定します。
	設定すると、該当するキャラクター音声のボリュームに従います。

++ bgm_fade_source（初期値=0）

	1 を指定した場合、BGM フェードのソースとなります。
	この音が再生されている間、BGM フェードの設定に従って、BGM のボリュームが小さくなります。

++ bgm_fade_target（初期値=0）

	1 を指定した場合、BGM フェードのターゲットとなります。
	声が再生されている間、BGM フェードの設定に従ってこの音のボリュームが小さくなります。

++ bgm_fade2_target（初期値=0）

	1 を指定した場合、BGM フェードのターゲットとなります。
	声が再生されている間、無音になります。
	※ほとんどBGV用の設定となります。

++ wait_type（初期値=0）

	wait_type = 0 の場合、待ち時間は「再生を開始してから、次の再生が始まるまでの待ち時間」です。
	最小値と最大値を指定した場合は、その範囲でランダムに待ち時間が決定されます。

	wait_type = 1 とした場合、待ち時間は、「再生が終わってから次の再生が始まるまでの待ち時間」になります。






















■ BGVについて

	BGV(バックグラウンドボイス)についての補足説明です。
	各命令の詳細は各命令のところを参照してください。

+ １ファイルで鳴らす場合

<pre class="source">
	pcmch[0].play($file_name, loop=1, volume_type = 16, bgm_fade2_target=1)
</pre>

	ファイル名を１つ指定し、ループさせています。
	音量は汎用に設定しているので、環境に合わせて変更してください。


+ 複数のファイルで鳴らす場合

<pre class="source">
	pcmevent[0].start_random(0,wait_type=1,volume_type = 1,bgm_fade2_target = 1,chara_no=5,
						[BGV_AA01, 100,500],
						[BGV_AA02, 100,500],
						[BGV_AA03, 100,500])
</pre>

	この例ではファイルを３つ指定し、ランダムに再生させています。
	音量設定は音声と同期させ、キャラ番号は「5」を指定しています。



■システム音

	Gameexe.ini で登録したシステム音を鳴らします。
	独自にメニュー画面を作成したときなどに使います。
	ゲーム中の演出には [[効果音]] や [[効果音チャンネル]] を使ってください。

<h4>システム音の特徴</h4>

<ul>
<li>環境設定の「システム音」のボリュームに従う</li>
<li>複数の音を同時に再生できる</li>
<li>「ロード」「タイトルに戻る」などで再生を止めない<br />※止めると格好悪いので止めません。</li>
</ul>

<h4>システム音を再生する</h4>

<pre class="exp">
se.play($se_no)
</pre>

	システム音を演奏します。$se_no には、Gameexe.ini で登録したシステム音の番号を指定します。

<h4>色々なシステム音を再生する</h4>

<pre class="exp">
se.play_by_file_name($file_name)             // ファイル名を指定してシステム音を鳴らす
se.play_by_koe_no($koe_no)                   // 声番号を指定してシステム音を鳴らす
se.play_by_se_no($se_no)                     // システム音番号を指定してシステム音を鳴らす
</pre>

	se.play_by_se_no は、se.play と同じコマンドです。

<h4>システム音を停止する</h4>

<pre class="exp">
se.stop
se.stop($fade_time)
</pre>

	システム音を停止します。$fade_time を指定すると、指定した時間でフェードアウトを行います。

<h4>システム音の再生が終了するのを待つ</h4>

<pre class="exp">
se.wait
se.wait_key
</pre>

	全てのシステム音が終了するまで待ちます。

<h4>システム音の再生状態を取得する</h4>

<pre class="exp">
a[0] = se.check
</pre>

	システム音の再生状態を取得します。（0=停止中、1=再生中、2=フェードアウト中）

<h4>ボリュームを設定する</h4>

<pre class="exp">
se.set_volume($volume)
se.set_volume($volume, $time)
</pre>

	システム音のボリュームを 0～255 の範囲で設定します。
	0 にすると無音になります。
	$time を指定すると、指定した時間をかけてボリュームを変化させます。

<h4>ボリュームを最大／最小に設定する</h4>

<pre class="exp">
se.set_volume_max
se.set_volume_max($time)
se.set_volume_min
se.set_volume_min($time)
</pre>

	システム音のボリュームを最大／最小にします。
	$time を指定すると、指定した時間をかけてボリュームを変化させます。

<h4>ボリュームを取得する</h4>

<pre class="exp">
a[0] = se.get_volume
</pre>

	システム音のボリュームを取得します。


■ ムービー

+ ムービーを再生する

<pre class="exp">
mov.play($file_name)            // ムービーを再生する
mov.play_wait($file_name)       // ムービーを再生し、再生終了まで待つ
a[0] = mov.play_wait_key($file_name)   // ムービーを再生し、再生終了まで待つ（キー入力でスキップできる）

<div class="mada">
mov.play($file_name, $x, $y, $w, $h)            // ムービーを再生する（サイズ指定）
mov.play_wait($file_name, $x, $y, $w, $h)       // ムービーを再生し、再生終了まで待つ（サイズ指定）
a[0] = mov.play_wait_key($file_name, $x, $y, $w, $h)   // ムービーを再生し、再生終了まで待つ（サイズ指定）（キー入力でスキップできる）
</div>
</pre>

	play_wait_key の場合、キーでムービー待ちをスキップできます。
	決定キーまたはキャンセルキーでスキップした場合は 1 または -1 が返ります。最後まで再生した場合は 0 が返ります。 

++ ＯＰムービーを再生する

	ＯＰムービーなどは、２回目以降はスキップできるようにすると親切です。

<pre class="source">
if (g[0000] == 0)   {
    mov.play_wait("OP00")
    g[0000] = 1
}
else    {
    mov.play_wait_key("OP00")
}
</pre>

+ ムービーを停止する

<pre class="exp">
mov.stop
</pre>



■ 汎用ボリューム

	Siglus には、0=BGM、1=KOE（声）、2=PCM（効果音）、3=SE（システム音）、4=MOV（ムービー）の５つのボリュームがあります。

	ところが、バックグラウンドで流れる声を表現するとき、上記のどれでもない新しいボリュームが欲しいことがありました。

	そのために Siglus では、内部では 32 個のボリュームを持っています。
	そのうち 16 番以降を、汎用ボリュームとして自由に使うことができます。
	（ボリューム 5～15 はシステムが予約しています。）

<div class="table-container">
<table>
<caption>ボリュームチャンネル</caption>
|番号|タイプ|
|0|BGM|
|1|KOE（声）|
|2|PCM（効果音）|
|3|SE（システム音）|
|4|MOV（ムービー）|
|5～15|（予約）|
|16～31|汎用ボリューム|
</table>
</div>

	効果音のボリュームを汎用ボリュームに合わせるには、
	[[効果音チャンネル（フルパラメータ）]] の volume_type を 16～31 に合わせて下さい。

	汎用ボリュームのボリュームやオンオフを設定するには、
	[[環境設定]] の音量設定を参考にして下さい。

++ 効果音を汎用ボリュームで再生する

<pre class="source">
// 効果音チャンネル 0 番で効果音を、汎用ボリューム 16 番に合わせて再生する
pcmch[0].play("sound00", volume_type = 16)
</pre>

++ 汎用ボリュームの音量を設定する

	汎用ボリュームはグローバルに保存されます。
	環境設定画面などでユーザーが操作できるように組んで下さい。

<pre class="source">
// ボリューム 16 番のボリュームを 64 に設定する
syscom.set_sound_volume(16, 64)
</pre>






■ ＣＧテーブル

	ＣＧを見た／見てないを調べる機能です。
	ＣＧ鑑賞モードを簡単に作ることができます。

	ＣＧテーブルを使うには、CGTablePack.exe で mode.cgm を作成し、
	設定ファイルに登録しておく必要があります。
	詳しくは CGTablePack のマニュアル、および [[ＣＧテーブルの設定]] を参照して下さい。

+ 一時的にＣＧテーブルの機能をオフにする／解除する

<pre class="exp">
cgtable.set_disable                            // 一時的に機能をオフにする
cgtable.set_enable                             // 解除する
</pre>

+ 見た／見てないフラグを取得する

<pre class="exp">
a[0] = cgtable.get_look_by_name($file_name)    // 名前から取得する
</pre>

	戻り値: 0=見てない、1=見た、-1=登録されていない

+ 見た／見てないフラグを設定する

<pre class="exp">
cgtable.set_look_by_name($file_name, $look)    // 名前から設定する
</pre>

	$look: 0=見てない、1=見た

+ 全てのＣＧを見た／見てない状態にする

<pre class="exp">
a[0] = cgtable.set_all_flag($look)
</pre>

	全てのＣＧを見た／見ていない状態にします。
	デバッグ時に使うことが多いと思いますが、
	リリース時にコメントアウトし忘れることが多いので注意して下さい。

	$look: 0=見てない、1=見た

+ 登録されているＣＧの枚数を取得する

<pre class="exp">
a[0] = cgtable.get_cg_cnt
</pre>

+ 見たＣＧの枚数を取得する

<pre class="exp">
a[0] = cgtable.get_look_cnt
</pre>

+ 見たＣＧの数をパーセントで取得する

<pre class="exp">
a[0] = cgtable.get_look_percent
</pre>





■ ＣＧテーブル（フラグを直接扱う）

+ ＣＧテーブルフラグ

<pre class="exp">
cgtable.flag
</pre>

	ＣＧテーブルは、ＣＧを見た／見てないを専用のフラグ（cgtable.flag）で管理しています。
	cgtable.flag は、aフラグなどと同様の、整数型のフラグです。
	他のフラグと同様に演算、代入などができます。ビットフラグにも対応しています。

	通常は [[ＣＧテーブル]] の簡易コマンドで事足りると思います。
	こちらの方が使いやすい場合は使って下さい。

++ フラグの値

	ＣＧを見てない=0、ＣＧを見た=1

+ ＣＧに割り当てられているフラグの番号を取得する

<pre class="exp">
a[0] = cgtable.get_flag_no_by_name($file_name)       // 名前から取得する
</pre>

<div class="table-container">
<table>
|cgtable.get_flag_no_by_name(CG001) == 3|cgtable.flag[3] == 0 なら見てない、cgtable.flag[3] == 1 なら見た|
|cgtable.get_flag_no_by_name(CG001) == 5|cgtable.flag[5] == 0 なら見てない、cgtable.flag[5] == 1 なら見た|
|cgtable.get_flag_no_by_name(CG001) == -1|CG001 は登録されていない|
</table>
</div>

+ フラグ番号からＣＧのファイル名を取得する

<pre class="exp">
s[0] = cgtable.get_name_by_flag_no($flag_no)
</pre>

+ フラグの使い方の例

<pre class="source">
cgtable.flag[0] = 1                 // フラグに 1 を代入
a[0] = cgtable.flag[0]              // フラグの値を a[0] に代入
a[0] = cgtable.flag.bit1[0]         // ビットフラグ
</pre>

++ サンプル：ＣＧを見た／見てないで分岐する

<pre class="source">
// CG001 に割り当てられているフラグ番号を取得する
a[0] = cgtable.get_flag_no_by_name(CG001)

// フラグが 0（=見ていない）か 1（=見た）で分岐
if (cgtable.flag[a[0]] == 1)    {
    // ＣＧを見たときの処理
}
else    {
    // ＣＧを見ていないときの処理
}
</pre>


■ ＢＧＭテーブル

	ＢＧＭを聴いた／聴いていないを調べる機能です。
	ＢＧＭ鑑賞モードを簡単に作ることができます。

	ＢＧＭテーブルはＣＧテーブルと違い、mode.cgm のような特殊なファイルを作る必要はありません。

+ 聴いた／聴いていないフラグを取得する

<pre class="exp">
a[0] = bgmtable.get_listen_by_name($file_name)
</pre>

	戻り値: 0=聴いていない、1=聴いた、-1=登録されていない

	名前はファイル名ではなく、Gameexe.ini の「登録名」で指定することに注意して下さい。

+ 聴いた／聴いていないフラグを設定する

<pre class="exp">
bgmtable.set_listen_by_name($file_name, $listen)
</pre>

	$listen: 0=聴いていない、1=聴いた

	名前はファイル名ではなく、Gameexe.ini の「登録名」で指定することに注意して下さい。

+ 全てのＢＧＭを聴いた／聴いていない状態にする

<pre class="exp">
a[0] = bgmtable.set_all_flag($listen)
</pre>

	全てのＢＧＭを聴いた／聴いていない状態にします。
	デバッグ時に使うことが多いと思いますが、
	リリース時にコメントアウトし忘れることが多いので注意して下さい。

	$listen: 0=聴いていない、1=聴いた

+ 登録されているＢＧＭの枚数を取得する

<pre class="exp">
a[0] = bgmtable.get_bgm_cnt
</pre>




■ データベースについて

	文字通りデータベースを作る機能です。
	アイテムやモンスターなどの情報をデータベース化して利用します。
	Microsoft Excel を使って作成できます。

+ データベースの作り方

<ul>
- Excel を使ってデータベースを作成する
- csv 形式で保存する
- CSV2DBS.exe を使って csv → dbs にコンバートする
- Gameexe.ini に dbs を登録する
</ul>

+ ステップ１：データベースを作成する

	データベースは Excel を使って作成します。
	以下の説明は、サンプルを見ながら読むと分かりやすいと思います。
	（→ ◇02_ツール\◇04_データ作成\CSV2DBS_データベース作成\サンプルデータ）

++ アイテム番号とコラム番号

	データベースには、アイテム番号とコラム番号が必要です。
	「Ａ」の列にある数値がアイテム番号です。
	「#DATANO」と書いてあるの行にある数値がコラム番号です。
	スクリプトではこれらの番号を指定することでデータを呼び出します。
	（例：「ともよ」を取り出すには、アイテム番号 = 4、コラム番号 = 1 を指定します。）
	番号は 0～2147483647 の範囲の整数です。
	アイテム番号がない行やコラム番号がない列のデータは取り出すことができません。
	逆に言えば、それらの行や列には、何を書いても構いません。コメントなどを書き込んで下さい。
	サンプルの「★プレイヤー」「名前」などは、アイテム番号がないため、コメントとして扱われます。

++ データタイプ

	データには、整数データと文字列データがあります。
	整数データは A,B,C,D,E,F,G,H,I,J,L,Z フラグに、
	文字列データは、RealLive の S,M,K フラグに読み込むことができます。
	コマンド「#DATATYPE」の行にある文字がデータタイプを表します。
	データタイプに V を指定したコラムのデータは整数データに、
	S を指定したコラムのデータは文字列データになります。

<img src="database_pic.png">

+ ステップ２：csv 形式で保存

	Excel で「ファイル」→「名前をつけて保存」→
	ファイルの種類を「CSV (カンマ区切り) (*.cvs)」を選んで保存すると、
	csv 形式でファイルを保存できます。

+ ステップ３：コンバート

	CSV2DBS を使って、csv ファイルを dbs ファイルにコンバートします。

+ ステップ４：Gameexe.ini に登録

	Gameexe.ini の #DATABASE_FILENAME に、dbs ファイルを登録します。

<pre class="source">
#DATABASE.CNT = 2
#DATABASE.000 = "database000.dbs"
#DATABASE.001 = "database001.dbs"
...
</pre>


■ データベース

<pre class="exp">
a[0] = database[$database_no].get_num($item_no, $column_no)   
s[0] = database[$database_no].get_str($item_no, $column_no)

a[0] = database[$database_no].check_item($item_no)
    // データベースにアイテムがあるかを調べる（0=存在しない、1=存在する）

a[0] = database[$database_no].check_column($column_no)
    // データベースにコラムがあるかを調べる（0=存在しない、1=整数コラム、2=文字列コラム）

a[0] = database[$database_no].find_num($column_no, $num)
    // アイテムを整数データから検索する

a[0] = database[$database_no].find_str($column_no, $str)
    // アイテムを文字列データから検索する（大文字小文字を区別しない）

a[0] = database[$database_no].find_str_real($column_no, $str)
    // アイテムを文字列データから検索する（大文字小文字を区別する）
</pre>

	データベースについては [[データベースについて]] を参照して下さい。

++ 引数

<div class="table-container">
<table><tr>
|$database_no|Gameexe.ini に登録したデータベース番号|
|$item_no|データベースのアイテム番号（行）|
|$column_no|データベースのコラム番号（列）|
</tr></table>
</div>

++ find_str_real 補足

	find_str_real は、アルファベットの半角全角を区別します。
	find_str_real を使う場合は、文字列を常にダブルコーテーションで括る必要があります。

<pre class="source">
a[0] = database[0].find_str_real(0, "AbCdE")
</pre>

<pre class="source">
s[0] = "AbCdE"
a[0] = database[0].find_str_real(0, s[0])
</pre>



■決定キーとキャンセルキー

	マウスやキーボードの入力を管理するには、input を使います。

<h4>キーの種類</h4>

	Siglus には、次の２つのキーがあります。

<pre class="exp">
input.decide    // 決定キー（マウス左、Enter キーなど）
input.cancel    // キャンセルキー（マウス右、Esc キーなど）
</pre>

<h4>キーの操作</h4>

	独自のメニュー画面などを作る場合は、
	「決定キーを押した場合の処理」などを自分で記述する必要があります。
	決定キーを使った例を示します。

<pre class="source">
input.clear
while (1)  {

    if (input.decide.on_down == 1)  {
        <font color="green">// 決定キーを押したときの処理</font>
        <font color="green">// ボタンを押したときの効果音を鳴らしたりなどの処理を書きます。</font>
    }
    if (input.decide.is_down == 1)  {
        <font color="green">// 決定キーが押されている間の処理</font>
        <font color="green">// つかんで動かせるボタンなどの場合は、ここの処理が重要です。</font>
    }
    if (input.decide.on_down_up == 1)  {
        <font color="green">// 決定キーを押して放したときの処理</font>
        <font color="green">// ボタンが選択されたときの処理を書きます。</font>
    }

    <font color="green">// 入力の状態を更新します。必ず disp の直前に置いて下さい！</font>
    input.next

    <font color="green">// 画面を更新します。</font>
    disp
}
</pre>

	on_down などのコマンドを使って、キーが押されたかどうかを判定することが出来ます。

	on_down は、キーが押された時に 1 になります。next を実行することで、0 に戻ります。
	disp によって画面が更新されますが、その間にキーが押されると、再び on_down が 1 になります。
	必ずループ内では、「キーが押されたとき（放されたときの）処理」→「input.next」→「disp」の順に行って下さい。

	ループの最初では、必ず input.clear を行ってください。

<h4>マウスやキーボードを個別に扱う</h4>

	ほとんどの処理は、決定キーとキャンセルキーだけで十分です。
	まれに、マウスとキーボードを個別に扱いたい場合があります。
	その場合は次のキーを使って下さい。

<pre class="exp">
mouse.left      // マウス左（決定キーとは区別されます。あまり使うことはないと思います。）
mouse.right     // マウス右（キャンセルキーとは区別されます。あまり使うことはないと思います。）
key[$key_no]    // キーボードの各種キー（$key_no: キーコード）
</pre>

	詳しくは [[マウス]]、[[キーボード]] を参照して下さい。














■ マウス

	マウスの情報を取得します。

+ マウスの持つキー

<pre class="source">
mouse.left
mouse.right
</pre>

	マウスのキー情報を使うことは滅多にありません。
	通常は、「決定キー」「キャンセルキー」などを使います。
	詳しくは [[決定キーとキャンセルキー]] を参照して下さい。

+ マウスの位置を取得する

<pre class="exp">
a[0] = mouse.get_pos_x     // Ｘ座標を取得
a[1] = mouse.get_pos_y     // Ｙ座標を取得
mouse.get_pos($x, $y)      // 一度に取得
</pre>

<div class="chips">
mouse.pos_x、mouse.pos_y でも座標を取得できます。
</div>

++ サンプル：マウスの座標を取得する

<pre class="source">
mouse.get_pos(a[0], a[1])
</pre>

+ マウスの位置を設定する

<pre class="exp">
mouse.set_pos($x, $y)      // 一度に設定
</pre>

	メニューを出したときに、メニューの先頭に自動的にマウスを動かしたい場合があると思います。
	そのときに使って下さい。
	ただし、自動で移動するのを好まないユーザもいます。
	メニューを閉じたときに元の位置に戻す、もしくは
	自動で動かす機能を ON/OFF できる、などの配慮が必要かも知れません。

+ ホイールの値を取得する

<pre class="exp">
a[0] = mouse.wheel
</pre>

	マウスのホイールの回転数を取得するコマンドです。（マイナス=上方向、プラス=下方向）

	ホイールの値を取得するには、キーと同様、clear や next と組み合わせて使う必要があります。

<pre class="source">
mouse.clear
while (1)  {

    if (mouse.wheel > 0)  {
        // ホイールを下方向に回したときの処理
    }
    if (mouse.wheel < 0)  {
        // ホイールを上方向に回したときの処理
    }

    mouse.next
    disp
}
</pre>

+ マウスの状態のみをクリアする

<pre class="exp">
mouse.clear
</pre>

	マウスの状態のみをクリアします。通常は input.clear を使います。

+ マウスの状態のみを更新する

<pre class="exp">
mouse.next
</pre>

	マウスの状態のみを更新します。通常は input.next を使います。









■ キーボード

	キーボードの情報を取得します。

	キーボードのみの情報を使うことは滅多にありません。
	通常は、「決定キー」「キャンセルキー」などを使います。
	詳しくは [[決定キーとキャンセルキー]] を参照して下さい。

+ キーボードの持つキー

<pre class="source">
key[$key_code]   // $key_code: キーコード
</pre>

	キーコードについては、[[キーコード]] を参照して下さい。

++ 例

<ul>
- key[13]: キーボードの Enter キー
- key['A']: キーボードの A キー
</ul>

++ キーボードの状態のみをクリアする

<pre class="exp">
key.clear
</pre>

	キーボードの状態のみをクリアします。通常は input.clear を使います。

+ キーボードの状態のみを更新する

<pre class="exp">
key.next
</pre>

	キーボードの状態のみを更新します。通常は input.next を使います。


■ エディットボックス

	エディットボックスを使って、名前などを入力させることができます。

	エディットボックスは初期設定で４つあります（editbox[0]～editbox[3]）。
	個数は設定ファイルで変更できます。詳しくは [[エディットボックスの設定]] を参照して下さい。

<pre class="exp">
editbox[0].create($x, $y, $w, $h, $moji_size)    // エディットボックスを作成する
editbox[0].destroy            // エディットボックスを破壊する
editbox[0].set_text($str)     // エディットボックスのテキストを設定する
s[0] = editbox[0].get_text    // エディットボックスのテキストを取得する
editbox[0].set_focus          // エディットボックスにフォーカスを設定する
editbox[0].check_decided      // Enter キーによる決定を取得する（0=決定されていない、1=決定された）
editbox[0].check_canceled     // ESC キーによるキャンセルを取得する（0=キャンセルされていない、1=キャンセルされた）
editbox[0].clear_input        // エディットボックスの決定／キャンセルを初期化する
</pre>

+ Tab キーでのフォーカスの移動について

	Tab キーでフォーカス（入力カーソル）を切り替えられます。
	切り替わる順は、editbox[0], editbox[1], ... の順です（最後まで行くと 0 に戻ります）。
	エディットボックスを複数並べるときは、必ず Tab キーでの移動テストをして下さい。

+ フォーカスの設定

	エディットボックスを複数作った場合、
	必ず、適切なエディットボックスにフォーカスを設定して下さい。

+ Enter キー、ESC キーの取得

	それぞれ、check_decided、check_canceled コマンドで取得できます。
	１度キーを押すと、これらの値は１になったままになります。
	０に戻すには clear_input コマンドを使って下さい。

<div class="chips">
(2010/10/5) Enter キーや ESC キーを押したとき、Windows の警告音が鳴っていましたが、
Ver.1.0.2.6 以降では鳴らなくなりました。
音を鳴らしたい場合は se.play コマンドなどで自分で鳴らして下さい。
</div>

+ サンプルについて

	「エディットボックスを使った名前の入力」に、複数のエディットボックスを使ったサンプルがあります。
	また、セーブ／ロード画面にも、メモ機能としてエディットボックスを使っています。






■ マウスカーソルを非表示にする

+ 一時的にマウスカーソルを非表示にする／解除する

<pre class="exp">
script.set_mouse_disp_off           // 一時的にマウスカーソルを非表示にする
script.set_mouse_disp_on            // 解除する
</pre>

	一時的にマウスカーソルを非表示にします。





■ マウスカーソル制御

+ マウスカーソルを一時的に変更する

<pre class="exp">
script.set_cursor_no($cursor_no)
a[0] = script.get_cursor_no
</pre>

	Gameexe.ini で登録したマウスカーソル番号を指定して下さい。

	このカーソルはセーブデータに保存されます。
	環境設定画面で変更する、などのグローバルな用途には向きません。
	章ごとに変更するなどの用途に使って下さい。



■ マウスカーソルを自動で隠す機能

+ 一時的にマウスカーソルを自動で隠す機能のオンオフを設定する

<pre class="exp">
script.set_mouse_cursor_hide_onoff($onoff)   // 一時的にマウスカーソルを自動で隠す機能のオンオフを設定する
script.set_mouse_cursor_hide_onoff_default   // 一時的にマウスカーソルを自動で隠す機能のオンオフを初期化する
a[0] = script.get_mouse_cursor_hide_onoff    // 一時的にマウスカーソルを自動で隠す機能のオンオフを取得する
</pre>

	環境設定の「一時的にマウスカーソルを自動で隠す機能のオンオフ」の値を一時的に変更します。

	<font color="red">
	この設定のデフォルト値は -1（環境設定に従う）です。（他のコマンドとは仕様が異なりますので注意！）
	初期化するときは必ず script.set_mouse_cursor_hide_onoff_default を使って下さい。
	</font>

+ 一時的にマウスカーソルを自動で隠す機能の時間を設定する

<pre class="exp">
script.set_mouse_cursor_hide_time($time)     // 一時的にマウスカーソルを自動で隠す機能の時間を設定する
script.set_mouse_cursor_hide_time_default    // 一時的にマウスカーソルを自動で隠す機能の時間を初期化する
a[0] = script.get_mouse_cursor_hide_time     // 一時的にマウスカーソルを自動で隠す機能の時間を取得する
</pre>

	環境設定の「一時的にマウスカーソルを自動で隠す機能の時間」の値を一時的に変更します。

	<font color="red">
	この設定のデフォルト値は -1（環境設定に従う）です。（他のコマンドとは仕様が異なりますので注意！）
	初期化するときは必ず script.set_mouse_cursor_hide_time_default を使って下さい。
	</font>




■ キー操作でマウスを動かす機能を無効にする

+ 一時的にキー操作でマウスを動かす機能を無効にする／解除する

<pre class="exp">
script.set_mouse_move_by_key_disable      // 一時的にキー操作でマウスを動かす機能を無効にする
script.set_mouse_move_by_key_enable       // 解除する
</pre>

	一時的にキー操作でマウスを動かす機能を無効にします。




■ 特定のキー操作を無効にする

+ 一時的に特定のキーを無効にする／解除する

<pre class="exp">
script.set_key_disable($key_code)
script.set_key_enable($key_code)
</pre>

	一時的に、特定のキー操作によるシステム操作を無効にします。

	たとえば、タイピングゲームを作ったとします。
	この場合、「'O' キーを押すと ss ファイルを開く」機能などは邪魔になります。
	このコマンドを使って、キーのシステム機能を個別にオフにすることができます。

	キーコードについては [[キーコード]] を参照して下さい。

+ サンプル：'O' キーを押すと次に進む処理を作る

<pre class="source">
input.clear

// 'O' キーの機能をオフにする
// 'O' キーのキーコードは 79
script.set_key_disable(79)
while (1)	{

	/* 何らかの処理… */

	// 'O' キーを押すとループを抜ける
	l[0] = key[79].on_down
	if (l[0] == 1)	{break}

	input.next
	disp
}
</pre>



■ 早送り制御

+ 一時的に早送りを禁止する／解除する

<pre class="exp">
script.set_skip_disable             // 一時的に早送りを禁止する
script.set_skip_enable              // 解除する
script.set_ctrl_skip_disable        // 一時的に早送りを禁止する（Ctrl キーを含む）
script.set_ctrl_skip_enable         // 解除する

// フラグで制御する場合
script.set_skip_disable_flag($onoff)
a[0] = script.set_skip_disable_flag
script.set_ctrl_skip_disable_flag($onoff)
a[0] = script.set_ctrl_skip_disable_flag
</pre>

	一時的に早送りを禁止します。

++ 早送りについて

	早送りには、「Ctrl キーによる早送り」と、システムコマンドによる「既読早送り」があります。
	script.set_skip_disable の場合は「既読早送り」だけが禁止されます。
	script.set_ctrl_skip_disable の場合は「Ctrl キーによる早送り」「既読早送り」の両方が禁止されます。

	日の変わりの演出などは、「既読早送り」時は飛ばさないほうが親切だと思います。（好みによりますが…）
	この場合は script.set_skip_disable を使ってください。

	エンドロールなど、音楽と同期をとる演出は、早送りすると崩れてしまいます。
	また、ゲーム開始時の注意書きなどは、早送りされると困ります。
	こういった場合は、script.set_ctrl_skip_disable を使ってください。

+ 早送りを判定する

<pre class="exp">
a[0] = script.check_skip            // 早送りを判定する
</pre>

	Ctrl スキップ、既読早送り、などの理由で早送り中かどうかを判定します。0=早送り中でない、1=早送り中

+ 一時的に「クリックで早送りを止める機能」を無効にする／解除する

<pre class="exp">
script.set_stop_skip_by_key_disable             // 一時的に「キーで早送りを止める機能」を無効にする
script.set_stop_skip_by_key_enable              // 解除する
</pre>

	早送りは、キーを押すことで止まります。

	メニュー操作中など、キーを押しても早送りを止めたくない場合があります。
	その場合はこのコマンドで、「キーで早送りを止める機能」を無効にして下さい。
	メニュー処理が終わったら解除するのを忘れないで下さい。


+ 一時的に「未読でも早送り可能にする」機能を設定／取得する

<pre class="exp">
script.set_skip_unread_message_flag($onoff)		// 0=オフ、1=オン
a[0] = script.get_skip_unread_message_flag		// 0=オフ、1=オン
</pre>

	未読文章は普通は早送りできませんが、
	この機能を使うことで早送りできるようになります。

	あまり使うことのない機能だと思います。
	メッセージウィンドウの「既読早送り」ボタンを強制的に有効にしたいことがあったので実装しました。

	ボタンを強制的に無効にする場合は、[[メッセージウィンドウボタン制御]] を使って下さい。








■ セーブポイント

<h4>セーブポイントとは？</h4>

	セーブを行ったとき、ファイルに保存されるのは「現在の状態」ではありません。
	「セーブポイントを立てたときの状態」です。

<pre class="source">
savepoint              // [1] ここでセーブポイントを立てます。

/* 処理 */

/* ここでセーブする */ // [2] ここでセーブします。[1] の時点での状態がセーブされます。
                       // このデータをロードした場合、[1] の位置から処理が再開されます。
/* 処理 */
</pre>

	セーブポイントが設定されていないとセーブを行うことはできません。

	セーブポイントは通常、メッセージや選択肢の先頭で自動的に設定されるため、意識する必要はありません。
	スクリプトで選択肢を組んだ時などに必要になります。


+ セーブポイントを設定する

<pre class="exp">
a[0] = savepoint
</pre>

	セーブポイントを設定します。

	セーブポイントはメッセージや選択肢の先頭で自動的に設定されるので、
	このコマンドを使う機会はあまりありません。
	どんな時に使うかと言いますと、自力で選択肢などを作る時に使います。

<div class="chips">
セーブポイントの戻り値については、[[ロード直後を判定する]] を参照して下さい。
</div>

<pre class="source">
// メッセージを表示すると、自動でセーブポイントが設定されます。
メッセージを表示します。r

// 自力で選択肢を作成します。
// この場合は savepoint コマンドでセーブポイントを設定します。
<font color="red"><b>savepoint</b></font>

//
// ここに自分で作った選択肢を入れます
//

// メッセージを表示すると、自動でセーブポイントが設定されます。
メッセージを表示します。r
</pre>

	実際は、選択肢ポイントも設定する必要があります。[[選択肢ポイント]] を参照して下さい。

+ セーブポイントをクリアする

<pre class="exp">
clear_savepoint
</pre>

+ セーブポイントが立っているかを判定する

<pre class="exp">
a[0] = check_savepoint
</pre>

	0=立っていない、1=立っている






■ 選択肢ポイント

<h4>選択肢ポイントとは？</h4>

	選択肢ポイントは、「前の選択肢に戻る」で戻るスクリプトの位置です。

<h4>選択肢ポイントを設定する</h4>

<pre class="exp">
selpoint
</pre>

	現在のセーブポイントの位置に選択肢ポイントを設定します。
	選択肢ポイントは sel コマンドなどで自動的に設定されるので、
	このコマンドを使う機会はあまりありません。
	どんな時に使うかと言いますと、自力で選択肢などを作る時に使います。

	selpoint は、「現在のセーブポイントの位置」に選択肢ポイントを設定するコマンドです。
	selpoint コマンドを入れる位置は注意が必要です。

<pre class="source">
// 選択肢の前にセーブポイントを置きます。
// 「前の選択肢に戻る」を使った場合、ここに戻ってきます。
<font color="red"><b>savepoint</b></font>

// まだ selpoint を置いてはいけません。
// 選択中に「前の選択肢に戻る」を選んだ場合、戻るべき位置は「１つ前の選択肢」です。
// ここに selpoint を置くと、ここに戻ってきてしまいます。

//
// ここに自分で作った選択肢を入れます
//

// selpoint を使うタイミングは、「選択終了後」のここです。
<font color="red"><b>selpoint</b></font>

// メッセージを表示します。
選択を終了します。r
</pre>

+ 選択肢ポイントをクリアする

<pre class="exp">
clear_selpoint
</pre>

+ 選択肢ポイントが立っているかを判定する

<pre class="exp">
a[0] = check_selpoint
</pre>

	0=立っていない、1=立っている



■ 選択肢ポイントスタック

	専用コマンドです。あまり使うことはないと思います。

	選択肢ポイントを１つだけ記憶しておくことができます。

<pre class="exp">
	stack_selpoint		// 選択肢ポイントを記憶しておく
	drop_selpoint		// 記憶した選択肢ポイントを降ろす
</pre>

	通常、選択肢ポイントは次のように使います。
	[[選択肢ポイント]] を参照して下さい。

<pre class="source">
	savepoint

	/* グラフィカルな選択肢 */

	selpoint
</pre>

	ところが、このグラフィカルな選択肢の部分で、
	メッセージ処理などセーブポイントが設定される処理を入れたいことがありました。
	この場合、選択肢ポイントを余分に記憶しておく必要があります。

<pre class="source">
	savepoint
	stack_selpoint		// 選択肢ポイントを作成し、積んでおく

	/* グラフィカルな選択肢 */
	/* 途中でメッセージ処理なども行う */

	drop_selpoint		// 積んである選択肢ポイントを降ろしてくる
</pre>




■ ロード直後を判定する

	セーブポイントを立てたときと、そのデータをロードした時で、
	処理を分けたいことがあります。

	たとえばドラクエのようなＲＰＧだと、データをロードした場合のみ、
	「よくぞ戻った勇者よ！」といったメッセージが表示されます。

	このためには、ロード直後を判定する必要があります。

	ロード直後を判定するには、savepoint の戻り値を使います。
	[[セーブポイント]] を参照して下さい。

+ savepoint の戻り値

<pre class="exp">
a[0] = savepoint
</pre>

	0=ロード直後でない、1=ロード直後

+ サンプル：ロードした場合のみメッセージを表示する

++ 失敗例

<pre class="source">
セーブしますか？r
l[0] = sel("はい", "いいえ")

// 「はい」を選んだ場合
if (l[0] == 0)	{

    a[0] = savepoint        // セーブポイントを立てます。

    capture                 // サムネイルを作る必要がある場合はここで作りましょう。
    syscom.save(0, 0, 1)    // セーブ番号０番にセーブします。

    セーブしました。r
}
</pre>

	この例では、このデータをロードした場合、
	すぐに「セーブしました」と表示されてしまい、不自然です。

++ 成功例

<pre class="source">
セーブしますか？r
l[0] = sel("はい", "いいえ")

// 「はい」を選んだ場合
if (l[0] == 0)	{

    a[0] = savepoint            // セーブポイントを立てます。

    // ロード直後の場合はここを通る
    if (a[0] == 1)	{

        ロードしました。r
    }

    // 通常はここを通る
    else	{

        capture                 // サムネイルを作る必要がある場合はここで作りましょう。
        syscom.save(0, 0, 1)    // セーブ番号０番にセーブします。

        セーブしました。r
    }
}
</pre>

	セーブした場合は「セーブしました」、
	ロードした場合は「ロードしました」が表示されます。


■ セーブポイント制御

+ 一時的にセーブポイントを自動で立てる機能をオフにする／解除する

<pre class="exp">
script.set_auto_savepoint_off           // 一時的にセーブポイントを自動で立てる機能をオフにする
script.set_auto_savepoint_on            // 解除する
</pre>

	セーブポイントについては [[セーブポイント]] を参照して下さい。




■ セーブポイントの情報を取得する

<pre class="exp">
k[0] = syscom.get_current_save_scene_title            // 現在のセーブポイントのシーンタイトルを取得する
k[0] = syscom.get_current_save_message                // 現在のセーブポイントのメッセージを取得する
</pre>

	現在のセーブポイントのシーンタイトルおよびメッセージを取得します。





■ セーブ／ロードを行う

	セーブ／ロード、およびクイックセーブ／クイックロードを実際に行うには、
	[[システムコマンド]] を参照して下さい。



■ セーブデータ


<h4>セーブデータの個数を取得する</h4>

<pre class="exp">
a[0] = syscom.get_save_cnt                          // セーブデータの個数を取得する
a[0] = syscom.get_quick_save_cnt                    // クイックセーブデータの個数を取得する
</pre>

<h4>最新のセーブデータの番号を取得する</h4>

<pre class="exp">
a[0] = syscom.get_save_new_no                       // 最新のセーブデータの番号を取得する（存在しない = -1）
</pre>

<h4>セーブデータが存在しているかを調べる</h4>

<pre class="exp">
a[0] = syscom.get_save_exist($save_no)              // セーブデータが存在しているかどうかを取得する（0=存在しない、1=存在する）
a[0] = syscom.get_quick_save_exist($save_no)        // クイックセーブデータが存在しているかどうかを取得する（0=存在しない、1=存在する）
</pre>

<h4>セーブデータの日時を取得する</h4>

<pre class="exp">
a[0] = syscom.get_save_year($save_no)               // セーブデータの「年」を取得する
a[0] = syscom.get_save_month($save_no)              // セーブデータの「月」を取得する
a[0] = syscom.get_save_day($save_no)                // セーブデータの「日」を取得する
a[0] = syscom.get_save_weekday($save_no)            // セーブデータの「曜日」を取得する（0=日、1=月、2=火、3=水、4=木、5=金、6=土）
a[0] = syscom.get_save_hour($save_no)               // セーブデータの「時」を取得する
a[0] = syscom.get_save_minute($save_no)             // セーブデータの「分」を取得する
a[0] = syscom.get_save_second($save_no)             // セーブデータの「秒」を取得する
a[0] = syscom.get_save_millisecond($save_no)        // セーブデータの「ﾐﾘ秒」を取得する（0 - 999）

a[0] = syscom.get_quick_save_year($save_no)         // クイックセーブデータの「年」を取得する
a[0] = syscom.get_quick_save_month($save_no)        // クイックセーブデータの「月」を取得する
a[0] = syscom.get_quick_save_day($save_no)          // クイックセーブデータの「日」を取得する
a[0] = syscom.get_quick_save_weekday($save_no)      // クイックセーブデータの「曜日」を取得する（0=日、1=月、2=火、3=水、4=木、5=金、6=土）
a[0] = syscom.get_quick_save_hour($save_no)         // クイックセーブデータの「時」を取得する
a[0] = syscom.get_quick_save_minute($save_no)       // クイックセーブデータの「分」を取得する
a[0] = syscom.get_quick_save_second($save_no)       // クイックセーブデータの「秒」を取得する
a[0] = syscom.get_quick_save_millisecond($save_no)  // クイックセーブデータの「ﾐﾘ秒」を取得する（0 - 999）
</pre>

<h4>セーブデータのタイトルを取得する</h4>

<pre class="exp">
s[0] = syscom.get_save_title($save_no)              // セーブデータのタイトルを取得する
s[0] = syscom.get_quick_save_title($save_no)        // クイックセーブデータのタイトルを取得する
</pre>

	セーブした時に set_title で指定されていたタイトルを取得します。

<h4>セーブデータのメッセージを取得する</h4>

<pre class="exp">
s[0] = syscom.get_save_message($save_no)            // セーブデータのメッセージを取得する
s[0] = syscom.get_quick_save_message($save_no)      // クイックセーブデータのメッセージを取得する
s[0] = syscom.get_save_full_message($save_no)       // セーブデータのメッセージを取得する（ノベル用）
s[0] = syscom.get_quick_save_full_message($save_no) // クイックセーブデータのメッセージを取得する（ノベル用）
</pre>

	セーブした時にメッセージウィンドウに表示されていたメッセージを取得します。

	ノベルウィンドウの場合、直前の r コマンドまでが取得できます。
	メッセージウィンドウ全体の文字列を取得する場合は、full_message の方を使って下さい。

<h4>セーブデータのコメントを取得／設定する</h4>

<pre class="exp">
s[0] = syscom.get_save_comment($save_no)            // セーブデータのコメントを取得する
syscom.set_save_comment($save_no, $str)             // セーブデータのコメントを設定する
s[0] = syscom.get_quick_save_comment($save_no)      // クイックセーブデータのコメントを取得する
syscom.set_quick_save_comment($save_no, $str)       // クイックセーブデータのコメントを設定する
</pre>

	自由に取得／設定することができます。
	セーブデータを直接読み書きするので、無駄に処理を行うと時間がかかります。

<h4>セーブデータの汎用フラグを取得／設定する</h4>

<pre class="exp">
syscom.get_save_value($save_no, $flag, $start_index, $flag_cnt)        // セーブデータのフラグを取得する
syscom.set_save_value($save_no, $flag, $start_index, $flag_cnt)        // セーブデータのフラグを設定する
syscom.get_quick_save_value($save_no, $flag, $start_index, $flag_cnt)  // クイックセーブデータのフラグを取得する
syscom.set_quick_save_value($save_no, $flag, $start_index, $flag_cnt)  // クイックセーブデータのフラグを設定する
</pre>

	セーブデータはそれぞれ汎用フラグを持っています。それを取得／設定するコマンドです。
	セーブデータを直接読み書きするので、無駄に処理を行うと時間がかかります。
	汎用フラグは 256 個あります。汎用フラグの個数を変更することはできません。

<pre class="source">
// セーブデータ０番から、汎用フラグを３つ受け取り、
// F[10]～F[12] に順に代入する
syscom.get_save_flag(0, F, 10, 3)
</pre>

<h4>セーブデータをコピー／交換／削除する</h4>

<pre class="exp">
a[0] = syscom.copy_save($save_no_1, $save_no_2)     // セーブデータ１をセーブデータ２にコピーする
a[0] = syscom.change_save($save_no_1, $save_no_2)   // セーブデータを交換する
a[0] = syscom.delete_save($save_no)                 // セーブデータを削除する

a[0] = syscom.copy_quick_save($save_no_1, $save_no_2)     // クイックセーブデータ１をクイックセーブデータ２にコピーする
a[0] = syscom.change_quick_save($save_no_1, $save_no_2)   // クイックセーブデータを交換する
a[0] = syscom.delete_quick_save($save_no)                 // クイックセーブデータを削除する
</pre>

<h5>戻り値</h5>

	0=失敗した、1=成功した




■ クイックセーブについての補足

	クイックセーブデータのセーブ番号は、設定ファイルの #SAVE_CNT の値です。
	仮に #SAVE_CNT=10 だとすると、０番～９番の１０個が通常のセーブデータの番号です。
	１０番がクイックセーブデータの番号になります。
	次の２つのコマンドは同じ意味になります。

<pre class="source">
// #SAVE.CNT = 10 の場合、
// クイックセーブ０番はセーブ１０番に等しいため、
// 次の２つのコマンドは同じ意味になります。

// セーブデータ１０番が存在するかどうかを調べる
a[0] = syscom.get_save_exist(10)

// クイックセーブデータ０番が存在するかどうかを調べる
a[0] = syscom.get_quick_save_exist(0)


// これを利用すると、
// 「セーブデータ０番とクイックセーブデータ０番を交換する」
// といったことも可能です。

// セーブデータ０番とクイックセーブデータ０番を交換する
syscom.change_save(0, 10)
</pre>




■ エンドセーブについて

	エンドセーブは、ゲーム終了時に自動的にセーブを行う機能です。
	owari、syscom.end_game を呼び出したとき、
	またはウィンドウの [×] ボタンで終了したときにセーブが行われます。

+ エンドセーブの設定

	[[エンドセーブの設定]] を参照して下さい。
	エンドセーブの個数を１にすると、エンドセーブを行います。

+ エンドセーブされたデータをロードする

	エンドセーブされたデータをロードするには、syscom.end_load コマンドを使います。
	[[システムコマンド]] を参照して下さい。
	エンドセーブを行うコマンドもありますが、あまり使わないと思います。

+ エンドセーブのセーブデータ番号

	エンドセーブのセーブデータ番号は、「セーブデータの個数＋クイックセーブデータの個数」になります。
	例えば、セーブデータが100個、クイックセーブデータが3個のとき、
	エンドセーブのセーブデータ番号は103番になります。

<div class="table-container">
<table>
||個数|番号|
|セーブデータ|100個|0～99番|
|クイックセーブデータ|3個|100～102番|
|エンドセーブデータ|1個|103番|
</table>
</div>

	これを利用して、セーブデータの操作ができます。

<pre class="source">
// エンドセーブデータが存在するかどうかを調べる
a[0] = syscom.get_save_exist(103)

// セーブデータ０番とエンドセーブデータを交換する
syscom.change_save(0, 103)
</pre>




■ セーブサムネイル

	セーブデータにサムネイルをつけることができます。
	セーブ画面が見やすくなると思います。

	※標準のシステムコマンドメニューによるセーブダイアログを用いている場合は、
	セーブサムネイルを使うことはできません。

+ モザイクについての注意

	セーブサムネイルを使う場合は、モザイクのサイズに注意して下さい。
	プログラム処理によって作成されたサムネイル画像（縮小画像）も、ソフ倫で規定されたルールに従う必要があります。

	例えば、画面サイズが 1280×720 で、サムネイルの大きさが４分の１の 320×180 だとします。
	サムネイルに必要なモザイクのピクセル数は 6×6 です。
	つまり、元画像では４倍の 24×24 のモザイクが必要となります。

	ただし、見た目で性器が判別できるようなサムネイルになってしまうようなら、
	原寸画像のモザイクサイズを大きくするようにして下さい。
	規定を満たしていてもソフ倫からＮＧが出ることがあります。

	サムネイルテーブルを使い、専用のサムネイルを作成する方法もあります。
	詳しくは [[サムネイルテーブル]] を参照して下さい。

+ セーブサムネイルの初期設定

	[[セーブサムネイルの設定]] を参照して下さい。

+ セーブサムネイルの作成

	[[画面をキャプチャーする]] を参照して下さい。

+ サンプルについて

	サンプル内でセーブサムネイルを使っています。参考にして下さい。

+ 専用セーブサムネイルについて

	[[サムネイルテーブル]] を参照して下さい。





■ 画面をキャプチャーする

+ 画面をキャプチャーする

<pre class="source">
capture                   // 画面をキャプチャーする
capture_free              // キャプチャーした画面を解放する
</pre>

	現在表示されている画面をキャプチャーし、セーブサムネイルを作成します。
	セーブ画面などを表示する前に（ＡＤＶパートが表示されている間に）このコマンドを呼び出してください。

+ セーブサムネイルの表示

	セーブサムネイルは、画像と同じようにオブジェクトを使って表示します。
	詳しくは [[オブジェクト]] の「セーブサムネイルオブジェクトを作成する」を参照して下さい。


■ サムネイルテーブル

	特定のＣＧが表示されているときのみ、
	専用の [[セーブサムネイル]] を作成する機能です。

	セーブサムネイルは通常、ゲーム画面より小さいサイズで作成します。
	そうするとモザイクも縮小されてしまい、ソフ倫規定に引っかかってしまいます。
	縮小されても問題ないようにモザイクサイズ大きくすれば大丈夫なのですが、
	そうしたくない場合は、各ＣＧごとに専用のセーブサムネイルを登録することができます。

++ 注意点１

	専用のセーブサムネイルは、必ずそのままで表示されます。
	画面をキャプチャーした時にメッセージウィンドウやその他の画像が表示されていても、
	セーブサムネイルには反映されません。

++ 注意点２

	サムネイル登録をし忘れた画像があった場合、大変です。
	また、それをビジュアルチェック時に見つけることは困難です。
	サムネイルテーブル機能を使うときは注意して下さい。

+ 専用セーブサムネイル登録手順

++ サムネイルＣＧを作る

	通常の g00 として作って下さい。
	必ず、設定ファイルで指定したサイズの画像で作って下さい。
	詳しくは [[セーブサムネイルの設定]] を参照して下さい。

++ サムネイルテーブルを作成する

	開発環境の ThumbTablePack.exe を使い、サムネイルテーブルを作って下さい。
	詳しくは ThumbTablePack.exe のマニュアルを参照して下さい。

++ 設定ファイルに登録する

<pre class="source">
// *************************************************************
// ■セーブサムネイルの設定
// =============================================================
#SAVE_THUMB.USE = 1                            // セーブサムネイルの使用（0=使わない、1=使う）
#SAVE_THUMB.SIZE = 320, 180                    // セーブサムネイルのサイズ

// *************************************************************
// ■サムネイルテーブルの設定
// =============================================================
#THUMBTABLE_FILE = "thumbtable.dat"            // サムネイルテーブルファイル
</pre>

	詳しくは [[セーブサムネイルの設定]]、[[サムネイルテーブルの設定]] を参照して下さい。

+ サムネイルテーブルを確認する

	G00Lib.exe（Ver.3.28 以降）で確認できます。











■ システムコマンドメニュー

+ システムコマンドメニューを呼び出す

<pre class="exp">
syscom.call_syscom_menu                      // システムコマンドメニューを呼び出す
</pre>

	システムコマンドメニューを呼び出します。
	Gameexe.ini でキャンセルシーンが指定されている場合は、そのシーンを呼び出します。
	指定されていない場合は、ポップアップメニューを呼び出します。

<pre class="source">
#CANCEL_SCENE = "_cancel"                    // キャンセルシーン
</pre>

+ システムコマンドメニューを禁止／解除する

<pre class="exp">
syscom.set_syscom_menu_disable               // システムコマンドを禁止する
syscom.set_syscom_menu_enable                // システムコマンドの禁止を解除する
</pre>

	右クリックによる、システムコマンドメニューの呼び出しを禁止します。




■ システムコマンド

+ 項目の状態について

++ ON/OFF

	一部の項目は、ON/OFF を設定できます。ON に設定すると、システムコマンドメニューの項目にチェックがつきます。
	ウィンドウボタンの場合、Gameexe.ini で登録したウィンドウボタンの「モード１」が使われます。

++ 許可／不許可

	一部の項目は、許可／不許可を設定できます。不許可に設定すると、システムコマンドメニューの項目がグレー表示になり、その項目が使えなくなります。
	ウィンドウボタンの場合、Gameexe.ini で登録したボタンアクションの「DISABLE」の設定が使われます。

++ 表示／非表示

	一部の項目は、表示／非表示を設定できます。非表示に設定すると、システムコマンドメニューの項目が非表示になります。
	ウィンドウボタンの場合、Gameexe.ini で登録したボタンアクションの「DISABLE」の設定が使われます。

++ 実際の表示

	一部の項目は、不許可にしていなくても、グレー表示になることがあります。
	例えば、セーブポイントが立っていない場合は、「セーブ」の項目はグレー表示になります。
	この状態を判定するのが check_???_enable コマンドです。

+ 項目の状態を初期化する

<pre class="exp">
syscom.init_syscom_flag             // システムコマンドの項目を初期化
</pre>

	システムコマンドの項目の ON/OFF、許可／不許可、表示／非表示を初期化します。

+ 既読早送り

<pre class="exp">
syscom.set_read_skip_onoff_flag($onoff)     // 既読早送りの ON/OFF を設定する（0=OFF、1=ON）
a[0] = syscom.get_read_skip_onoff_flag      // 既読早送りの ON/OFF を取得する（0=OFF、1=ON）
syscom.set_read_skip_enable_flag($enable)   // 既読早送りの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_read_skip_enable_flag     // 既読早送りの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_read_skip_exist_flag($exist)     // 既読早送りの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_read_skip_exist_flag      // 既読早送りの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_read_skip_enable        // 既読早送りが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

++ 既読早送りが使用不可能な場合はどんなとき？

<ul>
<li>既読早送りが非表示になっているとき（syscom.set_read_skip_exist_flag(0)）</li>
<li>既読早送りが不許可になっているとき（syscom.set_read_skip_enable_flag(0)）</li>
<li>一時的に早送りが禁止されているとき（script.set_skip_disable）</li>
<li>未読の文章を読み進めているとき</li>
</ul>

+ 自動早送り

<pre class="exp">
syscom.set_auto_skip_onoff_flag($onoff)     // 自動早送りの ON/OFF を設定する（0=OFF、1=ON）
a[0] = syscom.get_auto_skip_onoff_flag      // 自動早送りの ON/OFF を取得する（0=OFF、1=ON）
syscom.set_auto_skip_enable_flag($enable)   // 自動早送りの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_auto_skip_enable_flag     // 自動早送りの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_auto_skip_exist_flag($exist)     // 自動早送りの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_auto_skip_exist_flag      // 自動早送りの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_auto_skip_enable        // 自動早送りが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

++ 自動早送りが使用不可能な場合はどんなとき？

<ul>
<li>自動早送りが非表示になっているとき（syscom.set_auto_skip_exist_flag(0)）</li>
<li>自動早送りが不許可になっているとき（syscom.set_auto_skip_enable_flag(0)）</li>
</ul>

+ オートモード

<pre class="exp">
syscom.set_auto_mode_onoff_flag($onoff)     // オートモードの ON/OFF を設定する（0=OFF、1=ON）
a[0] = syscom.get_auto_mode_onoff_flag      // オートモードの ON/OFF を取得する（0=OFF、1=ON）
syscom.set_auto_mode_enable_flag($enable)   // オートモードの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_auto_mode_enable_flag     // オートモードの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_auto_mode_exist_flag($exist)     // オートモードの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_auto_mode_exist_flag      // オートモードの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_auto_mode_enable        // オートモードが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

++ オートモードが使用不可能な場合はどんなとき？

<ul>
<li>オートモードが非表示になっているとき（syscom.set_auto_mode_exist_flag(0)）</li>
<li>オートモードが不許可になっているとき（syscom.set_auto_mode_enable_flag(0)）</li>
</ul>

+ ウィンドウを消す

<pre class="exp">
syscom.set_hide_mwnd_onoff_flag($onoff)     // 「ウィンドウを消す」の ON/OFF を設定する（0=OFF、1=ON）
a[0] = syscom.get_hide_mwnd_onoff_flag      // 「ウィンドウを消す」の ON/OFF を取得する（0=OFF、1=ON）
syscom.set_hide_mwnd_enable_flag($enable)   // 「ウィンドウを消す」の許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_hide_mwnd_enable_flag     // 「ウィンドウを消す」の許可／不許可を取得する（0=不許可、1=許可）
syscom.set_hide_mwnd_exist_flag($exist)     // 「ウィンドウを消す」の表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_hide_mwnd_exist_flag      // 「ウィンドウを消す」の表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_hide_mwnd_enable        // 「ウィンドウを消す」が実際に使えるかを判定する（0=使えない、1=使える）
</pre>

++ 「ウィンドウを消す」が使用不可能な場合はどんなとき？

<ul>
<li>「ウィンドウを消す」が非表示になっているとき（syscom.set_hide_mwnd_exist_flag(0)）</li>
<li>「ウィンドウを消す」が不許可になっているとき（syscom.set_hide_mwnd_enable_flag(0)）</li>
</ul>

+ メッセージバック

<pre class="exp">
syscom.open_msg_back                       // メッセージバックを開く
syscom.set_msg_back_enable_flag($enable)   // 「メッセージバック」の許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_msg_back_enable_flag     // 「メッセージバック」の許可／不許可を取得する（0=不許可、1=許可）
syscom.set_msg_back_exist_flag($exist)     // 「メッセージバック」の表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_msg_back_exist_flag      // 「メッセージバック」の表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_msg_back_enable        // 「メッセージバック」が実際に使えるかを判定する（0=使えない、1=使える）
a[0] = syscom.check_msg_back_open          // 「メッセージバック」が開いているかを判定する（0=開いていない、1=開いている）
</pre>

++ 「メッセージバック」が使用不可能な場合はどんなとき？

<ul>
<li>「メッセージバック」が非表示になっているとき（syscom.set_msg_back_exist_flag(0)）</li>
<li>「メッセージバック」が不許可になっているとき（syscom.set_msg_back_enable_flag(0)）</li>
<li>一時的にメッセージバックが禁止されているとき（script.set_msg_back_disable）</li>
<li>メッセージバックが空のとき</li>
</ul>

+ ローカル汎用スイッチ

<pre class="exp">
syscom.set_local_extra_switch_onoff_flag($switch_no, $onoff)     // ローカル汎用スイッチの ON/OFF を設定する（0=OFF、1=ON）
a[0] = syscom.get_local_extra_switch_onoff_flag($switch_no)      // ローカル汎用スイッチの ON/OFF を取得する（0=OFF、1=ON）
syscom.set_local_extra_switch_enable_flag($switch_no, $enable)   // ローカル汎用スイッチの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_local_extra_switch_enable_flag($switch_no)     // ローカル汎用スイッチの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_local_extra_switch_exist_flag($switch_no, $exist)     // ローカル汎用スイッチの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_local_extra_switch_exist_flag($switch_no)      // ローカル汎用スイッチの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_local_extra_switch_enable($switch_no)        // ローカル汎用スイッチが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

++ 「ローカル汎用スイッチ」が使用不可能な場合はどんなとき？

<ul>
<li>「ローカル汎用スイッチ」が非表示になっているとき（syscom.set_local_extra_switch_exist_flag(0)）</li>
<li>「ローカル汎用スイッチ」が不許可になっているとき（syscom.set_local_extra_switch_enable_flag(0)）</li>
</ul>

+ ローカル汎用モード

<pre class="exp">
syscom.set_local_extra_mode_value($mode_no, $value)          // ローカル汎用モードの値を設定する
a[0] = syscom.get_local_extra_mode_value($mode_no)           // ローカル汎用モードの値を取得する
syscom.set_local_extra_mode_enable_flag($mode_no, $enable)   // ローカル汎用モードの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_local_extra_mode_enable_flag($mode_no)     // ローカル汎用モードの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_local_extra_mode_exist_flag($mode_no, $exist)     // ローカル汎用モードの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_local_extra_mode_exist_flag($mode_no)      // ローカル汎用モードの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_local_extra_mode_enable($mode_no)        // ローカル汎用モードが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

++ 「ローカル汎用モード」が使用不可能な場合はどんなとき？

<ul>
<li>「ローカル汎用モード」が非表示になっているとき（syscom.set_local_extra_mode_exist_flag(0)）</li>
<li>「ローカル汎用モード」が不許可になっているとき（syscom.set_local_extra_mode_enable_flag(0)）</li>
</ul>

+ セーブ／ロード

<pre class="exp">
syscom.call_save_menu                       // セーブメニューを呼び出す
syscom.set_save_enable_flag($enable)        // セーブの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_save_enable_flag          // セーブの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_save_exist_flag($exist)          // セーブの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_save_exist_flag           // セーブの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_save_enable             // セーブが実際に使えるかを判定する（0=使えない、1=使える）

syscom.call_load_menu                       // ロードメニューを呼び出す
syscom.set_load_enable_flag($enable)        // ロードの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_load_enable_flag          // ロードの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_load_exist_flag($exist)          // ロードの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_load_exist_flag           // ロードの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_load_enable             // ロードが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

	セーブ／ロードメニューを呼び出します。
	それぞれのメニューシーンが Gameexe.ini で指定してあればそのシーンを、
	指定されていなければダイアログが表示されます。

<pre class="source">
#SAVE_SCENE = "_save"                   // セーブシーン
#LOAD_SCENE = "_load"                   // ロードシーン
</pre>

++ セーブが使用不可能な場合はどんなとき？

<ul>
<li>セーブが非表示になっているとき（syscom.set_save_exist_flag(0)）</li>
<li>セーブが不許可になっているとき（syscom.set_save_enable_flag(0)）</li>
<li>セーブポイントが立っていないとき</li>
</ul>

++ ロードが使用不可能な場合はどんなとき？

<ul>
<li>ロードが非表示になっているとき（syscom.set_load_exist_flag(0)）</li>
<li>ロードが不許可になっているとき（syscom.set_load_enable_flag(0)）</li>
</ul>

+ セーブ／ロード／クイックセーブ／クイックロード（番号指定）

<pre class="exp">
a[0] = syscom.save($save_no, $warning, $se_play)                  // セーブする
a[0] = syscom.quick_save($quick_save_no, $warning, $se_play)      // クイックセーブする
a[0] = syscom.end_save($warning, $se_play)                        // エンドセーブする
</pre>

<pre class="exp">
syscom.load($save_no, $warning, $se_play, $fade_out)              // ロードする
syscom.quick_load($quick_save_no, $warning, $se_play, $fade_out)  // クイックロードする
syscom.end_load($warning, $se_play, $fade_out)                    // エンドロードする
</pre>

++ 引数

	$warning: 0=確認ダイアログなし、1=確認ダイアログあり<br />
	$se_play: 0=システム音を再生しない、1=システム音を再生する<br />
	$fade_out: 0=フェードアウトを行わない、1=フェードアウトを行う<br />

++ 戻り値

	0=セーブしなかった、1=セーブした

++ エンドセーブについて

	[[エンドセーブ]] を参照して下さい。

+ 「セーブロード時に警告を表示する。」

<pre class="exp">
syscom.set_saveload_alert_onoff($onoff)        // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_saveload_alert_onoff_default        // ON/OFF をデフォルトに設定する
a[0] = syscom.get_saveload_alert_onoff         // ON/OFF を取得する（0=OFF、1=ON）
</pre>

+ 前の選択肢に戻る

<pre class="exp">
syscom.return_to_sel($warning, $se_play, $fade_out)   // 前の選択肢に戻る
syscom.set_return_to_sel_enable_flag($enable)         // 前の選択肢に戻るの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_return_to_sel_enable_flag           // 前の選択肢に戻るの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_return_to_sel_exist_flag($exist)           // 前の選択肢に戻るの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_return_to_sel_exist_flag            // 前の選択肢に戻るの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_return_to_sel_enable              // 前の選択肢に戻るが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

	$warning: 0=確認ダイアログなし、1=確認ダイアログあり<br />
	$se_play: 0=システム音を再生しない、1=システム音を再生する<br />
	$fade_out: 0=フェードアウトを行わない、1=フェードアウトを行う<br />

+ 環境設定

<pre class="exp">
syscom.call_config_menu                // 環境設定メニューを呼び出す
</pre>

	環境設定メニューを呼び出します。
	メニューシーンが Gameexe.ini で指定してあればそのシーンを、
	指定されていなければ環境設定ダイアログが表示されます。

<pre class="source">
#CONFIG_SCENE = "_config"               // 環境設定シーン
</pre>

	環境設定の個別の項目については、[[環境設定]] を参照して下さい。

+ メニューに戻る

<pre class="exp">
syscom.return_to_menu($warning, $se_play, $fade_out)  // メニューに戻る
syscom.set_return_to_menu_enable_flag($enable)        // メニューに戻るの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_return_to_menu_enable_flag          // メニューに戻るの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_return_to_menu_exist_flag($exist)          // メニューに戻るの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_return_to_menu_exist_flag           // メニューに戻るの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_return_to_menu_enable             // メニューに戻るが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

	$warning: 0=確認ダイアログなし、1=確認ダイアログあり<br />
	$se_play: 0=システム音を再生しない、1=システム音を再生する<br />
	$fade_out: 0=フェードアウトを行わない、1=フェードアウトを行う<br />

	syscom.return_to_menu(0, 0, 1) コマンドは returnmenu コマンドと同じ動作です。

+ ゲームを終了する

<pre class="exp">
syscom.end_game($warning, $se_play, $fade_out)        // ゲームを終了する
syscom.set_end_game_enable_flag($enable)              // ゲームを終了するの許可／不許可を設定する（0=不許可、1=許可）
a[0] = syscom.get_end_game_enable_flag                // ゲームを終了するの許可／不許可を取得する（0=不許可、1=許可）
syscom.set_end_game_exist_flag($exist)                // ゲームを終了するの表示／非表示を設定する（0=非表示、1=表示）
a[0] = syscom.get_end_game_exist_flag                 // ゲームを終了するの表示／非表示を取得する（0=非表示、1=表示）
a[0] = syscom.check_end_game_enable                   // ゲームを終了するが実際に使えるかを判定する（0=使えない、1=使える）
</pre>

	$warning: 0=確認ダイアログなし、1=確認ダイアログあり<br />
	$se_play: 0=システム音を再生しない、1=システム音を再生する（※１）<br />
	$fade_out: 0=フェードアウトを行わない、1=フェードアウトを行う<br />

	syscom.end_game(0, 0, 0) コマンドは owari コマンドと同じ動作です。

	（※１）現在、ゲーム終了のためのシステム音は存在しません。
	$se_play には必ず 0 を指定して下さい。

<div class="chips">
Ver.1.1.36.0 以前は引数は $warning だけでした。
引数が３つに増えましたが、互換性のため引数１つでも動きます。（2013/7/1）
</div>

+ 最後に再生された声を再生する

<pre class="exp">
syscom.replay_koe                                     // 最後に再生された声を再生する
syscom.clear_replay_koe                               // 最後に再生された声を初期化する
a[0] = syscom.check_replay_koe                        // 最後に再生された声が存在するかを確認する（0=存在しない、1=存在する）
a[0] = syscom.get_replay_koe_koe_no                   // 最後に再生された声の声番号を取得する
a[0] = syscom.get_replay_koe_chara_no                 // 最後に再生された声をキャラクター番号を取得する
</pre>

	最後に再生された声を再生、取得します。

















■ システムコマンドメニューに関する特殊コマンド

+ 一時的にメッセージウィンドウを非表示にする／解除する

<pre class="exp">
script.set_mwnd_disp_off_flag($onoff)         // 一時的にメッセージウィンドウを非表示にするフラグを設定する（1=非表示にする、0=元に戻す）
a[0] = script.get_mwnd_disp_off_flag($onoff)  // 一時的にメッセージウィンドウを非表示にするフラグを取得する（1=非表示にする、0=元に戻す）
</pre>

	一時的にメッセージウィンドウを非表示にします。
	このコマンドで非表示になるのは、「スペースキーを押したときに非表示になるもの全て」です。

<ul>
- メッセージウィンドウ
- ボタン選択肢
- 「スペースキーで消える」属性を持つオブジェクト
</ul>

	<font color="red">専用コマンドです。</font>
	システムコマンドメニューをグラフィカルに作った場合に使います。
	メニュー中は、メッセージウィンドウが消えていた方が見栄えがいい場合があります。
	このコマンドでメッセージウィンドウを消して下さい。
	メニューから抜けるときに解除すると、メッセージウィンドウが再び表示されます。

	サンプルでも使っていますので調べてみて下さい。

+ 一時的にクエイクを止める／解除する

<pre class="exp">
script.set_quake_stop_flag($onoff)    // 一時的にクエイクを止めるフラグを設定する（0=解除する、1=止める）
a[0] = script.get_quake_stop_flag     // 一時的にクエイクを止めるフラグを取得する（0=解除する、1=止める）
</pre>

	一時的にクエイクを止めます。

	<font color="red">専用コマンドです。</font>
	システムコマンドメニューをグラフィカルに作った場合に使います。
	メニュー中は、クエイクを一時停止した方が見栄えがいいです。
	このコマンドでクエイクを止めて下さい。
	メニューから抜けるときに解除すると、クエイクが再開されます。

	サンプルでも使っていますので調べてみて下さい。






■ 環境設定

<h4>画面モード</h4>

<pre class="exp">
syscom.set_window_mode($mode)                       // ウィンドウモードを設定する（0=標準ウィンドウ、1=フルスクリーン）
syscom.set_window_mode_default                      // ウィンドウモードをデフォルトに設定する
a[0] = syscom.get_window_mode                       // ウィンドウモードを取得する（0=標準ウィンドウ、1=フルスクリーン）
syscom.set_window_mode_size($size)                  // 標準ウィンドウのサイズを比率で指定する（等倍=100）
syscom.set_window_mode_size_default                 // 標準ウィンドウのサイズをデフォルトに設定する
a[0] = syscom.get_window_mode_size                  // 標準ウィンドウのサイズを比率で取得する（等倍=100）
a[0] = syscom.check_window_mode_size_enable($size)  // 標準ウィンドウのサイズが使えるかを比率で判定する（等倍=100）

syscom.call_config_window_mode_menu    // 画面モードの設定ダイアログを呼び出す
</pre>

	標準ウィンドウ／フルスクリーンを切り替えます。
	標準ウィンドウについては、サイズを％で指定できます（100=等倍）。
	通常は 50, 75, 100, 150, 200 などを指定します。

	syscom.call_window_mode_menu で、画面モード設定ダイアログを呼び出します。
	ダイアログでしか設定できないメニューが多くありますので、
	環境設定画面を自分で作る場合は、必ず呼び出す方法を提供してください。

<h4>音量設定</h4>

<pre class="exp">
syscom.set_all_volume($volume)        // 全体の音量を設定する（0-255）
syscom.set_all_volume_default         // 全体の音量をデフォルトに設定する
a[0] = syscom.get_all_volume          // 全体の音量を取得する（0-255）
syscom.set_bgm_volume($volume)        // BGM の音量を設定する（0-255）
syscom.set_bgm_volume_default         // BGM の音量をデフォルトに設定する
a[0] = syscom.get_bgm_volume          // BGM の音量を取得する（0-255）
syscom.set_koe_volume($volume)        // 声の音量を設定する（0-255）
syscom.set_koe_volume_default         // 声の音量をデフォルトに設定する
a[0] = syscom.get_koe_volume          // 声の音量を取得する（0-255）
syscom.set_pcm_volume($volume)        // 効果音の音量を設定する（0-255）
syscom.set_pcm_volume_default         // 効果音の音量をデフォルトに設定する
a[0] = syscom.get_pcm_volume          // 効果音の音量を取得する（0-255）
syscom.set_se_volume($volume)         // システム音の音量を設定する（0-255）
syscom.set_se_volume_default          // システム音の音量をデフォルトに設定する
a[0] = syscom.get_se_volume           // システム音の音量を取得する（0-255）
syscom.set_mov_volume($volume)        // ムービーの音量を設定する（0-255）
syscom.set_mov_volume_default         // ムービーの音量をデフォルトに設定する
a[0] = syscom.get_mov_volume          // ムービーの音量を取得する（0-255）

syscom.set_sound_volume($no, $volume)   // 汎用ボリュームの音量を設定する（0-255）
syscom.set_sound_volume_default($no)    // 汎用ボリュームの音量をデフォルトに設定する
a[0] = syscom.get_sound_volume($no)     // 汎用ボリュームの音量を取得する（0-255）

syscom.set_all_onoff($onoff)          // 全体の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_all_onoff_default          // 全体の ON/OFF をデフォルトに設定する
a[0] = syscom.get_all_onoff           // 全体の ON/OFF を取得する（0=OFF、1=ON）
syscom.set_bgm_onoff($onoff)          // BGM の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_bgm_onoff_default          // BGM の ON/OFF をデフォルトに設定する
a[0] = syscom.get_bgm_onoff           // BGM の ON/OFF を取得する（0=OFF、1=ON）
syscom.set_koe_onoff($onoff)          // 声の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_koe_onoff_default          // 声の ON/OFF をデフォルトに設定する
a[0] = syscom.get_koe_onoff           // 声の ON/OFF を取得する（0=OFF、1=ON）
syscom.set_pcm_onoff($onoff)          // 効果音の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_pcm_onoff_default          // 効果音の ON/OFF をデフォルトに設定する
a[0] = syscom.get_pcm_onoff           // 効果音の ON/OFF を取得する（0=OFF、1=ON）
syscom.set_se_onoff($onoff)           // システム音の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_se_onoff_default           // システム音の ON/OFF をデフォルトに設定する
a[0] = syscom.get_se_onoff            // システム音の ON/OFF を取得する（0=OFF、1=ON）
syscom.set_mov_onoff($onoff)          // ムービーの ON/OFF を設定する（0=OFF、1=ON）
syscom.set_mov_onoff_default          // ムービーの ON/OFF をデフォルトに設定する
a[0] = syscom.get_mov_onoff           // ムービーの ON/OFF を取得する（0=OFF、1=ON）

syscom.set_sound_onoff($no, $onoff)     // 汎用ボリュームの ON/OFF を設定する（0=OFF、1=ON）
syscom.set_sound_onoff_default($no)     // 汎用ボリュームの ON/OFF をデフォルトに設定する
a[0] = syscom.get_sound_onoff($no)      // 汎用ボリュームの ON/OFF を取得する（0=OFF、1=ON）
 
syscom.call_config_volume_menu        // 音量設定の設定ダイアログを呼び出す
</pre>

	汎用ボリュームについては [[汎用ボリューム]] を参照して下さい。

<h4>ＢＧＭフェード</h4>

<pre class="exp">
syscom.set_bgmfade_volume($volume)    // ＢＧＭフェードの値を設定する（0-255）
syscom.set_bgmfade_volume_default     // ＢＧＭフェードの値をデフォルトに設定する
a[0] = syscom.get_bgmfade_volume      // ＢＧＭフェードの値を取得する（0-255）
syscom.set_bgmfade_onoff($onoff)      // ＢＧＭフェードの ON/OFF を設定する（0=OFF、1=ON）
syscom.set_bgmfade_onoff_default      // ＢＧＭフェードの ON/OFF をデフォルトに設定する
a[0] = syscom.get_bgmfade_onoff       // ＢＧＭフェードの ON/OFF を取得する（0=OFF、1=ON）
syscom.call_config_bgmfade_menu       // ＢＧＭフェードの設定ダイアログを呼び出す
</pre>

	ＢＧＭフェードは、音声を再生しているときに自動的にＢＧＭの音量を下げる機能です。
	デフォルトで有効になっています。

<h4>音声設定</h4>

<pre class="exp">
syscom.set_koemode($mode)             // 音声設定を設定する（0=音声あり、1=音声なし、2=音声のみ）
syscom.set_koemode_default            // 音声設定をデフォルトに設定する
a[0] = syscom.get_koemode             // 音声設定を取得する（0=音声あり、1=音声なし、2=音声のみ）
syscom.call_config_koemode_menu       // 音声設定の設定ダイアログを呼び出す
</pre>


<h4>キャラクタ音声</h4>

<pre class="exp">
syscom.set_charakoe_onoff($regist_no, $onoff)    // キャラクタ音声の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_charakoe_onoff_default($regist_no)    // キャラクタ音声の ON/OFF をデフォルトに設定する
a[0] = syscom.get_charakoe_onoff($regist_no)     // キャラクタ音声の ON/OFF を取得する（0=OFF、1=ON）

syscom.set_charakoe_volume($regist_no, $volume)  // キャラクタ音声のボリュームを設定する（0～255）
syscom.set_charakoe_volume_default($regist_no)   // キャラクタ音声のボリュームをデフォルトに設定する
a[0] = syscom.get_charakoe_volume($regist_no)    // キャラクタ音声のボリュームを取得する（0～255）

syscom.call_config_chakoe_menu($regist_no)       // キャラクタ音声の設定ダイアログを呼び出す
</pre>

	キャラクターごとの音声の ON/OFF、ボリュームを設定／取得します。

	$regist_no は Gameexe.ini の<font color="red">登録番号</font>で指定します。
	KOE コマンドの２つ目の引数を<font color="blue">キャラクター番号</font>といいますが、別物です。間違えないでください。
	以下の例では、<font color="red">赤字</font> が登録番号、<font color="blue">青字</font> がキャラクター番号です。

<pre class="source">
#CHRKOE.<font color="red">000</font> = "姫歌",   1,     "",         (<font color="blue">00</font>)
#CHRKOE.<font color="red">001</font> = "小春",   1,     "",         (<font color="blue">01</font>)
#CHRKOE.<font color="red">002</font> = "綾子",   1,     "",         (<font color="blue">02</font>)
#CHRKOE.<font color="red">010</font> = "女の子全て", 1, "",         (<font color="blue">00</font>, <font color="blue">01</font>, <font color="blue">02</font>)

KOE(200100364,<font color="blue">001</font>)【小春】「ふんふんふんふんふ～～～～ん♪」r
</pre>


<div class="mada">
<h4>キャラクタ音声の名前を取得する</h4>

<pre class="exp">
syscom.set_charakoe_look($regist_no, $look)              // キャラクタ音声の見た見てないを設定する（0=見てない、1=見た）
a[0] = syscom.get_charakoe_look($regist_no)              // キャラクタ音声の見た見てないを取得する（0=見てない、1=見た）
s[0] = syscom.get_charakoe_name($regist_no)              // キャラクタ音声の名前を取得する
s[0] = syscom.get_charakoe_name_default                  // キャラクタ音声のデフォルトの名前を取得する
</pre>

	get_charakoe_name：
	そのキャラクタが登場した場合は、名前が返ります。
	登場していない場合は、「？？？」が返ります。
	この文字列は Gameexe.ini で設定できます。

	get_charakoe_name_default：
	「？？？」が返ります。
	この文字列は Gameexe.ini で設定できます。

<pre class="source">
//            表示名,  モード, チェック名, 制御番号
#CHRKOE.CNT = 64						// バッファの個数
#CHRKOE.NOT_LOOK_NAME_STR = "？？？"	// 伏字用の文字列
//            表示名,  モード, チェック名, 制御番号
#CHRKOE.000 = "なまはむ",   1,         "", (00)
#CHRKOE.001 = "鈴",         1,         "", (01)
#CHRKOE.002 = "生ハム",     1,         "", (02)
#CHRKOE.003 = "生波夢",     1,         "", (03, 04)
#CHRKOE.004 = "生破無",     1,         "", (05, 06, 07)

#CHRKOE.010 = "女の子全て", 1,         "", (01)
</pre>
</div>

<h4>時短再生</h4>

<pre class="exp">
syscom.set_jitan_speed($speed)                // 時短再生の速度を設定する（100-300、100=等速）
syscom.set_jitan_speed_default                // 時短再生の速度をデフォルトに設定する
a[0] = syscom.get_jitan_speed                 // 時短再生の速度を取得する
syscom.set_jitan_normal_onoff($onoff)         // 通常時の時短再生の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_jitan_normal_onoff_default         // 通常時の時短再生の ON/OFF をデフォルトに設定する
a[0] = syscom.get_jitan_normal_onoff          // 通常時の時短再生の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_jitan_auto_mode_onoff($onoff)      // オートモード時の時短再生の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_jitan_auto_mode_onoff_default      // オートモード時の時短再生の ON/OFF をデフォルトに設定する
a[0] = syscom.get_jitan_auto_mode_onoff       // オートモード時の時短再生の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_jitan_koe_replay_onoff($onoff)     // 声リプレイ時の時短再生の ON/OFF を設定する（0=OFF、1=ON）
syscom.set_jitan_koe_replay_onoff_default     // 声リプレイ時の時短再生の ON/OFF をデフォルトに設定する
a[0] = syscom.get_jitan_koe_replay_onoff      // 声リプレイ時の時短再生の ON/OFF を設定する（0=OFF、1=ON）
syscom.call_config_jitan_menu                 // 時短再生の設定ダイアログを呼び出す
</pre>

<h4>メッセージ速度</h4>

<pre class="exp">
syscom.set_message_speed($speed)              // メッセージ速度を設定する（0-100、小さいほど速い）
syscom.set_message_speed_default              // メッセージ速度をデフォルトに設定する
a[0] = syscom.get_message_speed               // メッセージ速度を取得する
syscom.set_message_nowait($speed)             // メッセージ速度の「ノーウェイト」を設定する（0=OFF、1=ON）
syscom.set_message_nowait_default             // メッセージ速度の「ノーウェイト」をデフォルトに設定する
a[0] = syscom.get_message_nowait              // メッセージ速度の「ノーウェイト」を取得する（0=OFF、1=ON）
syscom.call_config_message_speed_menu         // メッセージ速度の設定ダイアログを呼び出す
</pre>

<h4>オートモード</h4>

<pre class="exp">
syscom.set_auto_mode_moji_wait($time)         // オートモードの文字時間を設定する（0-500）
syscom.set_auto_mode_moji_wait_default        // オートモードの文字時間をデフォルトに設定する
a[0] = syscom.get_auto_mode_moji_wait         // オートモードの文字時間を取得する（0-500）
syscom.set_auto_mode_min_wait($time)          // オートモードの最小時間を設定する（0-5000）
syscom.set_auto_mode_min_wait_default         // オートモードの最小時間をデフォルトに設定する
a[0] = syscom.get_auto_mode_min_wait          // オートモードの最小時間を取得する（0-5000）
syscom.call_config_auto_mode_menu             // オートモードの設定ダイアログを呼び出す
</pre>

	待ち時間 ＝ ( 表示した文字数 × 文字時間 ) ＋ 最小時間

<h4>自動でマウスカーソルを隠す</h4>

<pre class="exp">
syscom.set_mouse_cursor_hide_onoff($onoff)    // 自動でマウスカーソルを隠す機能のオンオフを設定する
syscom.set_mouse_cursor_hide_onoff_default    // 自動でマウスカーソルを隠す機能のオンオフを初期化する
a[0] = syscom.get_mouse_cursor_hide_onoff     // 自動でマウスカーソルを隠す機能のオンオフを取得する
syscom.set_mouse_cursor_hide_time($time)      // 自動でマウスカーソルを隠す時間を設定する
syscom.set_mouse_cursor_hide_time_default     // 自動でマウスカーソルを隠す時間を初期化する
a[0] = syscom.get_mouse_cursor_hide_time      // 自動でマウスカーソルを隠す時間を取得する
</pre>

<h4>フォントの設定</h4>

<pre class="exp">
syscom.set_font_name($name)                   // フォント名を設定する
syscom.set_font_name_default                  // フォント名を初期設定に戻す
s[0] = syscom.get_font_name                   // フォント名を取得する
a[0] = syscom.is_font_exist($name)            // フォントが存在するかを判定する（0=存在しない、1=存在する）
syscom.set_font_bold($bold)                   // フォントの太さを指定する（0=標準、1=太くする）
syscom.set_font_bold_default($bold)           // フォントの太さを初期設定に戻す
a[0] = syscom.get_font_bold($bold)            // フォントの太さを取得する（0=標準、1=太くする）
syscom.set_font_decoration($bold)             // フォントの装飾を指定する（0=なし、1=影、2=縁取る、3=縁+影）
syscom.set_font_decoration_default($bold)     // フォントの装飾を初期設定に戻す
a[0] = syscom.get_font_decoration($bold)      // フォントの装飾を取得する（0=なし、1=影、2=縁取る、3=縁+影）
syscom.call_config_font_menu                  // フォントの設定ダイアログを呼び出す
</pre>

	フォント名、およびフォントの「太くする」「影を付ける」などの設定を取得／設定します。

	通常は使わないコマンドです。
	必ず syscom.call_config_font_menu でフォント設定ダイアログを呼び出して下さい。
	（ダイアログでしか設定できないメニューが多くあります。）

	set_font_name、is_font_exist で指定するのはフォントファイル名ではなく「フォント名」な点に注意して下さい。

<h4>ウィンドウ背景</h4>

<pre class="exp">
syscom.set_filter_color_r($r)                 // フィルタカラー（赤）を設定する（0-255）
syscom.set_filter_color_r_default             // フィルタカラー（赤）をデフォルトに設定する
a[0] = syscom.get_filter_color_r              // フィルタカラー（赤）を取得する（0-255）
syscom.set_filter_color_g($g)                 // フィルタカラー（緑）を設定する（0-255）
syscom.set_filter_color_g_default             // フィルタカラー（緑）をデフォルトに設定する
a[0] = syscom.get_filter_color_g              // フィルタカラー（緑）を取得する（0-255）
syscom.set_filter_color_b($b)                 // フィルタカラー（青）を設定する（0-255）
syscom.set_filter_color_b_default             // フィルタカラー（青）をデフォルトに設定する
a[0] = syscom.get_filter_color_b              // フィルタカラー（青）を取得する（0-255）
syscom.set_filter_color_a($a)                 // フィルタカラー（不透明度）を設定する（0-255）
syscom.set_filter_color_a_default             // フィルタカラー（不透明度）をデフォルトに設定する
a[0] = syscom.get_filter_color_a              // フィルタカラー（不透明度）を取得する（0-255）
syscom.call_config_filter_color_menu          // フィルターカラーの設定ダイアログを呼び出す
</pre>

+ オブジェクトの表示

<pre class="exp">
syscom.set_object_disp_onoff($switch_no, $onoff)          // 「オブジェクトの表示」を設定する（0/1)
syscom.set_object_disp_onoff_default($switch_no)          // 「オブジェクトの表示」をデフォルトに設定する
a[0] = syscom.get_object_disp_onoff($switch_no)           // 「オブジェクトの表示」を取得する（0/1)
</pre>

	「オブジェクトの表示」は０番～３番まであります。値は 0 または 1 です。
	詳しくは Gameexe.ini の #DIALOG.OBJECT_DISP を参照して下さい。
	初期値については、Gameexe.ini の #CONFIG.OBJECT_DISP を参照して下さい。

<h4>グローバル汎用スイッチ</h4>

<pre class="exp">
syscom.set_global_extra_switch_onoff($switch_no, $onoff)    // グローバル汎用スイッチの値を設定する（0/1）
syscom.set_global_extra_switch_onoff_default($switch_no)    // グローバル汎用スイッチの値をデフォルトに設定する
a[0] = syscom.get_global_extra_switch_onoff($switch_no)     // グローバル汎用スイッチの値を取得する（0/1）
</pre>

	グローバル汎用スイッチは０番～３番まであります。値は 0 または 1 です。
	詳しくは Gameexe.ini の #DIALOG.GLOBAL_EXTRA_SWITCH を参照して下さい。
	初期値については、Gameexe.ini の #CONFIG.GLOBAL_EXTRA_SWITCH を参照して下さい。

<h4>グローバル汎用モード</h4>

<pre class="exp">
syscom.set_global_extra_mode_value($mode_no, $value)        // グローバル汎用モードの値を設定する
syscom.set_global_extra_mode_value_default($mode_no)        // グローバル汎用モードの値をデフォルトに設定する
a[0] = syscom.get_global_extra_mode_value($mode_no)         // グローバル汎用モードの値を取得する
</pre>

	グローバル汎用モードは０番～３番まであります。それぞれ８個まで項目を作ることができます。
	値は、たとえば項目が８個の場合、0～7 です。
	詳しくは Gameexe.ini の #DIALOG.GLOBAL_EXTRA_MODE を参照して下さい。
	初期値については、Gameexe.ini の #CONFIG.GLOBAL_EXTRA_MODE を参照して下さい。

<h4>ムービーの設定</h4>

<pre class="exp">
syscom.call_config_movie_menu                 // ムービーの設定ダイアログを呼び出す
</pre>

<h4>システム設定</h4>

<pre class="exp">
syscom.call_config_system_menu                // システム設定の設定ダイアログを呼び出す
</pre>

<h5>「本プログラムの動作を遅くして、他のプログラムがスムーズに動作するようにする。」</h5>

<pre class="exp">
syscom.set_sleep_onoff($onoff)                // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_sleep_onoff_default                // ON/OFF をデフォルトに設定する
a[0] = syscom.get_sleep_onoff                 // ON/OFF を取得する（0=OFF、1=ON）
</pre>

<h5>「画面暗転効果のアニメを無効にする。」</h5>

<pre class="exp">
syscom.set_no_wipe_anime_onoff($onoff)        // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_no_wipe_anime_onoff_default        // ON/OFF をデフォルトに設定する
a[0] = syscom.get_no_wipe_anime_onoff         // ON/OFF を取得する（0=OFF、1=ON）
</pre>

<h5>「画面暗転効果をマウスクリックで飛ばす。」</h5>

<pre class="exp">
syscom.set_skip_wipe_anime_onoff($onoff)      // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_skip_wipe_anime_onoff_default      // ON/OFF をデフォルトに設定する
a[0] = syscom.get_skip_wipe_anime_onoff       // ON/OFF を取得する（0=OFF、1=ON）
</pre>

<h5>「メッセージウィンドウの開閉時のアニメを無効にする。」</h5>

<pre class="exp">
syscom.set_no_mwnd_anime_onoff($onoff)        // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_no_mwnd_anime_onoff_default        // ON/OFF をデフォルトに設定する
a[0] = syscom.get_no_mwnd_anime_onoff         // ON/OFF を取得する（0=OFF、1=ON）
</pre>

<h5>「マウスのホイールボタンの下回しで文章を読み進める。」</h5>

<pre class="exp">
syscom.set_wheel_next_message_onoff($onoff)   // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_wheel_next_message_onoff_default   // ON/OFF をデフォルトに設定する
a[0] = syscom.get_wheel_next_message_onoff    // ON/OFF を取得する（0=OFF、1=ON）
</pre>

<h5>「声の再生中に次の文章に進んでも再生を続ける。」</h5>

<pre class="exp">
syscom.set_koe_dont_stop_onoff($onoff)        // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_koe_dont_stop_onoff_default        // ON/OFF をデフォルトに設定する
a[0] = syscom.get_koe_dont_stop_onoff         // ON/OFF を取得する（0=OFF、1=ON）
</pre>

<h5>「未読の文章も早送りできるようにする。」</h5>

<pre class="exp">
syscom.set_skip_unread_message_onoff($onoff)  // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_skip_unread_message_onoff_default  // ON/OFF をデフォルトに設定する
a[0] = syscom.get_skip_unread_message_onoff   // ON/OFF を取得する（0=OFF、1=ON）
</pre>

<h5>「サウンド再生時に雑音が入る場合はチェックして下さい。」</h5>

<pre class="exp">
syscom.set_play_silent_sound_onoff($onoff)    // ON/OFF を設定する（0=OFF、1=ON）
syscom.set_play_silent_sound_onoff_default    // ON/OFF をデフォルトに設定する
a[0] = syscom.get_play_silent_sound_onoff     // ON/OFF を取得する（0=OFF、1=ON）
</pre>




■ システムコール

	システムコールは、システムが呼び出すコールです。
	分かりやすい例では、ゲーム中に画面を右クリックすると、キャンセルコールが行われます。
	システムコールで呼び出されるシーンを設定すると、オリジナルのメニューなどが作れます。

<div class="table-container">
<table>
|キャンセルコール|画面を右クリックで呼び出される|
|セーブコール|システムコマンドメニューやウィンドウボタンの「セーブ」を選ぶと呼び出される|
|ロードコール|システムコマンドメニューやウィンドウボタンの「ロード」を選ぶと呼び出される|
|環境設定コール|システムコマンドメニューやウィンドウボタンの「環境設定」を選ぶと呼び出される|
</table>
</div>

	システムコール時に、いくつかの状態は自動的に設定されます。
	例えば、マウスカーソルは自動的に表示状態になります。
	これらの状態は、システムコールから戻るときに、自動的に元に戻されます。

+ 自動的に元に設定される／元に戻るもの

<ul>
- 既読早送りを止める
- オートモードを止める
- マウスカーソルを表示する
- ...
</ul>

	フラグやオブジェクトなどは元に戻りません。
	システムコール中に、これらの情報を破壊しないように注意してください。

	システムコール専用のパラメータについては [[システムコールパラメータ]] を参照して下さい。

+ システムコールで呼び出されるシーンを設定する

	Gameexe.ini で設定することが出来ます。

<pre class="source">
#CANCEL_SCENE = "_cancel"               // キャンセルシーン
#SAVE_SCENE = "_save"                   // セーブシーン
#LOAD_SCENE = "_load"                   // ロードシーン
#CONFIG_SCENE = "_config"               // 環境設定シーン
</pre>

+ システムコールから戻る

	通常のコールと同じように、return コマンドで戻ることが出来ます。

+ コールフラグ

	通常のコールと同じように、l フラグなどが確保されます。



■ システムコールを行う

	[[システムコール]] で説明したとおり、システムコールは自動的に行われます。
	それとは別に、スクリプトから呼び出す方法もあります。

+ キャンセルシーンを呼ぶ

<pre class="exp">
syscom.call_syscom_menu
</pre>

	設定ファイルで指定したキャンセルシーン（#CANCEL_SCENE）を呼びます。
	キャンセルシーンを指定していないときは、システムコマンドメニューが呼び出されます。
	[[システムコマンド]] も参照して下さい。

+ セーブ／ロードシーンを呼ぶ

<pre class="exp">
syscom.call_save_menu
syscom.call_load_menu
</pre>

	設定ファイルで指定したセーブ／ロードシーン（#SAVE_SCENE／#LOAD_SCENE）を呼びます。
	セーブ／ロードシーンを指定していないときは、セーブ／ロードダイアログが呼び出されます。
	[[システムコマンド]] も参照して下さい。

+ 環境設定シーンを呼ぶ

<pre class="exp">
syscom.call_config_menu
</pre>

	設定ファイルで指定した環境設定シーン（#CONFIG_SCENE）を呼びます。
	環境設定シーンを指定していないときは、環境設定ダイアログが呼び出されます。
	[[システムコマンド]] も参照して下さい。

+ その他のシーンを呼ぶ

<pre class="exp">
syscom.call_ex($scene_name)
syscom.call_ex($scene_name, $z_label_no)
</pre>

	任意のシーンをシステムコールとして呼び出します。




■ システムコール中を判定する

<pre class="exp">
excall.is_excall      // システムコール中かどうかを判定する（0=システムコール中でない、1=システムコール中）
</pre>

	excall.check_alloc とは違うコマンドです。
	[[システムコールパラメータ]] も参照して下さい。



■ システムコールパラメータ

+ システムコールパラメータを準備する

<pre class="exp">
excall.alloc          // システムコールパラメータを準備する
excall.free           // システムコールパラメータを解放する
</pre>

	システムコールパラメータが使えるようになります。
	使い終わったら excall.free で解放するのを忘れないで下さい。

+ システムコールパラメータが準備されているかを判定する

<pre class="exp">
a[0] = excall.check_alloc  // パラメータが準備されているかを判定する
                           // （0=準備されていない、1=準備されている）
</pre>

	excall.is_excall とは別のコマンドです。
	[[システムコール中を判定する]] を参照して下さい。

+ システムコールパラメータ

<pre class="exp">
excall.F
excall.counter
excall.frame_action
excall.frame_action_ch
excall.stage
excall.back
excall.front
excall.next
</pre>

	システムコール専用のフラグ、カウンタ、フレームアクション、ステージです。
	ステージにはオブジェクトやグループも含まれます。
	excall.alloc 時に、Gameexe.ini で設定された個数だけ確保されます。
	また、l フラグなど通常のコールパラメータも使うことができます。

	システムコールパラメータのオブジェクトは、通常のオブジェクトより前面に表示されます。

++ ワイプについて

	システムコール中にワイプを行うと、システムコールオブジェクトのみがワイプされます。
	通常のオブジェクトはワイプされません。

+ 簡単なアクセス

	excall[0] / excall[1] でも、
	例えば通常のオブジェクトやシステムコールのオブジェクトにアクセスできます。

<pre class="source">
front.object            // 通常のフロントオブジェクト
excall.front.object     // システムコールのフロントオブジェクト

excall[0].front.object  // 通常のフロントオブジェクト
excall[1].front.object  // システムコールのフロントオブジェクト
</pre>

	stage[0] / stage[1] / stage[2] で、back / front / next にもアクセスできることも覚えておくと、より便利です。











■ ロード直後コール

	準備中…。


■ ダミーファイル

<h4>ダミーファイルをチェックする</h4>

<pre class="exp">
system.check_dummy_file_once($file_name, $key, $code)
</pre>

<ul>
<li>$file_name: ダミーファイルのファイル名（拡張子は不要）</li>
<li>$key: ダミーファイルに埋め込まれた「キー」</li>
<li>$code: ダミーファイルに埋め込まれた「コード」</li>
</ul>

<h5>説明</h5>

	ディスク内にダミーファイル入れることで、ディスク認証ができます。
	認証は、初回起動時に１度だけ行います。

<h5>ダミーファイルを使ってできること</h5>

<ul>
<li>ゲームの容量を大きくすることで、ゲームデータがネットワークに流れにくくなります。</li>
<li>スクリプトでダミーファイルをチェックすることで、ディスク認証ができます。</li>
</ul>

<h5>ダミーファイルの作り方</h5>

	開発環境の DummyMaker.exe を使います。詳しくは DummyMaker のマニュアルを参照して下さい。

<h5>認証ディスクの作り方</h5>

	DummyMaker.exe で作られたダミーデータ、
	および認証ファイル（env ファイル、[[初期設定]] の #DISKMARK 参照）が入っていれば、
	正規ディスクとして認識されます。
	構成については開発環境の「◇セットアップ環境」を参考にして下さい。

	通常はゲームディスク＝認証ディスクになると思います。
	開発中、テスト用に認証ディスクを作りたい場合は、上記の２つを入れれば認証ディスクを作れます。
	<font color="red">env ファイルを入れ忘れると認識されませんので注意して下さい。</font>


<h5>使用例</h5>

<pre class="source">
system.check_dummy_file_once("dummy", 139, "tonapyon")
</pre>

<h5>設定ファイル</h5>

	設定ファイルで認証ダイアログの文字列を設定する必要があります。
	[[ダミーファイルの設定]] を参照して下さい。

<h5>補足２</h5>

	RealLive で必要だった初回起動チェックや認証中の文字の表示は必要なくなりました。





■ ウィンドウがアクティブかどうかを判定する

<pre class="exp">
a[0] = system.check_active           // 0=アクティブでない、1=アクティブ
</pre>

++ 使い方

	独自にメニューを組んだとします。
	この時、ウィンドウがアクティブでない場合はボタンに反応して欲しくない、という場合に使います。

<pre class="source">
input.clear
while (1) {
    if (system.check_active && 100 <= mouse.pos_x && mouse.pos_x <= 200)  {
        // ボタンにマウスが当たったときの処理
    }
    input.next
    disp
}
</pre>

++ 注意点

<ul>
- 例外として、デバッグウィンドウがアクティブなときも 1 になります。
- 環境設定ウィンドウ（フォントの設定など）などがアクティブなときは 0 になります。
</ul>


■ ファイルを開く

<pre class="exp">
system.shell_open_file($path)    // ファイルを開く
</pre>

	ファイルを、Windows に関連付けられたアプリケーションで開きます。

	ファイルのパスは、Siglus.exe からの相対パスで指定して下さい。

++ 注意点１

	ファイルは必ず何らかのフォルダに入れてください。（sys フォルダ、manual フォルダなど）
	Siglus.exe と同じ階層にあるファイルを開くことはできません。（最小セットアップ時に問題が起きます。）

++ 注意点２

	html マニュアルを開く際には注意が必要です。
	フルスクリーンで起動している場合、マニュアルを開いても、ブラウザがゲームウィンドウに隠れてしまいます。
	一度ウィンドウモードに戻してあげると親切です。

++ 注意点３

	ファイルパスについて、&yen; は &yen;&yen; と表記することに注意して下さい。

+ manual フォルダの index.html を開く

<pre class="source">
syscom.set_window_mode(0)                       // ウィンドウモードに戻す
system.shell_open_file("manual\\index.html")    // マニュアルを開く
</pre>




■ ウェブページをブラウザで開く

<pre class="exp">
system.shell_open_web($URL)      // ウェブページを開く
</pre>

++ 注意点１

	ウェブページを開く際には注意が必要です。
		フルスクリーンで起動している場合、ウェブページを開いても、ブラウザがゲームウィンドウに隠れてしまいます。
	一度ウィンドウモードに戻してあげると親切です。

++ 注意点２

	URL を開くとき、&yen; は &yen;&yen; と表記することに注意して下さい。

++ ウェブページを開く

<pre class="source">
syscom.set_window_mode(0)                            // ウィンドウモードに戻す
system.shell_open_web("http://www.product.co.jp")    // ウェブページを開く
</pre>



■ ファイルの存在を判定する

<pre class="exp">
a[0] = system.check_file_exist($path)    // ファイルの存在を判定する
</pre>

	ファイルが存在するかを判定します。0=存在しない、1=存在する

	ファイルのパスは、Siglus.exe からの相対パスで指定して下さい。

++ 注意点１

	何らかのフォルダに入っているファイルしか判定できません。（sys フォルダ、manual フォルダなど）
	Siglus.exe と同じ階層にあるファイルの存在を判定することはできません。（最小セットアップ時に問題が起きます。）

++ 注意点２

	ファイルパスについて、&yen; は &yen;&yen; と表記することに注意して下さい。

+ g00 画像 BG001.g00 が存在するかを判定する

<pre class="source">
l[0] = system.check_file_exist("g00\\BG001.g00")    // g00\\BG001.g00 が存在するかを判定
if (l[0] == 1)  {
    "BG001.g00 "は存在します。r
}
else   {
    "BG001.g00 "は存在しません。r
}
</pre>




■ 言語を取得する

<pre class="exp">
s[0] = system.get_language
</pre>

	SiglusEngine の言語を取得します。日本語版の場合 "ja"、英語版の場合 "en" が取得できます。






■ 現在の時間を取得する

+ 現在の日付と時間を取得する

<pre class="exp">
system.get_calendar($year, $month, $day, $weekday, $hour, $minute, $second, $millsecond)
</pre>

	現在の日付と時間を取得します。

<div class="table-container">
<table>
|$year|年（西暦）|
|$month|月（1～12）|
|$day|日（1～31）|
|$weekday|曜日（0=日、1=月、2=火、3=水、4=木、5=金、6=土）|
|$hour|時間（0～23）|
|$minute|分（0～59）|
|$second|秒（0～59）|
|$millsecond|ﾐﾘ秒（0～999）|
</table>
</div>

+ 現在の時間を unix 標準時刻で取得する

<pre class="exp">
a[0] = system.get_unix_time
</pre>

	現在の時間（秒）を、unix 時間（1970年1月1日からの経過時間）で取得します。






■ 総プレイ時間を取得／設定する

+ 総プレイ時間を取得する

<pre class="exp">
syscom.get_total_play_time($day, $hour, $minute, $second, $millsecond)
</pre>

	ゲームの総プレイ時間を取得／設定します。

<div class="table-container">
<table>
|$day|日（0～）|
|$hour|時間（0～23）|
|$minute|分（0～59）|
|$second|秒（0～59）|
|$millsecond|ﾐﾘ秒（0～999）|
</table>
</div>

+ 総プレイ時間を設定する

<pre class="exp">
syscom.set_total_play_time($day, $hour, $minute, $second, $millsecond)
</pre>


	デバッグ用のコマンドです。それ以外で使うことはほとんどないと思います。

	総プレイ時間を表示する画面を作ったときに、
	それが正常に動いているかをチェックするために使って下さい。

+ サンプル：総プレイ時間を取得する

<pre class="source">
// 総プレイ時間を取得します。
syscom.get_total_play_time(l[0], l[1], l[2], l[3], l[4])

// 文字列を組み立てます。表示方法は少し工夫が必要です。
// たとえばプレイ時間が１時間と１秒のときは、「日」の表示は必要ないですが「分」の表示は必要です。
k[0] = ""
if (l[0] > 0)	{
	k[0] += math.tostr(l[0]) + "日"
}
if (l[0] > 0 || l[1] > 0)	{
	k[0] += math.tostr(l[1]) + "時間"
}
if (l[0] > 0 || l[1] > 0 || l[2] > 0)	{
	k[0] += math.tostr(l[2]) + "分"
}
if (l[0] > 0 || l[1] > 0 || l[2] > 0 || l[3] > 0)	{
	k[0] += math.tostr(l[3]) + "秒"
}
if (l[0] > 0 || l[1] > 0 || l[2] > 0 || l[3] > 0)	{
	k[0] += math.tostr_zero(l[4], 3)
}
</pre>






■ デバッグ中かどうかを判定する

<pre class="exp">
a[0] = system.check_debug_flag
</pre>

	デバッグ中かどうかを判定します。（0=デバッグ中でない、1=デバッグ中）





■ デバッグ用メッセージボックス

	デバッグ時のみメッセージボックスを出す機能です。
	リリース時は何もしません。

<pre class="exp">
a[0] = system.debug_messagebox_ok($num)          // 0=OK
a[0] = system.debug_messagebox_ok($str)          // 0=OK
a[0] = system.debug_messagebox_okcancel($num)    // 0=OK、1=CANCEL
a[0] = system.debug_messagebox_okcancel($str)    // 0=OK、1=CANCEL
a[0] = system.debug_messagebox_yesno($num)       // 0=YES、1=NO
a[0] = system.debug_messagebox_yesno($str)       // 0=YES、1=NO
a[0] = system.debug_messagebox_yesnocancel($num) // 0=YES、1=NO、2=CANCEL
a[0] = system.debug_messagebox_yesnocancel($str) // 0=YES、1=NO、2=CANCEL
</pre>

	戻り値で、どのボタンを選んだかを取得できます。



■ デバッグログ出力

<pre class="exp">
system.debug_write_log(num)
system.debug_write_log(str)
</pre>

	独自のデバッグログを出力します。

	デバッグログは、作業フォルダ内の __DEBUG_LOG フォルダに作られます。
	（作業フォルダを指定していない場合は SiglusEngine.exe の隣に __DEBUG_LOG フォルダが作られます。）

	出力したログは、「デバッグメニュー」→「エラー情報」にも表示されます。

	リリース時には、この機能は無効になります。呼び出しても何も出力されません。


■ エレメント一覧
+ global 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|_____test|
|コマンド|int|__iapp_dummy|
|コマンド|int|__iapp_dummy2|
|コマンド|str|__iapp_dummy_str|
|コマンド|str|__iapp_dummy2_str|
|プロパティ|str|__fog_name|
|プロパティ|int|__fog_x|
|プロパティ|intevent|__fog_x_eve|
|プロパティ|int|__fog_near|
|プロパティ|int|__fog_far|
|コマンド|void|nop|
|コマンド|void|owari|
|コマンド|void|returnmenu|
|コマンド|void|jump|
|コマンド|int|farcall|
|コマンド|str|get_scene_name|
|コマンド|int|get_line_no|
|コマンド|void|set_title|
|コマンド|str|get_title|
|コマンド|int|savepoint|
|コマンド|void|clear_savepoint|
|コマンド|int|check_savepoint|
|コマンド|void|selpoint|
|コマンド|void|clear_selpoint|
|コマンド|void|stack_selpoint|
|コマンド|void|drop_selpoint|
|コマンド|int|check_selpoint|
|コマンド|void|timewait|
|コマンド|int|timewait_key|
|コマンド|void|frame|
|コマンド|void|disp|
|コマンド|void|wipe|
|コマンド|void|mask_wipe|
|コマンド|void|wipe_all|
|コマンド|void|mask_wipe_all|
|コマンド|void|wipe_end|
|コマンド|int|wait_wipe|
|コマンド|int|check_wipe|
|コマンド|void|capture|
|コマンド|void|capture_free|
|コマンド|void|capture_for_object|
|コマンド|void|capture_for_object_free|
|コマンド|int|capture_for_local_save|
|コマンド|void|message_box|
|コマンド|void|set_mwnd|
|コマンド|int|get_mwnd|
|コマンド|void|set_sel_mwnd|
|コマンド|int|get_sel_mwnd|
|コマンド|void|set_waku|
|コマンド|void|open|
|コマンド|void|open_wait|
|コマンド|void|open_nowait|
|コマンド|void|close|
|コマンド|void|close_wait|
|コマンド|void|close_nowait|
|コマンド|void|end_close|
|コマンド|void|msg_block|
|コマンド|void|msg_pp_block|
|コマンド|void|clear|
|コマンド|void|print|
|コマンド|void|ruby|
|コマンド|void|wait_msg|
|コマンド|void|pp|
|コマンド|void|r|
|コマンド|void|page|
|コマンド|void|nl|
|コマンド|void|nli|
|コマンド|void|indent|
|コマンド|void|clear_indent|
|コマンド|void|rep_pos|
|コマンド|void|size|
|コマンド|void|color|
|コマンド|void|multi_msg|
|コマンド|void|next_msg|
|コマンド|void|start_slide_msg|
|コマンド|void|end_slide_msg|
|コマンド|int|sel|
|コマンド|int|sel_cancel|
|コマンド|int|selmsg|
|コマンド|int|selmsg_cancel|
|コマンド|int|selbtn|
|コマンド|void|selbtn_ready|
|コマンド|int|selbtn_cancel|
|コマンド|void|selbtn_cancel_ready|
|コマンド|int|selbtn_start|
|コマンド|int|sel_image|
|コマンド|void|koe|
|コマンド|void|koe_play_wait|
|コマンド|int|koe_play_wait_key|
|コマンド|void|koe_stop|
|コマンド|void|koe_wait|
|コマンド|int|koe_wait_key|
|コマンド|int|koe_check|
|コマンド|int|koe_check_get_koe_no|
|コマンド|int|koe_check_get_chara_no|
|コマンド|int|koe_check_is_ex_koe|
|コマンド|void|koe_set_volume|
|コマンド|void|koe_set_volume_max|
|コマンド|void|koe_set_volume_min|
|コマンド|int|koe_get_volume|
|コマンド|int|exkoe|
|コマンド|void|exkoe_play_wait|
|コマンド|int|exkoe_play_wait_key|
|コマンド|void|clear_face|
|コマンド|void|set_face|
|コマンド|void|set_namae|
|コマンド|void|clear_msgbk|
|コマンド|void|insert_msgbk_img|
|プロパティ|intlist|a|
|プロパティ|intlist|b|
|プロパティ|intlist|c|
|プロパティ|intlist|d|
|プロパティ|intlist|e|
|プロパティ|intlist|f|
|プロパティ|intlist|g|
|プロパティ|intlist|z|
|プロパティ|strlist|s|
|プロパティ|strlist|m|
|プロパティ|intlist|x|
|プロパティ|strlist|namae_local|
|プロパティ|strlist|namae_global|
|コマンド|strref|namae|
|プロパティ|math|math|
|プロパティ|file|file|
|プロパティ|databaselist|database|
|プロパティ|counterlist|counter|
|プロパティ|g00buflist|g00buf|
|プロパティ|masklist|mask|
|プロパティ|worldlist|world|
|プロパティ|stagelist|stage|
|プロパティ|stage|back|
|プロパティ|stage|front|
|プロパティ|stage|next|
|プロパティ|msgbk|msgbk|
|プロパティ|bgm|bgm|
|プロパティ|koe|koe_st|
|プロパティ|pcm|pcm|
|プロパティ|pcmchlist|pcmch|
|プロパティ|pcmeventlist|pcmevent|
|プロパティ|se|se|
|プロパティ|mov|mov|
|プロパティ|input|input|
|プロパティ|mouse|mouse|
|プロパティ|keylist|key|
|プロパティ|screen|screen|
|プロパティ|frameaction|frame_action|
|プロパティ|frameactionlist|frame_action_ch|
|プロパティ|editboxlist|editbox|
|プロパティ|script|script|
|プロパティ|syscom|syscom|
|プロパティ|syscommenu|syscom_menu|
|プロパティ|mwndbtn|mwnd_btn|
|プロパティ|cgtable|cgtable|
|プロパティ|bgmtable|bgmtable|
|プロパティ|system|system|
|プロパティ|calllist|call|
|プロパティ|call|cur_call|
|プロパティ|excall|excall|
|コマンド|void|init_call_stack|
|コマンド|int|get_call_stack_cnt|
|コマンド|void|set_call_stack_cnt|
|コマンド|void|del_call_stack|
</table>
</div>
+ call 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|intlist|l|
|プロパティ|strlist|k|
</table>
</div>
+ calllist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|call|[]|
</table>
</div>
+ intlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|int|[]|
|コマンド|void|init|
|コマンド|void|resize|
|コマンド|int|get_size|
|コマンド|void|sets|
|コマンド|void|clear|
|プロパティ|intlist|bit|
|プロパティ|intlist|bit2|
|プロパティ|intlist|bit4|
|プロパティ|intlist|bit8|
|プロパティ|intlist|bit16|
</table>
</div>
+ intlistref 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|int|[]|
|コマンド|void|resize|
|コマンド|int|get_size|
|コマンド|void|sets|
|コマンド|void|clear|
|プロパティ|intlist|bit|
|プロパティ|intlist|bit2|
|プロパティ|intlist|bit4|
|プロパティ|intlist|bit8|
|プロパティ|intlist|bit16|
</table>
</div>
+ intevent 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|set|
|コマンド|void|set_real|
|コマンド|void|loop|
|コマンド|void|loop_real|
|コマンド|void|turn|
|コマンド|void|turn_real|
|コマンド|void|yure|
|コマンド|void|yure_real|
|コマンド|void|end|
|コマンド|void|wait|
|コマンド|int|wait_key|
|コマンド|int|check|
|コマンド|int|get_event_value|
|コマンド|void|__set|
</table>
</div>
+ inteventlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|intevent|[]|
|コマンド|void|resize|
</table>
</div>
+ allevent 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|end|
|コマンド|void|wait|
|コマンド|int|check|
</table>
</div>
+ str 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|str|upper|
|コマンド|str|lower|
|コマンド|int|len|
|コマンド|int|cnt|
|コマンド|str|left|
|コマンド|str|left_len|
|コマンド|str|mid|
|コマンド|str|mid_len|
|コマンド|str|right|
|コマンド|str|right_len|
|コマンド|int|search|
|コマンド|int|search_last|
|コマンド|int|get_code|
|コマンド|int|tonum|
</table>
</div>
+ strlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|str|[]|
|コマンド|void|init|
|コマンド|void|resize|
|コマンド|int|get_size|
|コマンド|void|sets|
</table>
</div>
+ math 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|int|max|
|コマンド|int|min|
|コマンド|int|limit|
|コマンド|int|abs|
|コマンド|int|rand|
|コマンド|int|sqrt|
|コマンド|int|log|
|コマンド|int|log2|
|コマンド|int|log10|
|コマンド|int|sin|
|コマンド|int|cos|
|コマンド|int|tan|
|コマンド|int|arcsin|
|コマンド|int|arccos|
|コマンド|int|arctan|
|コマンド|int|distance|
|コマンド|int|angle|
|コマンド|int|linear|
|コマンド|int|timetable|
|コマンド|str|tostr|
|コマンド|str|tostr_zero|
|コマンド|str|tostr_zen|
|コマンド|str|tostr_zen_zero|
|コマンド|str|tostr_by_code|
</table>
</div>
+ file 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|int|load_txt|
|コマンド|void|preload_omv|
</table>
</div>
+ cgtable 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|intlist|flag|
|コマンド|void|set_disable|
|コマンド|void|set_enable|
|コマンド|void|set_all_flag|
|コマンド|int|get_flag_no_by_name|
|コマンド|str|get_name_by_flag_no|
|コマンド|void|set_look_by_name|
|コマンド|int|get_look_by_name|
|コマンド|int|get_cg_cnt|
|コマンド|int|get_look_cnt|
|コマンド|int|get_look_percent|
</table>
</div>
+ bgmtable 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|int|get_bgm_cnt|
|コマンド|void|set_all_flag|
|コマンド|void|set_listen_by_name|
|コマンド|int|get_listen_by_name|
</table>
</div>
+ database 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|int|get_num|
|コマンド|str|get_str|
|コマンド|void|get_data|
|コマンド|int|check_item|
|コマンド|int|check_column|
|コマンド|int|find_num|
|コマンド|int|find_str|
|コマンド|int|find_str_real|
</table>
</div>
+ databaselist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|database|[]|
|コマンド|int|get_size|
</table>
</div>
+ g00buf 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|load|
|コマンド|void|free|
</table>
</div>
+ g00buflist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|g00buf|[]|
|コマンド|int|get_size|
|コマンド|void|free_all|
</table>
</div>
+ mask 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|init|
|コマンド|void|create|
|プロパティ|int|x|
|プロパティ|int|y|
|プロパティ|intevent|x_eve|
|プロパティ|intevent|y_eve|
</table>
</div>
+ masklist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|mask|[]|
|コマンド|int|get_size|
</table>
</div>
+ counter 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|set|
|コマンド|int|get|
|コマンド|void|reset|
|コマンド|void|start|
|コマンド|void|start_real|
|コマンド|void|start_frame|
|コマンド|void|start_frame_real|
|コマンド|void|start_frame_loop|
|コマンド|void|start_frame_loop_real|
|コマンド|void|stop|
|コマンド|void|resume|
|コマンド|void|wait|
|コマンド|int|wait_key|
|コマンド|int|check_value|
|コマンド|int|check_active|
</table>
</div>
+ counterlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|counter|[]|
|コマンド|int|get_size|
</table>
</div>
+ frameaction 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|start|
|コマンド|void|start_real|
|コマンド|void|end|
|プロパティ|counter|counter|
|コマンド|int|is_end_action|
</table>
</div>
+ frameactionlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|frameaction|[]|
|コマンド|void|resize|
|コマンド|int|get_size|
</table>
</div>
+ world 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|int|camera_eye_x|
|プロパティ|intevent|camera_eye_x_eve|
|プロパティ|int|camera_eye_y|
|プロパティ|intevent|camera_eye_y_eve|
|プロパティ|int|camera_eye_z|
|プロパティ|intevent|camera_eye_z_eve|
|プロパティ|int|camera_pint_x|
|プロパティ|intevent|camera_pint_x_eve|
|プロパティ|int|camera_pint_y|
|プロパティ|intevent|camera_pint_y_eve|
|プロパティ|int|camera_pint_z|
|プロパティ|intevent|camera_pint_z_eve|
|プロパティ|int|camera_up_x|
|プロパティ|intevent|camera_up_x_eve|
|プロパティ|int|camera_up_y|
|プロパティ|intevent|camera_up_y_eve|
|プロパティ|int|camera_up_z|
|プロパティ|intevent|camera_up_z_eve|
|プロパティ|int|camera_view_angle|
|プロパティ|int|mono|
|コマンド|void|init|
|コマンド|int|get_no|
|コマンド|void|set_camera_eye|
|コマンド|void|calc_camera_eye|
|コマンド|void|set_camera_pint|
|コマンド|void|calc_camera_pint|
|コマンド|void|set_camera_up|
|コマンド|void|set_camera_eve_xz_rotate|
</table>
</div>
+ worldlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|world|[]|
|コマンド|int|create_world|
|コマンド|void|destroy_world|
</table>
</div>
+ stage 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|create_object|
|コマンド|void|create_mwnd|
|プロパティ|objectlist|object|
|プロパティ|grouplist|objbtngroup|
|プロパティ|mwndlist|mwnd|
|プロパティ|btnselitemlist|btnselitem|
|プロパティ|effectlist|effect|
|プロパティ|quakelist|quake|
</table>
</div>
+ stagelist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|stage|[]|
</table>
</div>
+ object 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|int|__iapp_dummy|
|コマンド|str|get_element_name|
|プロパティ|int|disp|
|プロパティ|int|patno|
|プロパティ|int|world|
|プロパティ|int|order|
|プロパティ|int|layer|
|プロパティ|int|x|
|プロパティ|int|y|
|プロパティ|int|z|
|プロパティ|intlist|x_rep|
|プロパティ|intlist|y_rep|
|プロパティ|intlist|z_rep|
|プロパティ|int|center_x|
|プロパティ|int|center_y|
|プロパティ|int|center_z|
|プロパティ|int|center_rep_x|
|プロパティ|int|center_rep_y|
|プロパティ|int|center_rep_z|
|プロパティ|int|scale_x|
|プロパティ|int|scale_y|
|プロパティ|int|scale_z|
|プロパティ|int|rotate_x|
|プロパティ|int|rotate_y|
|プロパティ|int|rotate_z|
|プロパティ|int|clip_use|
|プロパティ|int|clip_left|
|プロパティ|int|clip_top|
|プロパティ|int|clip_right|
|プロパティ|int|clip_bottom|
|プロパティ|int|src_clip_use|
|プロパティ|int|src_clip_left|
|プロパティ|int|src_clip_top|
|プロパティ|int|src_clip_right|
|プロパティ|int|src_clip_bottom|
|プロパティ|int|tr|
|プロパティ|intlist|tr_rep|
|プロパティ|int|mono|
|プロパティ|int|reverse|
|プロパティ|int|bright|
|プロパティ|int|dark|
|プロパティ|int|color_r|
|プロパティ|int|color_g|
|プロパティ|int|color_b|
|プロパティ|int|color_rate|
|プロパティ|int|color_add_r|
|プロパティ|int|color_add_g|
|プロパティ|int|color_add_b|
|プロパティ|int|tonecurve_no|
|プロパティ|int|mask_no|
|プロパティ|int|fog_use|
|プロパティ|int|light_no|
|プロパティ|int|culling|
|プロパティ|int|alpha_test|
|プロパティ|int|alpha_blend|
|プロパティ|int|blend|
|プロパティ|int|wipe_copy|
|プロパティ|int|wipe_erase|
|プロパティ|int|click_disable|
|プロパティ|intevent|patno_eve|
|プロパティ|intevent|x_eve|
|プロパティ|intevent|y_eve|
|プロパティ|intevent|z_eve|
|プロパティ|inteventlist|x_rep_eve|
|プロパティ|inteventlist|y_rep_eve|
|プロパティ|inteventlist|z_rep_eve|
|プロパティ|intevent|center_x_eve|
|プロパティ|intevent|center_y_eve|
|プロパティ|intevent|center_z_eve|
|プロパティ|intevent|center_rep_x_eve|
|プロパティ|intevent|center_rep_y_eve|
|プロパティ|intevent|center_rep_z_eve|
|プロパティ|intevent|scale_x_eve|
|プロパティ|intevent|scale_y_eve|
|プロパティ|intevent|scale_z_eve|
|プロパティ|intevent|rotate_x_eve|
|プロパティ|intevent|rotate_y_eve|
|プロパティ|intevent|rotate_z_eve|
|プロパティ|intevent|tr_eve|
|プロパティ|inteventlist|tr_rep_eve|
|プロパティ|intevent|clip_left_eve|
|プロパティ|intevent|clip_top_eve|
|プロパティ|intevent|clip_right_eve|
|プロパティ|intevent|clip_bottom_eve|
|プロパティ|intevent|src_clip_left_eve|
|プロパティ|intevent|src_clip_top_eve|
|プロパティ|intevent|src_clip_right_eve|
|プロパティ|intevent|src_clip_bottom_eve|
|プロパティ|intevent|mono_eve|
|プロパティ|intevent|reverse_eve|
|プロパティ|intevent|bright_eve|
|プロパティ|intevent|dark_eve|
|プロパティ|intevent|color_r_eve|
|プロパティ|intevent|color_g_eve|
|プロパティ|intevent|color_b_eve|
|プロパティ|intevent|color_rate_eve|
|プロパティ|intevent|color_add_r_eve|
|プロパティ|intevent|color_add_g_eve|
|プロパティ|intevent|color_add_b_eve|
|プロパティ|allevent|all_eve|
|プロパティ|frameaction|frame_action|
|プロパティ|frameactionlist|frame_action_ch|
|プロパティ|objectlist|child|
|プロパティ|intlist|f|
|コマンド|void|init|
|コマンド|void|init_param|
|コマンド|void|free|
|コマンド|void|create|
|コマンド|void|create_rect|
|コマンド|void|create_string|
|コマンド|void|create_number|
|コマンド|void|create_weather|
|コマンド|void|create_save_thumb|
|コマンド|void|create_capture_thumb|
|コマンド|void|create_capture|
|コマンド|void|create_movie|
|コマンド|void|create_movie_loop|
|コマンド|void|create_movie_wait|
|コマンド|int|create_movie_wait_key|
|コマンド|void|create_mesh|
|コマンド|void|create_billboard|
|コマンド|void|create_copy_from|
|コマンド|void|change_file|
|コマンド|void|set_pos|
|コマンド|void|set_scale|
|コマンド|void|set_rotate|
|コマンド|void|set_center|
|コマンド|void|set_center_rep|
|コマンド|void|set_clip|
|コマンド|void|set_src_clip|
|コマンド|int|get_type|
|コマンド|int|get_size_x|
|コマンド|int|get_size_y|
|コマンド|int|get_size_z|
|コマンド|int|get_pixel_color_r|
|コマンド|int|get_pixel_color_g|
|コマンド|int|get_pixel_color_b|
|コマンド|int|get_pixel_color_a|
|コマンド|str|get_file_name|
|コマンド|void|set_string|
|コマンド|str|get_string|
|コマンド|void|set_string_param|
|コマンド|void|set_number|
|コマンド|int|get_number|
|コマンド|void|set_number_param|
|コマンド|void|set_weather_param_type_a|
|コマンド|void|set_weather_param_type_b|
|コマンド|void|pause_movie|
|コマンド|void|resume_movie|
|コマンド|void|seek_movie|
|コマンド|int|get_movie_seek_time|
|コマンド|int|check_movie|
|コマンド|void|wait_movie|
|コマンド|int|wait_movie_key|
|コマンド|void|end_movie_loop|
|コマンド|void|set_movie_auto_free|
|コマンド|void|clear_button|
|コマンド|void|set_button|
|コマンド|void|set_button_group|
|コマンド|void|set_button_state_normal|
|コマンド|void|set_button_state_select|
|コマンド|void|set_button_state_disable|
|コマンド|int|get_button_state|
|コマンド|int|get_button_hit_state|
|コマンド|int|get_button_real_state|
|コマンド|void|set_button_pushkeep|
|コマンド|int|get_button_pushkeep|
|コマンド|void|clear_button_call|
|コマンド|void|set_button_call|
|コマンド|void|load_gan|
|コマンド|void|start_gan|
|コマンド|void|add_hints|
|コマンド|void|clear_hints|
|コマンド|void|set_child_sort_type_default|
|コマンド|void|set_child_sort_type_test|
|コマンド|int|get_pat_cnt|
</table>
</div>
+ objectlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|object|[]|
|コマンド|void|resize|
|コマンド|int|get_size|
</table>
</div>
+ objectevent 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|set_x|
|コマンド|void|set_y|
|コマンド|void|set_z|
|コマンド|void|set_scale_x|
|コマンド|void|set_scale_y|
|コマンド|void|set_scale_z|
|コマンド|void|set_rotate_x|
|コマンド|void|set_rotate_y|
|コマンド|void|set_rotate_z|
|コマンド|void|set_tr|
|コマンド|void|loop_x|
|コマンド|void|loop_y|
|コマンド|void|loop_z|
|コマンド|void|loop_tr|
|コマンド|void|turn_x|
|コマンド|void|turn_y|
|コマンド|void|turn_z|
|コマンド|void|turn_tr|
|コマンド|void|stop_x|
|コマンド|void|stop_y|
|コマンド|void|stop_z|
|コマンド|void|stop_scale_x|
|コマンド|void|stop_scale_y|
|コマンド|void|stop_scale_z|
|コマンド|void|stop_rotate_x|
|コマンド|void|stop_rotate_y|
|コマンド|void|stop_rotate_z|
|コマンド|void|stop_tr|
|コマンド|void|stop_all|
|コマンド|void|wait_x|
|コマンド|void|wait_y|
|コマンド|void|wait_z|
|コマンド|void|wait_scale_x|
|コマンド|void|wait_scale_y|
|コマンド|void|wait_scale_z|
|コマンド|void|wait_rotate_x|
|コマンド|void|wait_rotate_y|
|コマンド|void|wait_rotate_z|
|コマンド|void|wait_tr|
|コマンド|void|wait_all|
</table>
</div>
+ objecteventlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|objectevent|[]|
</table>
</div>
+ mwnd 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|set_waku|
|コマンド|void|open|
|コマンド|void|open_wait|
|コマンド|void|open_nowait|
|コマンド|void|close|
|コマンド|void|close_wait|
|コマンド|void|close_nowait|
|コマンド|int|check_open|
|コマンド|void|end_close|
|コマンド|void|msg_block|
|コマンド|void|msg_pp_block|
|コマンド|void|clear|
|コマンド|void|___novel_clear|
|コマンド|void|set_namae|
|コマンド|void|namae|
|コマンド|void|___over_flow_namae|
|コマンド|void|print|
|コマンド|void|___over_flow_print|
|コマンド|void|ruby|
|コマンド|void|wait_msg|
|コマンド|void|pp|
|コマンド|void|r|
|コマンド|void|page|
|コマンド|int|sel|
|コマンド|int|sel_cancel|
|コマンド|int|selmsg|
|コマンド|int|selmsg_cancel|
|コマンド|void|nl|
|コマンド|void|nli|
|コマンド|void|indent|
|コマンド|void|clear_indent|
|コマンド|void|size|
|コマンド|void|rep_pos|
|コマンド|void|color|
|コマンド|void|multi_msg|
|コマンド|void|next_msg|
|コマンド|void|start_slide_msg|
|コマンド|void|___slide_msg|
|コマンド|void|end_slide_msg|
|コマンド|void|koe|
|コマンド|void|koe_play_wait|
|コマンド|int|koe_play_wait_key|
|コマンド|void|exkoe|
|コマンド|void|exkoe_play_wait|
|コマンド|int|exkoe_play_wait_key|
|コマンド|void|clear_face|
|コマンド|void|set_face|
|プロパティ|int|world|
|プロパティ|int|layer|
|プロパティ|objectlist|object|
|プロパティ|objectlist|button|
|プロパティ|objectlist|face|
|コマンド|void|init_window_pos|
|コマンド|void|init_window_size|
|コマンド|void|init_window_moji_cnt|
|コマンド|void|init_waku_file|
|コマンド|void|init_filter_file|
|コマンド|void|init_open_anime_type|
|コマンド|void|init_open_anime_time|
|コマンド|void|init_close_anime_type|
|コマンド|void|init_close_anime_time|
|コマンド|void|set_window_pos|
|コマンド|void|set_window_size|
|コマンド|void|set_window_moji_cnt|
|コマンド|void|set_waku_file|
|コマンド|void|set_filter_file|
|コマンド|void|set_open_anime_type|
|コマンド|void|set_open_anime_time|
|コマンド|void|set_close_anime_type|
|コマンド|void|set_close_anime_time|
|コマンド|int|get_window_pos_x|
|コマンド|int|get_window_pos_y|
|コマンド|int|get_window_size_x|
|コマンド|int|get_window_size_y|
|コマンド|int|get_window_moji_cnt_x|
|コマンド|int|get_window_moji_cnt_y|
|コマンド|str|get_waku_file|
|コマンド|str|get_filter_file|
|コマンド|int|get_open_anime_type|
|コマンド|int|get_open_anime_time|
|コマンド|int|get_close_anime_type|
|コマンド|int|get_close_anime_time|
|コマンド|int|get_default_open_anime_type|
|コマンド|int|get_default_open_anime_time|
|コマンド|int|get_default_close_anime_type|
|コマンド|int|get_default_close_anime_time|
</table>
</div>
+ mwndlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|mwnd|[]|
|コマンド|void|close|
|コマンド|void|close_wait|
|コマンド|void|close_nowait|
</table>
</div>
+ group 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|int|sel|
|コマンド|int|sel_cancel|
|コマンド|void|init|
|コマンド|void|start|
|コマンド|void|start_cancel|
|コマンド|void|end|
|コマンド|int|get_hit_no|
|コマンド|int|get_pushed_no|
|コマンド|int|get_decided_no|
|コマンド|int|on_hit_no|
|コマンド|int|on_pushed_no|
|コマンド|int|on_decided_no|
|コマンド|int|get_result|
|コマンド|int|get_result_button_no|
|プロパティ|int|order|
|プロパティ|int|layer|
|プロパティ|int|cancel_priority|
</table>
</div>
+ grouplist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|group|[]|
|コマンド|void|alloc|
|コマンド|void|free|
</table>
</div>
+ btnselitem 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|objectlist|object|
</table>
</div>
+ btnselitemlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|btnselitem|[]|
|コマンド|void|alloc|
|コマンド|void|free|
</table>
</div>
+ screen 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|init|
|プロパティ|int|x|
|プロパティ|int|y|
|プロパティ|int|z|
|プロパティ|int|mono|
|プロパティ|int|reverse|
|プロパティ|int|bright|
|プロパティ|int|dark|
|プロパティ|int|color_r|
|プロパティ|int|color_g|
|プロパティ|int|color_b|
|プロパティ|int|color_rate|
|プロパティ|int|color_add_r|
|プロパティ|int|color_add_g|
|プロパティ|int|color_add_b|
|プロパティ|intevent|x_eve|
|プロパティ|intevent|y_eve|
|プロパティ|intevent|z_eve|
|プロパティ|intevent|mono_eve|
|プロパティ|intevent|reverse_eve|
|プロパティ|intevent|bright_eve|
|プロパティ|intevent|dark_eve|
|プロパティ|intevent|color_r_eve|
|プロパティ|intevent|color_g_eve|
|プロパティ|intevent|color_b_eve|
|プロパティ|intevent|color_rate_eve|
|プロパティ|intevent|color_add_r_eve|
|プロパティ|intevent|color_add_g_eve|
|プロパティ|intevent|color_add_b_eve|
|プロパティ|effectlist|effect|
|コマンド|void|shake|
|プロパティ|quakelist|quake|
</table>
</div>
+ quake 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|start|
|コマンド|void|start_wait|
|コマンド|void|start_wait_key|
|コマンド|void|start_nowait|
|コマンド|void|start_all|
|コマンド|void|start_all_wait|
|コマンド|void|start_all_wait_key|
|コマンド|void|start_all_nowait|
|コマンド|void|end|
|コマンド|void|wait|
|コマンド|void|wait_key|
|コマンド|int|check|
</table>
</div>
+ quakelist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|quake|[]|
</table>
</div>
+ editbox 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|create|
|コマンド|void|destroy|
|コマンド|void|set_text|
|コマンド|str|get_text|
|コマンド|void|set_focus|
|コマンド|int|check_decided|
|コマンド|int|check_canceled|
|コマンド|void|clear_input|
</table>
</div>
+ editboxlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|editbox|[]|
|コマンド|void|clear_input|
</table>
</div>
+ effect 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|init|
|プロパティ|int|wipe_copy|
|プロパティ|int|wipe_erase|
|プロパティ|int|x|
|プロパティ|int|y|
|プロパティ|int|z|
|プロパティ|int|mono|
|プロパティ|int|reverse|
|プロパティ|int|bright|
|プロパティ|int|dark|
|プロパティ|int|color_r|
|プロパティ|int|color_g|
|プロパティ|int|color_b|
|プロパティ|int|color_rate|
|プロパティ|int|color_add_r|
|プロパティ|int|color_add_g|
|プロパティ|int|color_add_b|
|プロパティ|intevent|x_eve|
|プロパティ|intevent|y_eve|
|プロパティ|intevent|z_eve|
|プロパティ|intevent|mono_eve|
|プロパティ|intevent|reverse_eve|
|プロパティ|intevent|bright_eve|
|プロパティ|intevent|dark_eve|
|プロパティ|intevent|color_r_eve|
|プロパティ|intevent|color_g_eve|
|プロパティ|intevent|color_b_eve|
|プロパティ|intevent|color_rate_eve|
|プロパティ|intevent|color_add_r_eve|
|プロパティ|intevent|color_add_g_eve|
|プロパティ|intevent|color_add_b_eve|
|プロパティ|int|begin_order|
|プロパティ|int|end_order|
|プロパティ|int|begin_layer|
|プロパティ|int|end_layer|
</table>
</div>
+ effectlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|effect|[]|
|コマンド|void|resize|
|コマンド|int|get_size|
</table>
</div>
+ msgbk 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|insert_img|
|コマンド|void|insert_msg|
|コマンド|void|add_msg|
|コマンド|void|add_koe|
|コマンド|void|add_namae|
|コマンド|void|go_next_msg|
</table>
</div>
+ bgm 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|play|
|コマンド|void|play_oneshot|
|コマンド|void|play_wait|
|コマンド|void|ready|
|コマンド|void|ready_oneshot|
|コマンド|void|wait|
|コマンド|int|wait_key|
|コマンド|void|stop|
|コマンド|void|pause|
|コマンド|void|resume|
|コマンド|void|resume_wait|
|コマンド|void|wait_fade|
|コマンド|int|wait_fade_key|
|コマンド|int|check|
|コマンド|void|set_volume|
|コマンド|void|set_volume_max|
|コマンド|void|set_volume_min|
|コマンド|str|get_regist_name|
|コマンド|int|get_volume|
|コマンド|int|get_play_pos|
</table>
</div>
+ pcm 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|play|
|コマンド|void|stop|
</table>
</div>
+ pcmch 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|play|
|コマンド|void|play_loop|
|コマンド|void|play_wait|
|コマンド|void|ready|
|コマンド|void|ready_loop|
|コマンド|void|stop|
|コマンド|void|pause|
|コマンド|void|resume|
|コマンド|void|resume_wait|
|コマンド|void|wait|
|コマンド|int|wait_key|
|コマンド|void|wait_fade|
|コマンド|int|wait_fade_key|
|コマンド|int|check|
|コマンド|int|get_volume|
|コマンド|void|set_volume|
|コマンド|void|set_volume_max|
|コマンド|void|set_volume_min|
</table>
</div>
+ pcmchlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|pcmch|[]|
|コマンド|void|stop_all|
</table>
</div>
+ se 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|play|
|コマンド|void|play_by_file_name|
|コマンド|void|play_by_koe_no|
|コマンド|void|play_by_se_no|
|コマンド|void|stop|
|コマンド|void|wait|
|コマンド|void|wait_key|
|コマンド|int|check|
|コマンド|void|set_volume|
|コマンド|void|set_volume_max|
|コマンド|void|set_volume_min|
|コマンド|int|get_volume|
</table>
</div>
+ mov 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|play|
|コマンド|void|play_wait|
|コマンド|int|play_wait_key|
|コマンド|void|stop|
</table>
</div>
+ pcmevent 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|start_oneshot|
|コマンド|void|start_loop|
|コマンド|void|start_random|
|コマンド|void|stop|
|コマンド|void|wait|
|コマンド|int|wait_key|
|コマンド|int|check|
</table>
</div>
+ pcmeventlist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|pcmevent|[]|
</table>
</div>
+ mouse 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|clear|
|コマンド|void|next|
|コマンド|int|pos_x|
|コマンド|int|pos_y|
|コマンド|int|get_pos_x|
|コマンド|int|get_pos_y|
|コマンド|void|get_pos|
|コマンド|void|set_pos|
|コマンド|int|wheel|
|プロパティ|key|left|
|プロパティ|key|right|
</table>
</div>
+ key 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|int|on_down|
|コマンド|int|on_up|
|コマンド|int|on_down_up|
|コマンド|int|is_down|
|コマンド|int|is_up|
|コマンド|int|on_gesture_up|
|コマンド|int|on_gesture_up_release|
|コマンド|int|on_gesture_down|
|コマンド|int|on_gesture_left|
|コマンド|int|on_gesture_right|
</table>
</div>
+ keylist 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|key|[]|
|コマンド|void|wait|
|コマンド|void|wait_force|
|コマンド|void|clear|
|コマンド|void|next|
</table>
</div>
+ input 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|clear|
|コマンド|void|next|
|プロパティ|key|decide|
|プロパティ|key|cancel|
</table>
</div>
+ syscom 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|set_syscom_menu_enable|
|コマンド|void|set_syscom_menu_disable|
|コマンド|void|set_mwnd_btn_enable|
|コマンド|void|set_mwnd_btn_disable|
|コマンド|void|set_mwnd_btn_touch_enable|
|コマンド|void|set_mwnd_btn_touch_disable|
|コマンド|void|call_ex|
|コマンド|void|call_syscom_menu|
|コマンド|void|call_save_menu|
|コマンド|void|call_load_menu|
|コマンド|void|call_config_menu|
|コマンド|void|call_config_window_mode_menu|
|コマンド|void|call_config_volume_menu|
|コマンド|void|call_config_bgmfade_menu|
|コマンド|void|call_config_koemode_menu|
|コマンド|void|call_config_charakoe_menu|
|コマンド|void|call_config_jitan_menu|
|コマンド|void|call_config_message_speed_menu|
|コマンド|void|call_config_auto_mode_menu|
|コマンド|void|call_config_font_menu|
|コマンド|void|call_config_filter_color_menu|
|コマンド|void|call_config_system_menu|
|コマンド|void|call_config_movie_menu|
|コマンド|void|init_syscom_flag|
|コマンド|void|set_read_skip_onoff_flag|
|コマンド|int|get_read_skip_onoff_flag|
|コマンド|void|set_read_skip_enable_flag|
|コマンド|int|get_read_skip_enable_flag|
|コマンド|void|set_read_skip_exist_flag|
|コマンド|int|get_read_skip_exist_flag|
|コマンド|int|check_read_skip_enable|
|コマンド|void|set_auto_skip_onoff_flag|
|コマンド|int|get_auto_skip_onoff_flag|
|コマンド|void|set_auto_skip_enable_flag|
|コマンド|int|get_auto_skip_enable_flag|
|コマンド|void|set_auto_skip_exist_flag|
|コマンド|int|get_auto_skip_exist_flag|
|コマンド|int|check_auto_skip_enable|
|コマンド|void|set_auto_mode_onoff_flag|
|コマンド|int|get_auto_mode_onoff_flag|
|コマンド|void|set_auto_mode_enable_flag|
|コマンド|int|get_auto_mode_enable_flag|
|コマンド|void|set_auto_mode_exist_flag|
|コマンド|int|get_auto_mode_exist_flag|
|コマンド|int|check_auto_mode_enable|
|コマンド|void|set_hide_mwnd_onoff_flag|
|コマンド|int|get_hide_mwnd_onoff_flag|
|コマンド|void|set_hide_mwnd_enable_flag|
|コマンド|int|get_hide_mwnd_enable_flag|
|コマンド|void|set_hide_mwnd_exist_flag|
|コマンド|int|get_hide_mwnd_exist_flag|
|コマンド|int|check_hide_mwnd_enable|
|コマンド|void|open_msg_back|
|コマンド|void|close_msg_back|
|コマンド|void|set_msg_back_enable_flag|
|コマンド|int|get_msg_back_enable_flag|
|コマンド|void|set_msg_back_exist_flag|
|コマンド|int|get_msg_back_exist_flag|
|コマンド|int|check_msg_back_enable|
|コマンド|void|set_local_extra_switch_onoff_flag|
|コマンド|int|get_local_extra_switch_onoff_flag|
|コマンド|void|set_local_extra_switch_enable_flag|
|コマンド|int|get_local_extra_switch_enable_flag|
|コマンド|void|set_local_extra_switch_exist_flag|
|コマンド|int|get_local_extra_switch_exist_flag|
|コマンド|int|check_local_extra_switch_enable|
|コマンド|void|set_local_extra_mode_value|
|コマンド|int|get_local_extra_mode_value|
|コマンド|void|set_local_extra_mode_enable_flag|
|コマンド|int|get_local_extra_mode_enable_flag|
|コマンド|void|set_local_extra_mode_exist_flag|
|コマンド|int|get_local_extra_mode_exist_flag|
|コマンド|int|check_local_extra_mode_enable|
|コマンド|void|return_to_sel|
|コマンド|void|set_return_to_sel_enable_flag|
|コマンド|int|get_return_to_sel_enable_flag|
|コマンド|void|set_return_to_sel_exist_flag|
|コマンド|int|get_return_to_sel_exist_flag|
|コマンド|int|check_return_to_sel_enable|
|コマンド|void|return_to_menu|
|コマンド|void|set_return_to_menu_enable_flag|
|コマンド|int|get_return_to_menu_enable_flag|
|コマンド|void|set_return_to_menu_exist_flag|
|コマンド|int|get_return_to_menu_exist_flag|
|コマンド|int|check_return_to_menu_enable|
|コマンド|void|end_game|
|コマンド|void|set_end_game_enable_flag|
|コマンド|int|get_end_game_enable_flag|
|コマンド|void|set_end_game_exist_flag|
|コマンド|int|get_end_game_exist_flag|
|コマンド|int|check_end_game_enable|
|コマンド|void|get_total_play_time|
|コマンド|void|set_total_play_time|
|コマンド|void|replay_koe|
|コマンド|int|check_replay_koe|
|コマンド|int|get_replay_koe_koe_no|
|コマンド|int|get_replay_koe_chara_no|
|コマンド|void|clear_replay_koe|
|コマンド|int|save|
|コマンド|int|quick_save|
|コマンド|int|end_save|
|コマンド|void|set_save_enable_flag|
|コマンド|int|get_save_enable_flag|
|コマンド|void|set_save_exist_flag|
|コマンド|int|get_save_exist_flag|
|コマンド|int|check_save_enable|
|コマンド|void|load|
|コマンド|void|quick_load|
|コマンド|void|end_load|
|コマンド|void|set_load_enable_flag|
|コマンド|int|get_load_enable_flag|
|コマンド|void|set_load_exist_flag|
|コマンド|int|get_load_exist_flag|
|コマンド|int|check_load_enable|
|コマンド|int|get_save_cnt|
|コマンド|int|get_quick_save_cnt|
|コマンド|int|get_save_exist|
|コマンド|int|get_quick_save_exist|
|コマンド|int|get_end_save_exist|
|コマンド|int|get_save_new_no|
|コマンド|int|get_quick_save_new_no|
|コマンド|int|get_save_year|
|コマンド|int|get_quick_save_year|
|コマンド|int|get_save_month|
|コマンド|int|get_quick_save_month|
|コマンド|int|get_save_day|
|コマンド|int|get_quick_save_day|
|コマンド|int|get_save_weekday|
|コマンド|int|get_quick_save_weekday|
|コマンド|int|get_save_hour|
|コマンド|int|get_quick_save_hour|
|コマンド|int|get_save_minute|
|コマンド|int|get_quick_save_minute|
|コマンド|int|get_save_second|
|コマンド|int|get_quick_save_second|
|コマンド|int|get_save_millisecond|
|コマンド|int|get_quick_save_millisecond|
|コマンド|str|get_save_title|
|コマンド|str|get_quick_save_title|
|コマンド|str|get_save_message|
|コマンド|str|get_quick_save_message|
|コマンド|str|get_save_comment|
|コマンド|void|set_save_comment|
|コマンド|str|get_quick_save_comment|
|コマンド|void|set_quick_save_comment|
|コマンド|void|get_save_value|
|コマンド|void|get_quick_save_value|
|コマンド|void|set_save_value|
|コマンド|void|set_quick_save_value|
|コマンド|int|copy_save|
|コマンド|int|copy_quick_save|
|コマンド|int|change_save|
|コマンド|int|change_quick_save|
|コマンド|int|delete_save|
|コマンド|int|delete_quick_save|
|コマンド|int|inner_save|
|コマンド|int|inner_load|
|コマンド|int|clear_inner_save|
|コマンド|int|copy_inner_save|
|コマンド|int|check_inner_save|
|コマンド|str|get_current_save_scene_title|
|コマンド|str|get_current_save_message|
|コマンド|void|set_window_mode|
|コマンド|void|set_window_mode_default|
|コマンド|int|get_window_mode|
|コマンド|void|set_window_mode_size|
|コマンド|void|set_window_mode_size_default|
|コマンド|int|get_window_mode_size|
|コマンド|int|check_window_mode_size_enable|
|コマンド|void|set_all_volume|
|コマンド|void|set_all_volume_default|
|コマンド|int|get_all_volume|
|コマンド|void|set_bgm_volume|
|コマンド|void|set_bgm_volume_default|
|コマンド|int|get_bgm_volume|
|コマンド|void|set_koe_volume|
|コマンド|void|set_koe_volume_default|
|コマンド|int|get_koe_volume|
|コマンド|void|set_pcm_volume|
|コマンド|void|set_pcm_volume_default|
|コマンド|int|get_pcm_volume|
|コマンド|void|set_se_volume|
|コマンド|void|set_se_volume_default|
|コマンド|int|get_se_volume|
|コマンド|void|set_mov_volume|
|コマンド|void|set_mov_volume_default|
|コマンド|int|get_mov_volume|
|コマンド|void|set_sound_volume|
|コマンド|void|set_sound_volume_default|
|コマンド|int|get_sound_volume|
|コマンド|void|set_bgmfade_volume|
|コマンド|void|set_bgmfade_volume_default|
|コマンド|int|get_bgmfade_volume|
|コマンド|void|set_all_onoff|
|コマンド|void|set_all_onoff_default|
|コマンド|int|get_all_onoff|
|コマンド|void|set_bgm_onoff|
|コマンド|void|set_bgm_onoff_default|
|コマンド|int|get_bgm_onoff|
|コマンド|void|set_koe_onoff|
|コマンド|void|set_koe_onoff_default|
|コマンド|int|get_koe_onoff|
|コマンド|void|set_pcm_onoff|
|コマンド|void|set_pcm_onoff_default|
|コマンド|int|get_pcm_onoff|
|コマンド|void|set_se_onoff|
|コマンド|void|set_se_onoff_default|
|コマンド|int|get_se_onoff|
|コマンド|void|set_mov_onoff|
|コマンド|void|set_mov_onoff_default|
|コマンド|int|get_mov_onoff|
|コマンド|void|set_sound_onoff|
|コマンド|void|set_sound_onoff_default|
|コマンド|int|get_sound_onoff|
|コマンド|void|set_bgmfade_onoff|
|コマンド|void|set_bgmfade_onoff_default|
|コマンド|int|get_bgmfade_onoff|
|コマンド|void|set_koemode|
|コマンド|void|set_koemode_default|
|コマンド|int|get_koemode|
|コマンド|void|set_charakoe_onoff|
|コマンド|void|set_charakoe_onoff_default|
|コマンド|int|get_charakoe_onoff|
|コマンド|void|set_charakoe_volume|
|コマンド|void|set_charakoe_volume_default|
|コマンド|int|get_charakoe_volume|
|コマンド|void|set_jitan_normal_onoff|
|コマンド|void|set_jitan_normal_onoff_default|
|コマンド|int|get_jitan_normal_onoff|
|コマンド|void|set_jitan_auto_mode_onoff|
|コマンド|void|set_jitan_auto_mode_onoff_default|
|コマンド|int|get_jitan_auto_mode_onoff|
|コマンド|void|set_jitan_koe_replay_onoff|
|コマンド|void|set_jitan_koe_replay_onoff_default|
|コマンド|int|get_jitan_koe_replay_onoff|
|コマンド|void|set_jitan_speed|
|コマンド|void|set_jitan_speed_default|
|コマンド|int|get_jitan_speed|
|コマンド|void|set_message_speed|
|コマンド|void|set_message_speed_default|
|コマンド|int|get_message_speed|
|コマンド|void|set_message_nowait|
|コマンド|void|set_message_nowait_default|
|コマンド|int|get_message_nowait|
|コマンド|void|set_auto_mode_moji_wait|
|コマンド|void|set_auto_mode_moji_wait_default|
|コマンド|int|get_auto_mode_moji_wait|
|コマンド|void|set_auto_mode_min_wait|
|コマンド|void|set_auto_mode_min_wait_default|
|コマンド|int|get_auto_mode_min_wait|
|コマンド|void|set_filter_color_r|
|コマンド|void|set_filter_color_r_default|
|コマンド|int|get_filter_color_r|
|コマンド|void|set_filter_color_g|
|コマンド|void|set_filter_color_g_default|
|コマンド|int|get_filter_color_g|
|コマンド|void|set_filter_color_b|
|コマンド|void|set_filter_color_b_default|
|コマンド|int|get_filter_color_b|
|コマンド|void|set_filter_color_a|
|コマンド|void|set_filter_color_a_default|
|コマンド|int|get_filter_color_a|
|コマンド|void|set_object_disp_onoff|
|コマンド|void|set_object_disp_onoff_default|
|コマンド|int|get_object_disp_onoff|
|コマンド|void|set_global_extra_switch_onoff|
|コマンド|void|set_global_extra_switch_onoff_default|
|コマンド|int|get_global_extra_switch_onoff|
|コマンド|void|set_global_extra_mode_value|
|コマンド|void|set_global_extra_mode_value_default|
|コマンド|int|get_global_extra_mode_value|
|コマンド|void|set_saveload_alert_onoff|
|コマンド|void|set_sleep_onoff|
|コマンド|void|set_no_wipe_anime_onoff|
|コマンド|void|set_no_mwnd_anime_onoff|
|コマンド|void|set_skip_wipe_anime_onoff|
|コマンド|void|set_wheel_next_message_onoff|
|コマンド|void|set_koe_dont_stop_onoff|
|コマンド|void|set_skip_unread_message_onoff|
|コマンド|void|set_play_silent_sound_onoff|
|コマンド|void|set_saveload_alert_onoff_default|
|コマンド|void|set_sleep_onoff_default|
|コマンド|void|set_no_wipe_anime_onoff_default|
|コマンド|void|set_no_mwnd_anime_onoff_default|
|コマンド|void|set_skip_wipe_anime_onoff_default|
|コマンド|void|set_wheel_next_message_onoff_default|
|コマンド|void|set_koe_dont_stop_onoff_default|
|コマンド|void|set_skip_unread_message_onoff_default|
|コマンド|void|set_play_silent_sound_onoff_default|
|コマンド|int|get_saveload_alert_onoff|
|コマンド|int|get_sleep_onoff|
|コマンド|int|get_no_wipe_anime_onoff|
|コマンド|int|get_no_mwnd_anime_onoff|
|コマンド|int|get_skip_wipe_anime_onoff|
|コマンド|int|get_wheel_next_message_onoff|
|コマンド|int|get_koe_dont_stop_onoff|
|コマンド|int|get_skip_unread_message_onoff|
|コマンド|int|get_play_silent_sound_onoff|
|コマンド|void|set_font_name|
|コマンド|str|get_font_name|
|コマンド|int|is_font_exist|
|コマンド|void|set_font_bold|
|コマンド|void|set_font_bold_default|
|コマンド|int|get_font_bold|
|コマンド|void|set_font_decoration|
|コマンド|void|set_font_decoration_default|
|コマンド|int|get_font_decoration|
|コマンド|void|create_capture_buffer|
|コマンド|void|destroy_capture_buffer|
|コマンド|void|capture_and_save_buffer_to_png|
</table>
</div>
+ syscommenu 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|set_enable|
|コマンド|void|set_disable|
</table>
</div>
+ mwndbtn 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|set_enable|
|コマンド|void|set_disable|
</table>
</div>
+ script 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|void|set_auto_savepoint_off|
|コマンド|void|set_auto_savepoint_on|
|コマンド|void|set_skip_disable|
|コマンド|void|set_skip_enable|
|コマンド|void|set_ctrl_skip_disable|
|コマンド|void|set_ctrl_skip_enable|
|コマンド|int|check_skip|
|コマンド|void|set_stop_skip_by_key_disable|
|コマンド|void|set_stop_skip_by_key_enable|
|コマンド|void|set_end_msg_by_key_disable|
|コマンド|void|set_end_msg_by_key_enable|
|コマンド|void|set_skip_unread_message_flag|
|コマンド|int|get_skip_unread_message_flag|
|コマンド|void|start_auto_mode|
|コマンド|void|end_auto_mode|
|コマンド|void|set_auto_mode_moji_wait|
|コマンド|void|set_auto_mode_moji_wait_default|
|コマンド|int|get_auto_mode_moji_wait|
|コマンド|void|set_auto_mode_min_wait|
|コマンド|void|set_auto_mode_min_wait_default|
|コマンド|int|get_auto_mode_min_wait|
|コマンド|void|set_auto_mode_moji_cnt|
|コマンド|void|set_message_speed|
|コマンド|void|set_message_speed_default|
|コマンド|int|get_message_speed|
|コマンド|void|set_message_nowait_flag|
|コマンド|int|get_message_nowait_flag|
|コマンド|void|set_msg_async_mode_on|
|コマンド|void|set_msg_async_mode_on_once|
|コマンド|void|set_msg_async_mode_off|
|コマンド|void|set_hide_mwnd_disable|
|コマンド|void|set_hide_mwnd_enable|
|コマンド|void|set_msg_back_disable|
|コマンド|void|set_msg_back_enable|
|コマンド|void|set_msg_back_off|
|コマンド|void|set_msg_back_on|
|コマンド|void|set_msg_back_disp_off|
|コマンド|void|set_msg_back_disp_on|
|コマンド|void|set_msg_back_proc_off|
|コマンド|void|set_msg_back_proc_on|
|コマンド|void|set_mouse_move_by_key_disable|
|コマンド|void|set_mouse_move_by_key_enable|
|コマンド|void|set_mouse_disp_off|
|コマンド|void|set_mouse_disp_on|
|コマンド|void|set_key_disable|
|コマンド|void|set_key_enable|
|コマンド|void|set_mwnd_anime_on_flag|
|コマンド|int|get_mwnd_anime_on_flag|
|コマンド|void|set_mwnd_anime_off_flag|
|コマンド|int|get_mwnd_anime_off_flag|
|コマンド|void|set_mwnd_disp_off_flag|
|コマンド|int|get_mwnd_disp_off_flag|
|コマンド|void|set_quake_stop_flag|
|コマンド|int|get_quake_stop_flag|
|コマンド|void|set_vsync_wait_off_flag|
|コマンド|int|get_vsync_wait_off_flag|
|コマンド|void|set_koe_dont_stop_on_flag|
|コマンド|int|get_koe_dont_stop_on_flag|
|コマンド|void|set_koe_dont_stop_off_flag|
|コマンド|int|get_koe_dont_stop_off_flag|
|コマンド|void|set_shortcut_disable|
|コマンド|void|set_shortcut_enable|
|コマンド|void|start_bgmfade|
|コマンド|void|end_bgmfade|
|コマンド|void|set_skip_trigger|
|コマンド|void|ignore_r_on|
|コマンド|void|ignore_r_off|
|コマンド|void|set_cursor_no|
|コマンド|int|get_cursor_no|
|コマンド|void|set_time_stop_flag|
|コマンド|void|set_counter_time_stop_flag|
|コマンド|void|set_frame_action_time_stop_flag|
|コマンド|void|set_stage_time_stop_flag|
|コマンド|int|get_time_stop_flag|
|コマンド|int|get_counter_time_stop_flag|
|コマンド|int|get_frame_action_time_stop_flag|
|コマンド|int|get_stage_time_stop_flag|
</table>
</div>
+ system 型
<div class="table-container">
<table>
|タイプ|型|名前|
|コマンド|int|check_active|
|コマンド|int|check_debug_flag|
|コマンド|void|shell_open_file|
|コマンド|void|shell_open_web|
|コマンド|int|check_file_exist|
|コマンド|int|check_file_exist_save_dir|
|コマンド|void|check_dummy_file_once|
|コマンド|void|open_dialog_for_chihaya_bench|
|コマンド|str|get_spec_info_for_chihaya_bench|
|コマンド|int|debug_messagebox_ok|
|コマンド|int|debug_messagebox_okcancel|
|コマンド|int|debug_messagebox_yesno|
|コマンド|int|debug_messagebox_yesnocancel|
|コマンド|void|debug_write_log|
|コマンド|void|get_calendar|
|コマンド|int|get_unix_time|
</table>
</div>
+ excall 型
<div class="table-container">
<table>
|タイプ|型|名前|
|プロパティ|excall|[]|
|コマンド|void|alloc|
|コマンド|int|check_alloc|
|コマンド|int|is_excall|
|コマンド|void|free|
|プロパティ|stagelist|stage|
|プロパティ|stage|back|
|プロパティ|stage|front|
|プロパティ|stage|next|
|プロパティ|counterlist|counter|
|プロパティ|frameaction|frame_action|
|プロパティ|frameactionlist|frame_action_ch|
|プロパティ|intlist|f|
</table>
</div>

■ キーコード

	未対応キー：[F1]～[F12]、[半角／全角 | 漢字]、[Caps Lock | 英数]、[カタカナ ひらがな | ローマ字]、[Print Screen] など

<div class="table-container">
<table>
|000||064||128||192| @ |
|001||065| A |129||193||
|002||066| B |130||194||
|003||067| C |131||195||
|004||068| D |132||196||
|005||069| E |133||197||
|006||070| F |134||198||
|007||071| G |135||199||
|008|[Back Space]|072| H |136||200||
|009|[Tab]|073| I |137||201||
|010||074| J |138||202||
|011||075| K |139||203||
|012||076| L |140||204||
|013|[Enter]|077| M |141||205||
|014||078| N |142||206||
|015||079| O |143||207||
|016|[Shift]|080| P |144|[Num Lock]|208||
|017|[Ctrl]|081| Q |145|[Scroll Lock]|209||
|018|[Alt]|082| R |146||210||
|019|[Pause]|083| S |147||211||
|020||084| T |148||212||
|021||085| U |149||213||
|022||086| V |150||214||
|023||087| W |151||215||
|024||088| X |152||216||
|025|[漢字]|089| Y |153||217||
|026||090| Z |154||218||
|027|[Esc]|091|[L-Windows]|155||219| [ |
|028|[変換]|092|[R-Windows]|156||220| \ |
|029|[無変換]|093|[Context]|157||221| ] |
|030||094||158||222|^|
|031||095||159||223||
|032|[Space]|096|[Num 0]|160|[L-Shift]|224||
|033|[Page Up]|097|[Num 1]|161|[R-Shift]|225||
|034|[Page Down]|098|[Num 2]|162|[L-Ctrl]|226| \ （＼）|
|035|[End]|099|[Num 3]|163|[R-Ctrl]|227||
|036|[Home]|100|[Num 4]|164|[L-Alt]|228||
|037|[←]|101|[Num 5]|165|[R-Alt]|229||
|038|[↑]|102|[Num 6]|166||230||
|039|[→]|103|[Num 7]|167||231||
|040|[↓]|104|[Num 8]|168||232||
|041||105|[Num 9]|169||233||
|042||106|[Num *]|170||234||
|043||107|[Num +]|171||235||
|044||108||172||236||
|045|[Insert]|109|[Num -]|173||237||
|046|[Delete]|110|[Num .]|174||238||
|047||111|[Num /]|175||239||
|048| 0 |112||176||240||
|049| 1 |113||177||241||
|050| 2 |114||178||242||
|051| 3 |115||179||243||
|052| 4 |116||180||244||
|053| 5 |117||181||245||
|054| 6 |118||182||246||
|055| 7 |119||183||247||
|056| 8 |120||184||248||
|057| 9 |121||185||249||
|058||122||186| : |250||
|059||123||187| ; |251||
|060||124||188| , |252||
|061||125||189| - |253||
|062||126||190| . |254||
|063||127||191| / |255||
</table>
</div>


■ ワイプタイプ一覧

<pre>
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０００　クロスフェード（デフォルト用）
００１　ワイプ効果なし（すぐ表示）
００２　ワイプ効果なし（待って表示）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０１０　４×４のじわだし９パターン
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 128（パターンのＸサイズ）
            [Op2]: 1 - 128（パターンのＹサイズ）
０１１　４×４のじわだし７パターン
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 128（パターンのＸサイズ）
            [Op2]: 1 - 128（パターンのＹサイズ）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０２０　４×４の回るように
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 128（パターンのＸサイズ）
            [Op2]: 1 - 128（パターンのＹサイズ）
            [Op3]: 0 - 7  （パターンの開始位置と方向が変わります）
            [Op4]: 0, 1   （1=描画順序反転）
０２１　４×４の改行すように
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 128（パターンのＸサイズ）
            [Op2]: 1 - 128（パターンのＹサイズ）
            [Op3]: 0 - 7  （パターンの開始位置と方向が変わります）
            [Op4]: 0, 1   （1=描画順序反転）
０２２　４×４の折り返すように
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 128（パターンのＸサイズ）
            [Op2]: 1 - 128（パターンのＹサイズ）
            [Op3]: 0 - 7  （パターンの開始位置と方向が変わります）
            [Op4]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０３０　８×８の回るように
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 64 （パターンのＸサイズ）
            [Op2]: 1 - 64 （パターンのＹサイズ）
            [Op3]: 0 - 7  （パターンの開始位置と方向が変わります）
            [Op4]: 0, 1   （1=描画順序反転）
０３１　８×８の改行すように
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 64 （パターンのＸサイズ）
            [Op2]: 1 - 64 （パターンのＹサイズ）
            [Op3]: 0 - 7  （パターンの開始位置と方向が変わります）
            [Op4]: 0, 1   （1=描画順序反転）
０３２　８×８の折り返すように
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 64 （パターンのＸサイズ）
            [Op2]: 1 - 64 （パターンのＹサイズ）
            [Op3]: 0 - 7  （パターンの開始位置と方向が変わります）
            [Op4]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０４０　ランダム
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 128（パターンのＸサイズ）
            [Op2]: 1 - 128（パターンのＹサイズ）
０４１　ランダムライン
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （0=縦ライン 1=横ライン）
            [Op2]: 1 - 128（パターンのサイズ）
０４２　ランダム斜めライン
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （0=斜めライン 1=逆斜めライン）
            [Op2]: 1 - 128（パターンのサイズ）
０４３　ランダムクロス
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 128（パターンのＸサイズ）
            [Op2]: 1 - 128（パターンのＹサイズ）
０４４　ランダム斜めクロス
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 1 - 128（パターンサイズ）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０５０　シミ
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （暗いとこから／明るいとこから）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０６０　１周
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （開始軸 0,1=横軸 2,3=縦軸）
            [Op2]: 0, 1   （1=描画順序反転）
０６１　半周
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （開始軸 0=横軸 1=縦軸）
            [Op2]: 0, 1   （1=描画順序反転）
０６２　分割周
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 4  （分割数 0=４分割 1=８分割 2=１６分割 3=３２分割 4=６４分割）
            [Op2]: 0, 1   （1=描画順序反転）
０６３　中心扇
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （1=描画順序反転）
０６４　角扇
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （支点角 0=左上角 1=右上角 2=左下角 3=右下角）
            [Op2]: 0, 1   （1=描画順序反転）
０６５　縁扇
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （支点縁 0=左縁 1=右縁 2=左縁 3=右縁）
            [Op2]: 0, 1   （1=描画順序反転）
０６６　縁扇２
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （支点縁 0=左縁 1=右縁 2=左縁 3=右縁）
            [Op2]: 0, 1   （1=描画順序反転）
０６７　角扇（遠）
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （支点角 0=左上角 1=右上角 2=左下角 3=右下角）
            [Op2]: 0, 1   （1=描画順序反転）
０６８　縁扇（遠）
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （支点縁 0=左縁 1=右縁 2=左縁 3=右縁）
            [Op2]: 0, 1   （1=描画順序反転）
０６９　縁扇２（遠）
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （支点縁 0=左縁 1=右縁 2=左縁 3=右縁）
            [Op2]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０７０　小矩形の１周
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0 - 3  （開始軸 0,1=横軸 2,3=縦軸）
            [Op5]: 0, 1   （1=描画順序反転）
０７１　小矩形の半周
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0, 1   （開始軸 0=横軸 1=縦軸）
            [Op5]: 0, 1   （1=描画順序反転）
０７２　小矩形の分割周
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0 - 4  （分割数 0=４分割 1=８分割 2=１６分割 3=３２分割 4=６４分割）
            [Op5]: 0, 1   （1=描画順序反転）
０７３　小矩形の中心扇
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0, 1   （1=描画順序反転）
０７４　小矩形の角扇
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0 - 3  （支点角 0=左上角 1=右上角 2=左下角 3=右下角）
            [Op5]: 0, 1   （1=描画順序反転）
０７５　小矩形の縁扇
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0 - 3  （支点縁 0=左縁 1=右縁 2=左縁 3=右縁）
            [Op5]: 0, 1   （1=描画順序反転）
０７６　小矩形の縁扇２
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0 - 3  （支点縁 0=左縁 1=右縁 2=左縁 3=右縁）
            [Op5]: 0, 1   （1=描画順序反転）
０７７　小矩形の角扇（遠）
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0 - 3  （支点角 0=左上角 1=右上角 2=左下角 3=右下角）
            [Op5]: 0, 1   （1=描画順序反転）
０７８　小矩形の縁扇（遠）
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0 - 3  （支点縁 0=左縁 1=右縁 2=左縁 3=右縁）
            [Op5]: 0, 1   （1=描画順序反転）
０７９　小矩形の縁扇２（遠）
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0 - 3  （支点縁 0=左縁 1=右縁 2=左縁 3=右縁）
            [Op5]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０８０　四角形
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （1=描画順序反転）
０８１　菱形
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （1=描画順序反転）
０８２　十字
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （1=描画順序反転）
０８３　テレビ
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
０９０　小矩形の四角形
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0, 1   （1=描画順序反転）
０９１　小矩形の菱形
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0, 1   （1=描画順序反転）
０９２　小矩形の十字
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0, 1   （1=描画順序反転）
０９３　小矩形のテレビ
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=矩形パターンを半分ずらす。※矩形サイズが偶数値に補正されます）
            [Op4]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
１００　指定方向から
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （方向 0=上から 1=下から 2=左から 3=右から）
１０１　指定方向からスライス
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （方向 0=上から 1=下から 2=左から 3=右から）
            [Op2]: 2 - 128（スライスの幅）
１０２　指定方向からブラインド
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （方向 0=上から 1=下から 2=左から 3=右から）
            [Op2]: 2 - 128（ブラインドの幅）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
１１０　指定の斜め方向から
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （方向 0=左上から 1=右上から 2=左下から 3=右下から）
１１１　指定方向からブロックブラインド
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0 - 3  （方向 0=上から 1=下から 2=左から 3=右から）
            [Op2]: 2 - 128（ブラインドの幅）
            [Op3]: 1 - 128（ブロックの幅）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
１２０　両方向から
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （方向 0=上下から 1=左右から）
            [Op2]: 0, 1   （1=描画順序反転）
１２１　両方向からスライス
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （方向 0=上下から 1=左右から）
            [Op2]: 2 - 128（スライスの幅）
            [Op3]: 0, 1   （1=描画順序反転）
１２２　両方向からブラインド
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （方向 0=上下から 1=左右から）
            [Op2]: 2 - 128（ブラインドの幅）
            [Op3]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
１３０　両方向からストライプ
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （方向 0=上下から 1=左右から）
            [Op2]: 1 - 128（ストライプの幅）
１３１　両方向からストライプ２
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （方向 0=上下から 1=左右から）
            [Op2]: 1 - 128（ストライプの幅）
１３２　両方向からブロックブラインド
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （方向 0=上下から 1=左右から）
            [Op2]: 2 - 128（ブラインドの幅）
            [Op3]: 1 - 128（ブロックの幅）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
１４０　４方向から
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 0, 1   （1=描画順序反転）
１４１　４方向からスライス
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 2 - 128（スライスの幅）
            [Op2]: 0, 1   （1=描画順序反転）
１４２　４方向からブラインド
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 2 - 128（ブラインドの幅）
            [Op2]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
１５０　小矩形の４方向から
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 0, 1   （1=描画順序反転）
１５１　小矩形の４方向からスライス
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 2 - 128（スライスの幅）
            [Op4]: 0, 1   （1=描画順序反転）
１５２　小矩形の４方向からブラインド
            [Op0]: 0 - 8  （フェード効果）
            [Op1]: 4 - 128（矩形のＸサイズ）
            [Op2]: 4 - 128（矩形のＹサイズ）
            [Op3]: 2 - 128（ブラインドの幅）
            [Op4]: 0, 1   （1=描画順序反転）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
２００　スライドイン
            [Op0]: 0 - 3  （方向 0=上から 1=下から 2=左から 3=右から）
            [Op1]: 0 - 2  （次絵の動き 0=動かない 1=スライドして出てくる 2=拡大して出てくる）
            [Op2]: 0 - 2  （元絵の動き 0=動かない 1=スライドして消える 2=縮小して消える）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
２１０　次絵を拡大表示
            [Op0]: 0=中心から
                   1=左上から 2=右上から 3=左下から 4=右下から
                   5=中心から上下へ 6=中心から左右へ
                   7=上から 8=下から 9=左から 10=右から
                   11=中心座標指定
            [Op1]: 0, 1 （1=フェードＩＮ）
            [Op2]: Ｘ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
            [Op3]: Ｙ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
２１１　元絵を縮小表示
            [Op0]: 0=中心から
                   1=左上から 2=右上から 3=左下から 4=右下から
                   5=中心から上下へ 6=中心から左右へ
                   7=上から 8=下から 9=左から 10=右から
                   11=中心座標指定
            [Op1]: 0, 1 （1=フェードＯＵＴ）
            [Op2]: Ｘ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
            [Op3]: Ｙ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
２１２　元絵を拡大後、次絵に変更して縮小表示
            [Op0]: 0=中心から
                   1=左上から 2=右上から 3=左下から 4=右下から
                   5=中心から上下へ 6=中心から左右へ
                   7=上から 8=下から 9=左から 10=右から
                   11=中心座標指定
            [Op1]: 未使用
            [Op2]: Ｘ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
            [Op3]: Ｙ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
２１３　次絵を拡大状態からフェードＩＮしながら縮小表示
            [Op0]: 0=中心から
                   1=左上から 2=右上から 3=左下から 4=右下から
                   5=中心から上下へ 6=中心から左右へ
                   7=上から 8=下から 9=左から 10=右から
                   11=中心座標指定
            [Op1]: 未使用
            [Op2]: Ｘ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
            [Op3]: Ｙ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
２１４　元絵をフェードＯＵＴしながら拡大表示
            [Op0]: 0=中心から
                   1=左上から 2=右上から 3=左下から 4=右下から
                   5=中心から上下へ 6=中心から左右へ
                   7=上から 8=下から 9=左から 10=右から
                   11=中心座標指定
            [Op1]: 未使用
            [Op2]: Ｘ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
            [Op3]: Ｙ座標（Op0=11用です。ゲーム画面外を指定した場合は補正します）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
２１５　ワイプ開始(終了)時の矩形範囲を指定して、次(元)絵を拡大(縮小)表示
            [Op0]: 0, 1, 2 （0=フェードなし, 1=フェードＩＮ, 2=フェードＯＵＴ）
            [Op1]: 0, 1 （0=拡大, 1=縮小）
            [Op2]: 始点Ｘ座標（ゲーム画面外を指定した場合は補正します）
            [Op3]: 始点Ｙ座標（ゲーム画面外を指定した場合は補正します）
            [Op4]: 終点Ｘ座標（ゲーム画面外を指定した場合は補正します）
            [Op5]: 終点Ｙ座標（ゲーム画面外を指定した場合は補正します）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
２２０　クロスラスタ（元絵がフェードアウトしていき、次絵がフェードインしてくる）（★注意１）
            [Op0]: 0, 1 （縦／横）
            [Op1]: カットピクセル数
            [Op2]: 波の数
            [Op3]: 歪みパワー
            
２２１　ラスタ（Op4で次絵がフェードイン／元絵がフェードアウト）
            [Op0]: 0, 1 （縦／横）
            [Op1]: カットピクセル数
            [Op2]: 波の数
            [Op3]: 歪みパワー
            [Op4]: 0, 1 （次絵がフェードイン／元絵がフェードアウト）

[ ★★★注意１★★★ ]

２２０番のワイプは、少しビデオメモリを使います。ビデオメモリが足りない場合は他のワイプに切り替わります。
（2011/9/6 の時点で、ユーザの 0.1% 未満だと思います。）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
２３０　クロスモザイク
            [Op0]: 0 - 9（モザイクの粗さ）（0=小さいほど細かく、9=大きいほど粗くなる）

２３１　モザイク
            [Op0]: 0 - 9（モザイクの粗さ）（0=小さいほど細かく、9=大きいほど粗くなる）
            [Op1]: 0, 1 （次絵がフェードイン／元絵がフェードアウト）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
２４０　クロス爆発ブラー（指定した点を基準に拡散ブラー、点から離れるほど強くブラーがかかります）（★注意１）
            [Op0]: 中心Ｘ     指定可能な座標はゲーム画面内です。範囲外も指定可能ですが一部環境で見え方が変わります（★注意２）
            [Op1]: 中心Ｙ     指定可能な座標はゲーム画面内です。範囲外も指定可能ですが一部環境で見え方が変わります（★注意２）
            [Op2]: 0 - 10     透明度効果
            [Op3]: 0, 1       透明度効果の反転
            [Op4]: 0 - 10     ブラー効果
            [Op5]: 0, 1       ブラー効果の反転
            [Op6]: - 100 -    ブラーの強さ（１００あたりを基準に作り始めると良いです。負の値も指定可能ですが一部環境で見え方が変わります（★注意２））

２４１　爆発ブラー（指定した点を基準に拡散ブラー、点から離れるほど強くブラーがかかります）（★注意１）
            [Op0]: 中心Ｘ     指定可能な座標はゲーム画面内です。範囲外も指定可能ですが一部環境で見え方が変わります（★注意２）
            [Op1]: 中心Ｙ     指定可能な座標はゲーム画面内です。範囲外も指定可能ですが一部環境で見え方が変わります（★注意２）
            [Op2]: 0 - 10     透明度効果
            [Op3]: 0, 1       透明度効果の反転
            [Op4]: 0 - 10     ブラー効果
            [Op5]: 0, 1       ブラー効果の反転
            [Op6]: - 100 -    ブラーの強さ（１００あたりを基準に作り始めると良いです。負の値も指定可能ですが一部環境で見え方が変わります（★注意２））
            [Op7]: 0, 1       0=元絵 1=次絵

２４２　クロスクェイクブラー（★注意１）
            [Op0]: 0 - 10     透明度効果
            [Op1]: 0, 1       透明度効果の反転
            [Op2]: 0 - 10     ブラー効果
            [Op3]: 0, 1       ブラー効果の反転
            [Op4]: - 100 -    ブラーの強さ（１００あたりを基準に作り始めると良いです。負の値も指定可能ですが一部環境で見え方が変わります（★注意２））

２４３　クェイクブラー（★注意１）
            [Op0]: 0 - 10     透明度効果
            [Op1]: 0, 1       透明度効果の反転
            [Op2]: 0 - 10     ブラー効果
            [Op3]: 0, 1       ブラー効果の反転
            [Op4]: - 100 -    ブラーの強さ（１００あたりを基準に作り始めると良いです。負の値も指定可能ですが一部環境で見え方が変わります（★注意２））
            [Op5]: 0, 1       0=元絵 1=次絵

[ ★★★注意１★★★ ]

２４０～２４３番のワイプは、少しビデオメモリを使います。ビデオメモリが足りない場合は他のワイプに切り替わります。
（2011/9/6 の時点で、ユーザの 0.1% 未満だと思います。）

[ ★★★注意２★★★ ]

２４０～２４１番で中心を画面外にしたり、２４０～２４３番でブラーの強さをマイナスにすると、
一部環境で、ワイプ画像の端に、黒い部分がつくことがあります。
一部環境とは、「２の累乗以外のテクスチャが作成できない環境」になります。ノートＰＣなどがよく該当します。

環境の調べ方は、Siglusをデバッグモードで起動し、
「ウィンドウ → システム情報 → Direct3D情報 → デバイス情報 → ２の累乗以外のテクスチャ」を見て下さい。
この項目が「No」であれば、２の累乗以外のテクスチャが作成できない環境です。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
３００　３Ｄで回転
            [Op0]: 0, 1    （回転の向き 0=時計回り 1=反時計回り）
            [Op1]: 1 - 1799（視野角（1=0.1度、1799=179.9度）小さいと視点が遠ざかります）
            [Op2]: 0 - 2   （0=通常、1=インのみ、2=アウトのみ）

            詳しくは [[３Ｄ回転ワイプ]] を参照して下さい。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
３０１　３Ｄでページをめくる
            [Op0]: 0, 1    （回転の向き 0=時計回り 1=反時計回り）
            [Op1]: 1 - 1799（視野角（1=0.1度、1799=179.9度）小さいと視点が遠ざかります）
            [Op2]: 0 - 2   （0=通常、1=インのみ、2=アウトのみ）

            詳しくは [[３Ｄ回転ワイプ]] を参照して下さい。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
９００　マスクワイプ
            [Op0]: 0 - 8  （フェード効果）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
９０１　マスク拡大ワイプ
            [Op0]: 0, 1  （拡大／縮小）
            [Op1]: 拡大率（1000=原寸  2000=２倍）
            [Op2]: 回転数（0=回転なし マイナス値で逆回転）
            [Op3]: 分割  （0,1=そのまま  2以上=ワイプ範囲を分割  最大=64）
            [Op4]: 0, 1  （1=分割したパターンを半ずらしで表示）

            ≪拡大率の補足≫
                指定されたマスク画像の真ん中を中心として拡大します。
                拡大した結果が画面全体を覆うように調整する必要があります。
                例えば、100×100のサイズのマスク画像を２倍に拡大しても200×200の範囲が覆われるだけです。
                最低でも８倍する事で800×800のサイズを覆うことになります。
                さらに中央部分の完全マスク部分で覆うとなると100×100サイズのマスクでは小さすぎると言えます。
                ゲーム画面のサイズと同じ大きさか、それ以上のサイズのマスク画像を用意するのが望ましいです。

            ≪分割の補足≫
                例えば、 4 を指定すると、縦を４分割、横を４分割で合計１６分割されたマスクズームワイプになります。
                分割すると、上記の拡大率の調整に影響があります。
                ４分割するなら、分割しない場合に比べて４分の１の拡大率で、画面全体を覆う事ができます。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
</pre>


■メッセージウィンドウ開閉アニメタイプ一覧

<div class="table-container">
<table>
<caption>アニメタイプ</caption>
|00|アニメなし|
|01|フェードイン／フェードアウト|
|02|上から|
|03|下から|
|04|左から|
|05|右から|
|06|上下近いほうから|
|07|左右近いほうから|
|08|上下左右近いほうから|
|09|中心に対して左右拡大（上下拡大）|
|10|中心に対して左右拡大（上下縮小）|
|11|中心に対して左右拡大（上下そのまま）|
|12|中心に対して左右縮小（上下拡大）|
|13|中心に対して左右縮小（上下縮小）|
|14|中心に対して左右縮小（上下そのまま）|
|15|中心に対して左右そのまま（上下拡大）|
|16|中心に対して左右そのまま（上下縮小）|
|17|左端に対して左右縮小|
|18|右端に対して左右縮小|
|19|上端に対して左右縮小|
|20|下端に対して左右縮小|
|21|左上角に対して左右縮小|
|22|右上角に対して左右縮小|
|23|左下角に対して左右縮小|
|24|右下角に対して左右縮小|
|25|画面左端に対して左右縮小|
|26|画面右端に対して左右縮小|
|27|画面上端に対して左右縮小|
|28|画面下端に対して左右縮小|
<!--
|29|中心に対して縮小しながら右に１回転|
|30|中心に対して縮小しながら左に１回転|
|31|中心に対して縮小しながら右に２回転|
|32|中心に対して縮小しながら左に２回転|
|33|中心に対して拡大しながら右に１回転|
|34|中心に対して拡大しながら左に１回転|
|35|中心に対して拡大しながら右に２回転|
|36|中心に対して拡大しながら左に２回転|
|37|中心に対して上下縮小しながら右に１回転|
|38|中心に対して上下縮小しながら左に１回転|
|39|中心に対して左右縮小しながら右に１回転|
|40|中心に対して左右縮小しながら左に１回転|
|41|中心に対して上下縮小しながら右に半回転|
|42|中心に対して上下縮小しながら左に半回転|
|43|中心に対して左右縮小しながら右に半回転|
|44|中心に対して左右縮小しながら左に半回転|
|45|中心に対して上下縮小しながら右に四半回転|
|46|中心に対して上下縮小しながら左に四半回転|
|47|中心に対して左右縮小しながら右に四半回転|
|48|中心に対して左右縮小しながら左に四半回転|
-->
</table>
</div>

