/**
 * 環境BGMオブジェクト
 */
class KAGEnvBgm {

    var env;

    var wait;
    var waitFade;
    
    /**
     * コンストラクタ
     */
    function KAGEnvBgm(env) {
        this.env = env;
    }

    /**
     * 再生処理
     * @param param 再生対象ファイル
     */
    function play(param, elm) {
        if (param !== void) {
            var time = +elm.time;
            if (elm.noxchg) {
                if (time > 0)  {
                    kag.bgm.fadeIn(%[ storage:param, loop:elm.loop, time:time, start:elm.start]);
                } else {
                    kag.bgm.play(%[ storage:param, loop:elm.loop, paused:elm.paused, start:elm.start]);
                }
            } else {
                if (time > 0 || +elm.intime > 0) {
                    kag.bgm.exchange(%[ storage:param, loop:elm.loop, time:time, intime:elm.intime, outtime:elm.outtime, overlap:elm.overlap, start:elm.start]);
                } else {
                    kag.bgm.play(%[ storage:param, loop:elm.loop, paused:elm.paused, start:elm.start]);
                }
            }
            kag.clearBgmStop();
            kag.clearBgmLabel();
            // 再生既読フラグ
            kag.sflags["bgm_" + (param.toUpperCase())] = true;
        }
    }

    /**
     * 停止処理
     * @param param フェードアウト時間
     */
    function stop(param, elm) {
        if (+param > 0) {
            kag.bgm.fadeOut(%[ time: +param]);
        } else {
            kag.bgm.stop();
        }
    }

    /**
     * ポーズ処理
     * @param param フェードアウト時間
     */
    function pause(param, elm) {
        if (+param > 0) {
            kag.bgm.fadePause(%[ time: +param]);
        } else {
            kag.bgm.pause();
        }
    }

    /**
     * 再開
     */
    function resume(param, elm) {
        kag.bgm.resume();
    }

    /**
     * 音量フェード
     * @param param フェード時間
     */
    function fade(param, elm) {
        kag.bgm.fade(%[ time:elm.time, volume:param ]);
    }

    /**
     * 終了まち
     * @param param フェード時間
     */
    function setWait(param, elm) {
        wait = %[];
        (Dictionary.assign incontextof wait)(elm, false);
        if (wait.canskip === void) {
            wait.canskip = true;
        }
    }

    /**
     * 終了まち
     * @param param フェード時間
     */
    function setWaitFade(param, elm) {
        waitFade = %[];
        (Dictionary.assign incontextof waitFade)(elm, false);
        if (waitFade.canskip === void) {
            waitFade.canskip = true;
        }
    }

    var bgmcommands = %[
    tagname : null, 
    play : play incontextof this,
    stop : stop incontextof this,
    pause : pause incontextof this,
    resume : resume incontextof this,
    fade : fade incontextof this,
    wait : setWait incontextof this,
    waitfade : setWaitFade incontextof this,
    noxchg : null,
    loop : null,
    time : null,
    start : null,
    paused : null,
    intime : null,
    outtime : null,
    overlap : null,
    canskip : null,
        ];

    var doflag;
    
    /**
     * コマンドの実行
     * @param cmd コマンド
     * @param param パラメータ
     * @param elm 他のコマンドも含む全パラメータ
     * @return 実行が行われた場合 true
     */
    function doCommand(cmd, param, elm) {
        var func;
        if ((func = bgmcommands[cmd]) !== void) {
            if (func != null) {
                func(param, elm);
                doflag = true;
            }
            return true;
        }
        // 再生コマンドとみなす
        play(cmd, elm);
        doflag = true;
        return true;
    }

    /**
     * KAG タグ処理
     * @param elm 引数
     */
    function tagfunc(elm) {
        //dm("BGM 用ファンクション呼び出し!");
        doflag = false;
        wait = void;
        waitFade = void;
        foreach(elm, doCommand);
        // 何もしなかった場合、かつ、タグ名が bgm でなければそれを再生する
        if (!doflag && elm.tagname != "bgm") {
            play(elm.tagname, elm);
        }
        if (waitFade !== void) {
            return kag.waitBGMFade(waitFade);
        } else  if (wait !== void) {
            return kag.waitBGMStop(wait);
        }
        return 0;
    }
    
};
