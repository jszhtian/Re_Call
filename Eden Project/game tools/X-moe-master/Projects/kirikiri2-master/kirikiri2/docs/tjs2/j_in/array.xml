<?xml version="1.0" encoding="Shift_JIS" ?>
<doc>

<title>Array クラス</title>

<para>
<ptitle>Array クラス</ptitle>
　Array クラスは<kw>配列</kw>を扱うクラスです。<r/>
<r/>
　このクラスのオブジェクトを作成し、間接メンバ選択演算子によって指定された添え字を使って配列のように扱うことができます。添え字は整数です。0は先頭の要素を表し、1はその次の要素を表します。負の整数を指定すると、配列の最後から指定したものとして扱われます (-1 は最後の要素を表します)。<r/>
<example>
	var a = new Array();<r/>
	var i;<r/>
	for(i=0;i&lt;100;i++) a[i]=i;<r/>
</example>
<r/>
　配列の大きさは宣言する必要はありません。指定された添え字の大きさまで自動的にサイズが拡張され、何も値が代入されていない要素は void に初期化されます。<r/>
<r/>
　また、count プロパティがあり、これが配列のサイズを表しています。count プロパティに値を代入しても配列のサイズを変えることができます。<r/>
</para>


<para>
<ptitle>式中配列</ptitle>
　<tt><kw>[ ]</kw></tt> を使って、式中に <tt>Array</tt> クラスのオブジェクトをその場で記述することができます。<tt>[ ]</tt> にはカンマで区切り、初期要素となる式を列挙します。たとえば、<r/>
<tt>
	var ar = ["a", "b", "c"];
</tt>
　と記述すれば、<tt>ar</tt> に、 <tt>"a" "b" "c"</tt> の要素が入った <tt>Array</tt> クラスのオブジェクトへの参照が代入されます。<r/>
</para>

<para>
<ptitle>count</ptitle>
　count プロパティは、配列の大きさを表します。<r/>
</para>

<para>
<ptitle>load</ptitle>
　load メソッドは、配列をファイルから読み込みます。<r/>
<bq>
構文 : load(&lt;ファイル名>, &lt;モード=''>)<r/>
</bq>
　テキストファイルから配列を読み込みます。ファイルのテキストが一行づつ、各要素に入り、最終的に count プロパティはファイルの行数と同じになります。<r/>
　モードには、ファイルを読み込む際のモード文字列を指定します。これは TJS が動作している環境によって異なります。"o" に続いてオフセットを10進で指定するとファイルのそのバイト位置からの読み込みになります。<r/>
　TJS が動作している環境によってはこのメソッドと save メソッド、 saveStruct メソッドは使用できません。<r/>
　load メソッドは、この Array クラスのオブジェクト自身を返します。<r/>
</para>

<para>
<ptitle>save</ptitle>
　save メソッドは、配列をファイルに書き出します。<r/>
<bq>
構文 : save(&lt;ファイル名>, &lt;モード=''>)<r/>
</bq>
　配列をファイルに書き出します。一行ずつ、各メンバが出力されますが、オブジェクトやクラス、関数などへの参照は空行となります。<r/>
　モードには、ファイルを書き込む際のモード文字列を指定します。これは TJS が動作している環境によって異なりますが、吉里吉里の場合は "c" を指定するとファイルに簡単な暗号化がかかります ( そのまま load メソッドで読み込むことができます ) 。"z" を指定するとファイルを圧縮して保存できます ("c" と併用は出来ません; これもそのまま load メソッドで読み込むことができます)。"o" に続いてオフセットを10進で指定するとファイルのそのバイト位置からの書き込みになります。<r/>
　save メソッドは、この Array クラスのオブジェクト自身を返します。<r/>
</para>

<para>
<ptitle>split</ptitle>
　split メソッドは、文字列を分割します。<r/>
<bq>
構文 : split(&lt;パターン/デリミタ集合>, &lt;文字列>, &lt;(予約)>, &lt;空の要素を無視するか=false>)
</bq>
　配列を初期化し、この配列に、文字列をパターンまたはデリミタ集合で区切った物をコピーします。<r/>
　第１引数にはパターンまたはデリミタ集合を指定します。<r/>
　パターンは正規表現オブジェクトである必要があります。<r/>
　デリミタ集合には、区切り記号となる文字を指定します。文字列を指定することで区切り文字を複数指定できます。<r/>
　第３引数は将来のバージョンのために予約されています。<r/>
　空の要素を無視するか、では、空の要素 ( たとえばカンマをデリミタにしているときに ,,,,, など ) の場合にその要素を配列にコピーしない場合は true を指定します。<r/>
　引数の順番に注意してください。<r/>
</para>

<para>
<ptitle>join</ptitle>
　join メソッドは、配列を結合し、一つの文字列にします。<r/>
<bq>
構文 : join(&lt;デリミタ>, &lt;(予約)>, &lt;空の要素を無視するか=false>)
</bq>
　配列の各要素をデリミタで結合し、結合した文字列を返します。<r/>
　空の要素を無視するか、が true の場合は、要素中の void は無視されます。<r/>
<example>
	var ar = [ "a", "b", void, "d" ];<r/>
	var s1 = ar.join(","); // s1 には "a,b,,d" が代入される<r/>
	var s2 = ar.join(",",,true); // s2 には "a,b,d" が代入される<r/>
</example>
</para>

<para>
<ptitle>reverse</ptitle>
　reverse メソッドは、配列の要素の並びを逆さまにします。<r/>
<bq>
構文 : reverse()<r/>
</bq>
</para>

<para>
<ptitle>sort</ptitle>
　sort メソッドは、配列をソート(並び替え)します。<r/>
<bq>
構文 : sort(&lt;ソート順='+'>, &lt;安定ソートを行うか=false>)
</bq>
　ソート順は以下の文字列のどれかです。昇順では小さい物から大きい物へと並び替えられ、降順はその逆です。省略すると '+' を指定されたと見なされます。<r/>
<bq>
"+"  : 昇順 (通常の &lt; 演算子での比較)<r/>
"-"  : 降順<r/>
"0"  : 数値による昇順 ( 10,2,1 は 1,2,10 に並び替えられます )<r/>
"9"  : 数値による降順<r/>
"a"  : 文字列による昇順 ( "a","c","b" は "a","b","c" に並び替えられます )<r/>
"z"  : 文字列による降順<r/>
</bq>
　ソート順の文字の変わりに関数を指定することが出来ます。関数は２つの引数を持ちます。第１引数が第２引数よりも前に来るべき場合に真を返す関数を指定します (JavaScript の sort メソッドに渡す関数と、戻り値の意味が違うので注意してください )。<r/>
<r/>
　第２引数には、安定ソートを行うかどうかを指定します。省略すると false が指定されたと見なされ、不安定なソートが行われます。安定ソートは、同じ順位の配列要素の順番は、ソート後も同じ順番になります。不安定ソートの場合は同じ順位の配列要素の順番は、ソート後に同じ順番になる保証はありません。<r/>
<example>
	var array = [ 0, 1, 2, 10, 12, 14, 4, 6, 2 ];<r/>
	array.sort();<r/>
		// ↑ メソッド実行後、array は [0, 1, 2, 2, 4, 6, 10, 12, 14] に<r/>
	array.sort('-');<r/>
		// ↑ メソッド実行後、array は [14, 12, 10, 6, 4, 2, 2, 1, 0] に<r/>
	array.sort('a');<r/>
		// ↑ メソッド実行後、array は [0, 1, 10, 12, 14, 2, 2, 4, 6] に<r/>
<r/>
	var array = [ "hoge", "foo" , "bar", "baz" ];<r/>
	array.sort();<r/>
		// ↑ メソッド実行後、array は ["bar", "baz", "foo", "hoge"] に<r/>
<r/>
	var array = [ "abcd", "abc", "ab", "a" , "b", "c" ];<r/>
	array.sort(function(a,b) { return a&lt; b; } );<r/>
		// ↑ '+' の指定と同じ意味<r/>
<r/>
	var array = [ "abcd", "abc", "ab", "a" , "b", "c" ];<r/>
	array.sort(function(a,b) { return a.length &lt; b.length; } );<r/>
		// ↑ 文字列の長さの短い順<r/>
		// (長さが同じ"a" "b" "c" がソート後も "a" "b" "c"<r/>
		// の順番である保証はない)<r/>
<r/>
	var array = [ "abcd", "abc", "ab", "a" , "b", "c" ];<r/>
	array.sort(function(a,b) { return a.length &lt; b.length; }, true );<r/>
		// ↑ 文字列の長さの短い順<r/>
		// (長さが同じ"a" "b" "c" はソート後もこの順番である)<r/>
</example>
</para>

<para>
<ptitle>saveStruct</ptitle>
　saveStruct はファイルへ構造化されたデータの出力を行います。<r/>
<bq>
構文 : save(&lt;ファイル名>, &lt;モード=''>)<r/>
</bq>
　saveStruct メソッドは、要素の状態を復元可能な状態でファイルに出力します。<r/>
　各要素には文字列、実数、オクテット列、整数を含めることができます。また、要素にオブジェクトがあった場合は、それが Array クラスあるいは Dictionary クラスのオブジェクトである場合に限り、そのオブジェクトの中身もファイルに出力します。それ以外の要素は void が出力されます。<r/>
　たとえば、<r/>
<example>
	([ 1, 2, 3, [4, 5], %[ a : 1, b : 2 ], "文字列" ]).saveStruct("out.txt");<r/>
</example>
　では
<bq>
(const) [<r/>
	1,<r/>
	2,<r/>
	3,<r/>
	(const) [<r/>
		4,<r/>
		5<r/>
	],<r/>
	(const) %[<r/>
		"a" => 1,<r/>
		"b" => 2<r/>
	],<r/>
	"文字列"<r/>
]<r/>
</bq>
　のような内容が出力されます。これはこのファイル全体を一つの式として評価することにより、保存した時と同じ構造を復元できるものです。<r/>
　ここでの (const) は、 [ ] や %[ ] の中身が定数項しか無いことを表しています。コンパイラはこの(const) を見つけると、直後の式中辞書配列や式中配列を、中身が定数項しかないことと仮定して、高効率で読み込む事ができます。<r/>
　saveStruct メソッドは、この Array クラスのオブジェクト自身を返します。<r/>
</para>

<para>
<ptitle>assign</ptitle>
　assign メソッドは、配列をコピーします。<r/>
<bq>
構文 : assign(&lt;コピー元配列>)<r/>
</bq>
　引数で指定された他の配列の内容を、そっくりコピーします。<r/>
<r/>
　辞書配列 (Dictionaryクラスのオブジェクト) をコピー元配列に指定した場合は、その辞書配列の各メンバが、名前、値の順に交互に現れる配列となります。メンバの順番は不定となります。<r/>
</para>

<para>
<ptitle>assignStruct</ptitle>
　assignStruct メソッドは、配列を構造ごとコピーします。<r/>
<bq>
構文 : assignStruct(&lt;コピー元配列>)<r/>
</bq>
　引数で指定された他の配列の内容を、そっくりコピーします。<r/>
　assign メソッドと違い、メンバに配列あるいは辞書配列があった場合は、再帰的にその内容も
コピーします ( assign メソッドの場合は参照がコピーされるだけです )。<r/>
</para>

<para>
<ptitle>clear</ptitle>
　clear メソッドは、配列の要素をすべて削除します。<r/>
</para>

<para>
<ptitle>erase</ptitle>
　erase メソッドは、指定された添え字の要素を削除します。<r/>
<bq>
構文 : erase(&lt;添え字>)<r/>
</bq>
　指定された位置にある添え字を削除します。添え字以降の要素は一つずつ前にずれ、詰められます。添え字が範囲外の場合は例外が発生します。<r/>
</para>

<para>
<ptitle>remove</ptitle>
　remove メソッドは、指定された値と同じ値を持つ要素を削除します。<r/>
<bq>
構文 : remove(&lt;値>, &lt;すべて削除するか=true>)<r/>
</bq>
　指定された値と各要素を識別比較し ( <kw>===</kw> 演算子の動作 )、一致した要素を削除します。<r/>
　すべて削除するか、が false の場合は、最初に見つかった要素のみを削除します。そうでなければ、見つかったすべての要素を削除します。<r/>
</para>

<para>
<ptitle>insert</ptitle>
　insert メソッドは、指定された値を指定された位置に挿入します。<r/>
<bq>
構文 : insert(&lt;位置>, &lt;値>)<r/>
</bq>
　位置で示された添え字位置に、値で示された要素を挿入します。位置以降の要素は一つずつ後ろにずれます。<r/>
</para>

<para>
<ptitle>add</ptitle>
　add メソッドは、指定された値を配列の最後に追加します。<r/>
<bq>
構文 : add(&lt;値>)<r/>
</bq>
　配列の最後に値で示された要素を追加します。<r/>
　このメソッドは値が追加された位置を返します。<r/>
</para>

<para>
<ptitle>find</ptitle>
　find メソッドは、指定された値が最初に現れる添え字を返します。<r/>
<bq>
構文 : find(&lt;値>, &lt;検索開始位置=0>)<r/>
</bq>
　指定された値を、検索開始位置の添え字から順に見ていき、最初に現れる添え字を返します。指定された値が見つからなかったときは -1 を返します。<r/>
　比較には識別比較 ( === 演算子の動作 ) が用いられます。<r/>
</para>

<para>
<ptitle>push</ptitle>
　push メソッドは、指定された要素を配列の最後に追加します。<r/>
　addメソッドと違い、このメソッドは追加後の配列のサイズを返します。また、複数の引数を指定した場合は、すべての引数を順番に追加します。<r/>
<bq>
構文 : push(&lt;値>, ...)<r/>
</bq>
</para>

<para>
<ptitle>pop</ptitle>
　push メソッドは、配列の最後から一つ要素を取り出し、それを返します。取り出された要素は配列から削除されます(配列のサイズは一つ減ります)。<r/>
　このメソッドは、取り出された要素を返します。要素が無かった場合はvoidを返します。<r/>
<bq>
構文 : pop()<r/>
</bq>
</para>


<para>
<ptitle>unshift</ptitle>
　unshift メソッドは、要素を配列の先頭に追加します。複数の要素が指定された場合は複数の要素を先頭に追加することができます。この場合は、たとえば a, b, c の順番で渡された場合は、配列の先頭の要素は a, b, c の順番になります。<r/>
　このメソッドは追加後の配列のサイズを返します。<r/>
<bq>
構文 : unshift(&lt;値>, ...)<r/>
</bq>
</para>

<para>
<ptitle>shift</ptitle>
　shift メソッドは、配列の最初から一つ要素を取り出し、それを返します。取り出された要素は配列から削除されます(配列のサイズは一つ減ります)。<r/>
　このメソッドは、取り出された要素を返します。要素が無かった場合はvoidを返します。<r/>
<bq>
構文 : shift()<r/>
</bq>
</para>

</doc>
