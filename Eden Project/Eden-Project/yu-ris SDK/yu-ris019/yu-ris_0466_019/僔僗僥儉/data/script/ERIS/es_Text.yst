//============================================================================
//
//■ERIS テキスト処理
//
//============================================================================

//■スタティック変数宣言
{
	S_INT[@mTX.NOWTIME] //暫定

	S_STR[$TX]
	S_INT[@TX.LEN]
	S_INT[@TX.POS]
	S_STR[$TX.LOG] //ログ用
	S_INT[@TX.LOG.LEN]
	S_INT[@TX.LOG.POS]

	S_STR[$TX.TASK]
	S_INT[@TX.TASK.LEN]
	S_INT[@TX.TASK.POS]

//	S_INT[@TX.BUF(\.TX.MAX+1)]
	S_INT[@TX.BUF.X(\.TX.MAX+1)]
	S_INT[@TX.BUF.Y(\.TX.MAX+1)]
	S_INT[@TX.BUF.SB(\.TX.MAX+1)]
	S_INT[@TX.BUF.SX(\.TX.MAX+1)]
	S_INT[@TX.BUF.SY(\.TX.MAX+1)]
	S_INT[@TX.BUF.COLOR(\.TX.MAX+1)]
	S_INT[@TX.BUF.COLOR2(\.TX.MAX+1)]
	S_INT[@TX.BUF.TCFLAG(\.TX.MAX+1)]
	S_INT[@TX.BUF.SPD(\.TX.MAX+1)]
	S_INT[@TX.BUF.RUBY(\.TX.MAX+1)]

	S_STR[$TX.BUF.RUBY.STR(64)]
	S_INT[@TX.BUF.RUBY.SRCLEN(64)]

	S_INT[@TX.ColorWritePos]
	S_INT[@TX.SizeWritePos]
	S_INT[@TX.WaitTimeWritePos]
	S_INT[@TX.WaitTime.Start]
	S_INT[@TX.WaitTime.First] //１文字目は即表示フラグ
	S_INT[@TX.WaitTime.Next]  //次の文字表示の時間

	S_STR[$TX.DEFSTR]
	S_STR[$TXN.DEFSTR]
	S_STR[$TX.RUBY.DEFSTR]

	S_INT[@TX.SPD]
	S_INT[@TX.WAIT]
	S_INT[@TX.SY.MAX]
	S_INT[@TX.SX]
	S_INT[@TX.SY]
	S_INT[@TX.COLOR]
	S_INT[@TX.COLOR2]
	S_INT[@TX.TCFLAG]
	S_INT[@TX.SHADE.COLOR]
	S_INT[@TX.SHADE.X]
	S_INT[@TX.SHADE.Y]
	S_INT[@TX.OUTLINE.COLOR]

	S_INT[@TX.StartPosX=2]
	S_INT[@TX.StartPosY=2]
	S_INT[@TX.PrevLine.X]
	S_INT[@TX.PrevLine.Y]

	S_STR[$TX.RubyStartStr]
	S_STR[$TX.RubyCenterStr]
	S_STR[$TX.RubyEndStr]
	S_INT[@TX.RUBY.AnalyzePos]
	S_INT[@TX.RUBY.AnalyzeLen]

	S_INT[@TX.RUBY.COLOR]
	S_INT[@TX.RUBY.COLOR2]
	S_INT[@TX.RUBY.X]
	S_INT[@TX.RUBY.Y]
	S_INT[@TX.RUBY.SX]
	S_INT[@TX.RUBY.SY]
	S_INT[@TX.RUBY.SHADE.COLOR]
	S_INT[@TX.RUBY.SHADE.X]
	S_INT[@TX.RUBY.SHADE.Y]
	S_INT[@TX.RUBY.OUTLINE.COLOR]

	S_INT[@TXN.COLOR]
	S_INT[@TXN.COLOR2]
	S_INT[@TXN.X]
	S_INT[@TXN.Y]
	S_INT[@TXN.SX]
	S_INT[@TXN.SY]
	S_INT[@TXN.SHADE.COLOR]
	S_INT[@TXN.SHADE.X]
	S_INT[@TXN.SHADE.Y]
	S_INT[@TXN.OUTLINE.COLOR]


	S_INT[@TX.AUTOCLICK.F]		//自動クリック待ち設定
	S_INT[@TX.AUTOPAGE.F]		//自動改頁設定
	S_INT[@TX.AUTORETURN.F]		//自動改行設定
	S_INT[@TX.AUTOCLICK.L]		//自動クリック待ち設定
	S_INT[@TX.AUTOPAGE.L]		//自動改頁設定
	S_INT[@TX.AUTORETURN.L]		//自動改行設定
	S_INT[@TX.AUTOCLICK.N]		//一時的クリック待ち無効設定
	S_INT[@TX.AUTOPAGE.N]		//一時的改頁無効設定
	S_INT[@TX.AUTORETURN.N]		//一時的改行無効設定

	S_INT[@TX.SCRIPTSAVEFLAG]

	S_INT[@TX.LineEndTime] //テキストが文末に達したときの時間

	S_STR[$TXN.NAME.TEXT]
	S_STR[$TXN.NAME.CG]
	S_INT[@TXN.EXIST]

	S_INT[@TX.STATE]

	S_INT[@SKIPTIME]

}


//============================================================================
//
//■テキストタスク
//
//============================================================================
#=es.TextTask
{
	return[]
}


//============================================================================
//
//■テキストタスク 後処理
//
//============================================================================
#=es.TextTask.END
{

	//----------------------------------------------------------------
	// フォント初期化
	//----------------------------------------------------------------
		GOSUB[#=es.FONT.SET pint=0]

	//----------------------------------------------------------------
	// 内部の文字バッファをクリアする.
	//----------------------------------------------------------------
		TEXT[CLEAR=1]

	//----------------------------------------------------------------
	// 後処理
	//----------------------------------------------------------------
		GOSUB[#=es.TX.End]

	//----------------------------------------------------------------
	// 日付ウィンドウ各種レイヤ消去
	//----------------------------------------------------------------
		GOSUB[#=es.DATE.DEL]

	//----------------------------------------------------------------
	// テキスト情報クリア
	//----------------------------------------------------------------
		//\TEXTBUF_CLEAR
		$_TEXT=""
		$_TEXT_FLAG=""

		$TX.LOG = ""

		@TX.TCFLAG=0

		GOSUB[#=es.Mes.Clear]

	//----------------------------------------------------------------
	// 名前初期化
	//----------------------------------------------------------------
		GOSUB[#=es.TX.NAMEINIT]
		GOSUB[#=es.NAMEW.CLEAR]

	//----------------------------------------------------------------
	// 設定初期化
	//----------------------------------------------------------------
		@es.TX.AUTO=0
		@es.TX.SKIP=0
		\SUPERAUTOMODE_OFF
		$es.ScriptPosData=""

@es.TXSTART=0

	return[]
}


//============================================================================
//
//■テキスト処理タスク 準備
//
//============================================================================
#=es.TextTask.Init
{

/*
DEBUGLIST[ADD=$TX				STR="$TX"]
DEBUGLIST[ADD=@TX.LEN			STR="@TX.LEN"]
DEBUGLIST[ADD=@TX.POS			STR="@TX.POS"]
DEBUGLIST[ADD=$TX.TASK			STR="$TX.TASK"]
DEBUGLIST[ADD=@TX.TASK.LEN		STR="@TX.TASK.LEN"]
DEBUGLIST[ADD=@TX.TASK.POS		STR="@TX.TASK.POS"]
DEBUGLIST[ADD=$TX.LOG			STR="$TX.LOG"]
DEBUGLIST[ADD=@TX.LOG.LEN		STR="@TX.LOG.LEN"]
DEBUGLIST[ADD=@TX.PrevLine.X	STR="@TX.PrevLine.X"]
DEBUGLIST[ADD=@TX.PrevLine.Y	STR="@TX.PrevLine.Y"]
//DEBUGLIST[ADD=@TX.STATE		STR="@TX.STATE"]
*/

	GOSUB[#=es.TX.RUBY.STR.SET pstr=$T(36,25) pstr2=$T(36,26) pstr3=$T(36,27)]

	//----------------------------------------------------------------
	// テキストフォント初期化
	//----------------------------------------------------------------
		FONT[NAME=$es.GSD(113)]

	//----------------------------------------------------------------
	// 文字情報初期化
	//----------------------------------------------------------------
		$TX.DEFSTR = $T(36,18)
		GOSUB[#=es.TDDEF.SEARCH pstr=$TX.DEFSTR]
		@TX.SX = @_RINT(1) / 65536
		@TX.SY = @_RINT(1) % 65536
		@TX.COLOR  = @_RINT(2)
		@TX.COLOR2 = @_RINT(3)
		@TX.SHADE.X = @_RINT(5) / 65536
		@TX.SHADE.Y = @_RINT(5) % 65536
		@TX.SHADE.COLOR = @_RINT(6)
		@TX.OUTLINE.COLOR = @_RINT(7)

		$TXN.DEFSTR = $T(36,31)
		GOSUB[#=es.TDDEF.SEARCH pstr=$TXN.DEFSTR]
		@TXN.SX = @_RINT(1) / 65536
		@TXN.SY = @_RINT(1) % 65536
		@TXN.COLOR  = @_RINT(2)
		@TXN.COLOR2 = @_RINT(3)
		@TXN.SHADE.X = @_RINT(5) / 65536
		@TXN.SHADE.Y = @_RINT(5) % 65536
		@TXN.SHADE.COLOR = @_RINT(6)
		@TXN.OUTLINE.COLOR = @_RINT(7)

		$TX.RUBY.DEFSTR = $T(36,22)
		GOSUB[#=es.TDDEF.SEARCH pstr=$TX.RUBY.DEFSTR]
		@TX.RUBY.SX = @_RINT(1) / 65536
		@TX.RUBY.SY = @_RINT(1) % 65536
		@TX.RUBY.COLOR  = @_RINT(2)
		@TX.RUBY.COLOR2 = @_RINT(3)
		@TX.RUBY.SHADE.X = @_RINT(5) / 65536
		@TX.RUBY.SHADE.Y = @_RINT(5) % 65536
		@TX.RUBY.SHADE.COLOR = @_RINT(6)
		@TX.RUBY.OUTLINE.COLOR = @_RINT(7)



		\_txsize(@TX.SX, @TX.SY)

	//----------------------------------------------------------------
	// テキスト自動改行、自動改頁、自動クリック待ちをＯＮ.
	//----------------------------------------------------------------
	IF[@es.LOADTHRU==0] //onにすると進んでしまう
	{
		@TX.AUTORETURN.F = 1
		@TX.AUTOPAGE.F   = 1
		@TX.AUTOCLICK.F  = 1
		@TX.AUTORETURN.L = 1
		@TX.AUTOPAGE.L   = 1
		@TX.AUTOCLICK.L  = 1
		@TX.AUTORETURN.N = 0
		@TX.AUTOPAGE.N   = 0
		@TX.AUTOCLICK.N  = 0
	}
	IFEND[]

		@TX.SCRIPTSAVEFLAG = 0

		@TX.LEN = 0
		@TX.LOG.LEN = 0
		@TX.TASK.LEN = 0
		@es.TX.IKKATSU = 0

		@TX.POS      = 1  // 読込位置初期化
		@TX.LOG.POS  = 1  // 読込位置初期化
		@TX.TASK.POS = 1  // 読込位置初期化

		@TX.ColorWritePos    = 1  // テキスト色情報埋め込み完了位置
		@TX.SizeWritePos     = 1  // テキストサイズ情報埋め込み完了位置
		@TX.WaitTimeWritePos = 1  // テキスト速度情報埋め込み完了位置

		@es.TX.CWAIT = 0

		@TX.PrevLine.X = 0
		@TX.PrevLine.Y = 0

		@TX.STATE = 0

		GOSUB[#=es.TX.TIMEINIT]

	//----------------------------------------------------------------
	// テキスト情報クリア(INIT時にしないとロード時$_TEXT参照するのでおかしくなる)
	//----------------------------------------------------------------
		//\TEXTBUF_CLEAR
		$_TEXT=""
		$_TEXT_FLAG=""

		$TX.LOG = ""

	//----------------------------------------------------------------
	// 名前初期化
	//----------------------------------------------------------------
		GOSUB[#=es.TX.NAMEINIT]
		GOSUB[#=es.NAMEW.CLEAR]

	//----------------------------------------------------------------
	// 内部テキスト情報初期化
	//----------------------------------------------------------------
	//	


	return[]
}


#=es.TEXTTASK.FOR.LOAD
{
	GOSUB[#=es.TextTask.Init]
	@TX.STATE=950

	return[]
}


//============================================================================
//
//■テキスト処理タスク メインループ
//
//============================================================================
#=es.TEXTTASK.LOOP
{

	LOOP[]
	{
		IF[@TX.STATE==0] GOSUB[#=es.TX.100]      @TX.STATE=9 IFEND[]		
		IF[@TX.STATE==9] GOSUB[#=es.TX.100.2]    IF[@_RINT(1)] @TX.STATE=1 IFEND[] IFEND[]
		IF[@TX.STATE==1] GOSUB[#=es.TX.101]      @TX.STATE=2 IFEND[]		//未処理タスクがある
		IF[@TX.STATE==2] GOSUB[#=es.TX.Ready]    @TX.STATE=3 IFEND[]		//ゞ
		IF[@TX.STATE==3] GOSUB[#=es.TX.Main.103] @TX.STATE=4 IFEND[]		//テキスト処理タスク メイン
		IF[@TX.STATE==4] GOSUB[#=es.TX.Main.104] IF[@_RINT(1)] @TX.STATE=950 ELSE[] @TX.STATE=5 IFEND[] IFEND[]	//タスクが全て終了するまで繰り返す
		IF[@TX.STATE==5] GOSUB[#=es.TX.Main.105] IFEND[]	//ここで一文字ずつ表示
	//	IF[@TX.STATE==5] GOSUB[#=es.TX.Main.105] IF[@TX.STATE==4] LOOPCONTINUE[] IFEND[] IFEND[] //ここで一文字ずつ表示

/*
FONT[DRAWMODE=0 BOLD=0 COLOR=0xffffff COLOR2=0xaaaaff SX=10 SY=10 ANTIALIASING=0]
CGACT[ID=:/W3/DBG RECTPAINT=1 SET=0]
INT[@we]WINDOWINFO[NO=3 E=1 LET=@we]
IF[@we] CGACT[ID=:/W3/DBG Y=0 TEXT=1 SETSTR="OS_TIME="+$(@_OS_TIME(1))+", WaitTime.Next="+$(@TX.WaitTime.Next)] IFEND[]
*/

		GOSUB[#=es.TX.CLICKWAIT.MAIN]	// クリック待ち処理


		IF[@TX.STATE==101] GOSUB[#=es.TX.CLICK.101] IFEND[]	//$_CHR(0xEF)+$_CHR(0xF3) クリック待ち (NOVEL)
		IF[@TX.STATE==102] GOSUB[#=es.TX.CLICK.102] IFEND[]	//CR クリック改行
		IF[@TX.STATE==103] GOSUB[#=es.TX.CLICK.103] IFEND[]	//CP クリック改ページ
		IF[@TX.STATE==104] GOSUB[#=es.TX.CLICK.104] IFEND[]	//C  クリック待ち (ADVモード)

		IF[@TX.STATE==201] GOSUB[#=es.TX.CLICK.201] GOSUB[#=es.TX.TIMEINIT] @TX.STATE=5 IFEND[]
		IF[@TX.STATE==202] GOSUB[#=es.TX.CLICK.202] GOSUB[#=es.TX.TIMEINIT] @TX.STATE=5 IFEND[]
		IF[@TX.STATE==203] GOSUB[#=es.TX.CLICK.203] GOSUB[#=es.TX.TIMEINIT] @TX.STATE=5 IFEND[]
		IF[@TX.STATE==204] GOSUB[#=es.TX.CLICK.204] GOSUB[#=es.TX.TIMEINIT] @TX.STATE=5 IFEND[]

		IF[@TX.STATE==950] GOSUB[#=es.TX.End] GOSUB[#=es.TX.Final] @TX.STATE=0 IFEND[]

		LOOPBREAK[]
	}
	LOOPEND[]

	//----------------------------------------------------------------
	// ボイスアイコン処理
	//----------------------------------------------------------------
	//============================================================ ボイス再生終了チェック
	IF[@es.VOICEPLAYFLAG]
	{
		\VO.PCHK
		IF[@_RINT(1)==0]
			@es.VOICEPLAYFLAG=0
			\BT.OFF("ES.GAMEMAIN.BTN.VOICE")
		IFEND[]
	}
	IFEND[]

	return[]
}

//■TX.100
#=es.TX.100
{
/*
	//------------------------------------------------------------
	// 名前 or 名前画像表示されていたらクリア
	//------------------------------------------------------------
		IF[@TXN.EXIST]
		{
			@TXN.EXIST=0
			GOSUB[#=es.NAMEW.CLEAR]
		}
		IFEND[]
*/
	return[]
}

//■TX.100.2
#=es.TX.100.2
{
	INT[@ret]

	//------------------------------------------------------------
	// テキストおよびテキストタスクを解析用変数に移す
	//------------------------------------------------------------
		$TX      = $_TEXT
		$TX.TASK = $_TEXT_FLAG

		\_strlen($TX.TASK)
		@TX.TASK.LEN = @_RINT(1)

	//------------------------------------------------------------
	// 未処理タスクがあれば処理する
	//------------------------------------------------------------
		IF[@TX.TASK.POS <= @TX.TASK.LEN] @ret=1 IFEND[]

	return[rint=@ret]
}

//■TX.101
#=es.TX.101
{
	//------------------------------------------------------------
	// シナリオタスクを一時停止
	//------------------------------------------------------------
		\es.TXTASK.TX.E0

	//------------------------------------------------------------
	// ロード時音声再生
	// ＆ロード時状態解除
	//------------------------------------------------------------
	IF[@es.LOADTHRU]
	{
		@es.LOADTHRU = 0

		\VO1($es.VOICE.FILE( 1))
		\VO2($es.VOICE.FILE( 2))
		\VO3($es.VOICE.FILE( 3))
		\VO4($es.VOICE.FILE( 4))
		\VO5($es.VOICE.FILE( 5))
		\VO6($es.VOICE.FILE( 6))
		\VO7($es.VOICE.FILE( 7))
		\VO8($es.VOICE.FILE( 8))
		\VO9($es.VOICE.FILE( 9))
		\VO10($es.VOICE.FILE(10))
	}
	IFEND[]

	return[]
}

#=es.TXTASK.TX.E0
{
	@es.TXTASK.TX.E = 0
	\_task.pause($es.ScenarioTaskID)
	return[]
}
#=es.TXTASK.SN.E0
{
	@es.TXTASK.SN.E = 0
	\_task.pause($es.ScenarioTaskID)
	return[]
}
#=es.TXTASK.TX.E1
{
	@es.TXTASK.TX.E = 1
	IF[@es.TXTASK.TX.E && @es.TXTASK.SN.E] \_task.resume($es.ScenarioTaskID) IFEND[]
	return[]
}
#=es.TXTASK.SN.E1
{
	@es.TXTASK.SN.E = 1
	IF[@es.TXTASK.TX.E && @es.TXTASK.SN.E] \_task.resume($es.ScenarioTaskID) IFEND[]
	return[]
}

//■TX.Ready
#=es.TX.Ready
{
///xS
	@es.VOICEPLAYFLAG=0
	\BT.OFF("ES.GAMEMAIN.BTN.VOICE")

///rin
	IF[$es.RIN.LFNAME!=""]
	{
		LOAD[FILE=$es.RIN.LFNAME DNO=0005 LET=@L()]	// データ
		LOAD[FILE=$es.RIN.LFNAME DNO=0006 LET=$L()]	// データ

		$es.RIN.LFNAME=""
	}
	IFEND[]

	//------------------------------------------------------------
	// 色、サイズ、速度情報をバッファに格納
	//------------------------------------------------------------
		GOSUB[#=es.TX.BUFSET.COL]  // 色
		GOSUB[#=es.TX.BUFSET.SIZE] // サイズ
		GOSUB[#=es.TX.BUFSET.SPD]  // 速度

	//------------------------------------------------------------
	// 文字定義情報取得
	//------------------------------------------------------------
		GOSUB[#=es.TDDEF.SEARCH pstr=$TX.DEFSTR]
		@TX.COLOR  = @_RINT(2)
		@TX.COLOR2 = @_RINT(3)
		@TX.SHADE.X = @_RINT(5) / 65536
		@TX.SHADE.Y = @_RINT(5) % 65536
		@TX.SHADE.COLOR = @_RINT(6)
		@TX.OUTLINE.COLOR = @_RINT(7)

		GOSUB[#=es.TDDEF.SEARCH pstr=$TXN.DEFSTR]
		@TXN.COLOR  = @_RINT(2)
		@TXN.COLOR2 = @_RINT(3)
		@TXN.SHADE.X = @_RINT(5) / 65536
		@TXN.SHADE.Y = @_RINT(5) % 65536
		@TXN.SHADE.COLOR = @_RINT(6)
		@TXN.OUTLINE.COLOR = @_RINT(7)

		GOSUB[#=es.TDDEF.SEARCH pstr=$TX.RUBY.DEFSTR]
		@TX.RUBY.COLOR  = @_RINT(2)
		@TX.RUBY.COLOR2 = @_RINT(3)
		@TX.RUBY.SHADE.X = @_RINT(5) / 65536
		@TX.RUBY.SHADE.Y = @_RINT(5) % 65536
		@TX.RUBY.SHADE.COLOR = @_RINT(6)
		@TX.RUBY.OUTLINE.COLOR = @_RINT(7)


		@es.KIDOKUCOLORFLAG = 0

	//------------------------------------------------------------
	// 既読文字ならば文字色変更
	//------------------------------------------------------------
		\_task.info($es.ScenarioTaskID, 1)
		INT[@mFNo = @_RINT(2)]
		INT[@mTLine = @_RINT(4)]
		@GSD.NEXTVOICE = (@_RINT(5)!=0)

		\KIDOKU.CHECK(@mFNo, @mTLine)
		@es.KIDOKUFLAG = @_RINT(1)
		IF[@es.KIDOKUFLAG]
		{
			IF[@es.GSD(110,09)] @es.KIDOKUCOLORFLAG=1 IFEND[]
			IF[@es.GSD(112,02)] @es.TX.IKKATSU=1 IFEND[]
		}
		IFEND[]


		STR[$BID="ES.GAMEMAIN."]
		IF[$es.VOICE.FILE(1)+$es.VOICE.FILE(2)+$es.VOICE.FILE(3)+$es.VOICE.FILE(4)+$es.VOICE.FILE(5)+$es.VOICE.FILE(6)+$es.VOICE.FILE(7)+$es.VOICE.FILE(8)+$es.VOICE.FILE(9)+$es.VOICE.FILE(10)!=""]
		{
			\BT.N0($BID+"BTN.VOICE")
	//		\BT.ONOFF($BID+"BTN.VOICE",,@es.VOICEPLAYFLAG)
		}
		ELSE[]
		{
			\BT.N1($BID+"BTN.VOICE")
		}
		IFEND[]


	//----------------------------------------------------------------
	// テキストフォント初期化
	//----------------------------------------------------------------
		FONT[NAME=$es.GSD(113)]


	return[]
}


//■TX.End
#=es.TX.End
{

	//------------------------------------------------------------
	// ボイス情報初期化
	//------------------------------------------------------------
		IF[@es.LOADTHRU==0]
			GOSUB[#=es.Voice.DataInit]
		IFEND[]

	//------------------------------------------------------------
	// ボイス停止
	//------------------------------------------------------------
		IF[@es.GSD(111,02)==0]
		{
			GOSUB[#=es.VOICE.DEL]
		}
		IFEND[]

	//------------------------------------------------------------
	// ロード時なら、ロード完了までここで待つ.その１
	//------------------------------------------------------------
		LOOP[]
		{
			IF[@es.LoadFlag==0] LOOPBREAK[] IFEND[]
			WAIT[FRAME=1]
			//\_dmes(loadwait)
		}
		LOOPEND[]

	return[]
}


//■TX.Final
#=es.TX.Final
{
	//------------------------------------------------------------
	// 既読判定
	//------------------------------------------------------------
		\_task.info($es.ScenarioTaskID, 1)
		INT[@mFNo = @_RINT(2)]
		INT[@mTLine = @_RINT(4)]
		\KIDOKU.ON(@mFNo, @mTLine)

	//------------------------------------------------------------
	// ノベルモードでなければスクリプト位置を記憶
	//------------------------------------------------------------
	//	IF[@TX.AUTOPAGE.N==0]
		{
			IF[@TX.AUTOCLICK.L==1 || @TX.SCRIPTSAVEFLAG]
			{
				@TX.SCRIPTSAVEFLAG=0
				\SCRIPTPOS_SAVE
			}
			IFEND[]
		}
	//	IFEND[]

		@TX.AUTOCLICK.N  = 0
		@TX.AUTORETURN.N = 0
		@TX.AUTOPAGE.N   = 0

	//------------------------------------------------------------
	// シナリオタスク再開
	//------------------------------------------------------------
		\es.TXTASK.TX.E1

	return[]
}

//============================================================================
//
//■テキスト処理タスク メイン
//
//============================================================================
#=es.TX.Main.103
{
	//------------------------------------------------------------
	// 
	//------------------------------------------------------------
	//	\LOG.NUM.PLUS(1)

	//------------------------------------------------------------
	// 色、サイズ、速度情報をバッファに格納
	//------------------------------------------------------------
		GOSUB[#=es.TX.BUFSET.COL]  // 色
		GOSUB[#=es.TX.BUFSET.SIZE] // サイズ
		GOSUB[#=es.TX.BUFSET.SPD]  // 速度

	//------------------------------------------------------------
	// テキストからルビ記述を抜き出し
	//------------------------------------------------------------
		GOSUB[#=es.TX.RUBY.CHK]

	//------------------------------------------------------------
	// テキストからキャラ名抜き出し
	//------------------------------------------------------------
//		IF[@TX.AUTOCLICK.L] //ADVモードのみ
	//	IF[$TXN.NAME.TEXT=="" && @TX.PrevLine.X==0 && @TX.PrevLine.Y==0]
		IF[$TXN.NAME.TEXT==""]
			GOSUB[#=es.TX.CHARNAME.CHK]
		IFEND[]

	//------------------------------------------------------------
	// テキスト/テキストタスク文字数を調べる
	//------------------------------------------------------------
		\_strlen($TX)
		@TX.LEN = @_RINT(1)
		@TX.LOG.LEN = @_RINT(1)
		\_strlen($TX.TASK)
		@TX.TASK.LEN = @_RINT(1)

	//------------------------------------------------------------
	// 表示位置情報をバッファに格納（禁則処理付）
	//------------------------------------------------------------
		GOSUB[#=es.TX.BUFSET.XY]

	//------------------------------------------------------------
	// 名前テキスト表示
	//------------------------------------------------------------
		GOSUB[#=es.NameSet]

@es.SEL.SEQFLAG=0

	//------------------------------------------------------------
	// 
	//------------------------------------------------------------
		GOSUB[#=es.TX.TIMEINIT]

	return[]
}

//------------------------------------------------------------
// タスクが全て終了するまで繰り返す.
//------------------------------------------------------------
#=es.TX.Main.104
{
	INT[@ret]

	LOOP[SET=1]
	{
		//--------------------------------------------------------------------
		// タスクが無くなったら抜ける(文中のクリック待ちの時等に必要)
		//--------------------------------------------------------------------
			IF[@TX.TASK.POS > @TX.TASK.LEN] @ret=1;LOOPBREAK[] IFEND[]

		//--------------------------------------------------------------------
		// テキストウェイト無視して一括表示
		//--------------------------------------------------------------------
			IF[@es.TX.SKIP]       @es.TX.IKKATSU=1 IFEND[]
			IF[@es.TX.CSKIP]      @es.TX.IKKATSU=1 IFEND[]
			IF[@es.TEXT.TIPCLICK] @es.TEXT.TIPCLICK=0;@es.TX.IKKATSU=1 IFEND[]

		//--------------------------------------------------------------------
		// 待ち時間の基準となる時刻を取得
		//--------------------------------------------------------------------
			@mTX.NOWTIME = @_OS_TIME(1)
	}
	LOOPEND[]

	return[rint=@ret]
}

#=es.TX.Main.105
{
	STR[$str]
	STR[$one]

	LOOP[SET=1]
	{

		//--------------------------------------------------------------------
		// メッセージウェイト分だけ待ったか、クリックによる一括表示モードか
		//--------------------------------------------------------------------
			IF[(@mTX.NOWTIME - @TX.WaitTime.Start >= @TX.WaitTime.Next) || @es.TX.IKKATSU==1 || @TX.WaitTime.First>0]
			{
				IF[@TX.WaitTime.First>0] @TX.WaitTime.First-=1 IFEND[]

				//------------------------------------------------------------
				// タスク文字を調べ、それに応じた処理.
				//------------------------------------------------------------
					IF[@TX.TASK.POS > @TX.TASK.LEN] @TX.STATE=950;LOOPBREAK[] IFEND[]
					\_strmid($TX.TASK, @TX.TASK.POS, 1)
					$str=$_RSTR(1)

					IF[$str=='2']
					{
						//１文字分抽出
						\_strmid($TX, @TX.POS, 1)
						$one = $_RSTR(1)
						$TX.LOG+=$one

						IF[$one==$_CHR(0xEF)+$_CHR(0xF3)] //クリック待ち
						{
//\_dmes("C")
							@es.TX.ICON.TYPE=1
							GOSUB[#=es.TX.CLICK.PRE]
							@TX.STATE=101;LOOPBREAK[]
						}
						ELSE[$one==$_CHR(0xEF)+$_CHR(0xF0)] // 改行
						{
//\_dmes("R")
							//テキスト読込位置の移動
							@TX.POS += 1
							@TX.LOG.POS += 1
///xTOC
	\LOG.ONE($_CHR(0xEF))
	\LOG.ONE($_CHR(0xF0))
						}
						ELSE[$one==$_CHR(0xEF)+$_CHR(0xF2)] // 改頁
						{
//\_dmes("P")
							GOSUB[#=es.Mes.Clear]
							//表示位置初期化
///x4						@TX.PrevLine.X=0;@TX.PrevLine.Y=0

							//ログ書込
						//	\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$TX.LOG )
					IF[@es.LSD(035,02)]
							\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xEF)+$TX.LOG )
					ELSE[]
							\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$TX.LOG )
					IFEND[]
							\LOG.W2( $es.VOICE.FILE(1), $es.VOICE.FILE(2), $es.VOICE.FILE(3), $es.VOICE.FILE(4), $es.VOICE.FILE(5), $es.VOICE.FILE(6), $es.VOICE.FILE(7), $es.VOICE.FILE(8), $es.VOICE.FILE(9), $es.VOICE.FILE(10) )
							\LOG.WRITE

							\LOG.NUM.PLUS.FLAG
							\LOG.NUM.PLUS(2)

						//	$TX=""
							$TX.LOG=""
							@TX.LOG.POS = 1

							// テキスト読込位置の移動
							@TX.POS += 1

							//改頁直後処理
							GOSUB[#=es.TextPageAfter]
							GOSUB[#=es.TextPageAfter2]

						}
						ELSE[$one==$_CHR(0xEF)+$_CHR(0xF4)] // クリック改行
						{
//\_dmes("CR")
							@es.TX.ICON.TYPE=1
							GOSUB[#=es.TX.CLICK.PRE]
							@TX.STATE=102;LOOPBREAK[]
						}
						ELSE[$one==$_CHR(0xEF)+$_CHR(0xF5)] // クリック待ち(改頁用)
						{
//\_dmes("CP")
							@es.TX.ICON.TYPE=0
							GOSUB[#=es.TX.CLICK.PRE]
							@TX.STATE=101;LOOPBREAK[]
						}
						ELSE[]
						{
							GOSUB[#=es.TX.OUTPUT.ONE pint=2] // 全角
						}
						IFEND[]

					}
					ELSE[$str=='1']
					{
						//１文字分抽出
						\_strmid($TX, @TX.POS, 1)
						$one = $_RSTR(1)
						$TX.LOG+=$one

						GOSUB[#=es.TX.OUTPUT.ONE pint=1] // 半角
					}
					ELSE[$str=='C'] //クリック待ち(ADVモード)
					{
//\_dmes("AC")
						@es.TX.ICON.TYPE=0
						GOSUB[#=es.TX.CLICK.PRE]
						@TX.STATE=104;LOOPBREAK[]
					}
					ELSE[$str=="R"] // 改行
					{
//\_dmes("AR")
	@TX.PrevLine.X = 0
	@TX.PrevLine.Y += @TX.SY.MAX + @T(36,20)
	IF[@T(36,21)] @TX.PrevLine.Y += @TX.RUBY.SY + @T(36,24) IFEND[]
					}
					ELSE[$str=="P"] //改頁(ADVモード)
					{
//\_dmes("AP")
						GOSUB[#=es.Mes.Clear]
						//表示位置初期化
						@TX.PrevLine.X=0;@TX.PrevLine.Y=0

						//ログ書込
					//	\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$TX.LOG )
				IF[@es.LSD(035,02)]
						\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xEF)+$TX.LOG )
				ELSE[]
						\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$TX.LOG )
				IFEND[]

						\LOG.W2( $es.VOICE.FILE(1), $es.VOICE.FILE(2), $es.VOICE.FILE(3), $es.VOICE.FILE(4), $es.VOICE.FILE(5), $es.VOICE.FILE(6), $es.VOICE.FILE(7), $es.VOICE.FILE(8), $es.VOICE.FILE(9), $es.VOICE.FILE(10) )
						\LOG.WRITE

						\LOG.NUM.PLUS.FLAG
						\LOG.NUM.PLUS(4)

						$TX=""
						$TX.LOG=""

						// テキスト読込位置の移動
					//	@TX.POS += 1
					//	@TX.LOG.POS += 1

						//改頁直後処理
						GOSUB[#=es.TextPageAfter]
						GOSUB[#=es.TextPageAfter2]

					}
					ELSE[$str=="E"] // 行末
					{
//\_dmes("行末Ｅ")
						//----------------------------------------------------------------
						// その時点までのログを書込
						//----------------------------------------------------------------
							\_strmid($TX.LOG, 1, @TX.LOG.POS-1)

						//	\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$_RSTR(1) )
					IF[@es.LSD(035,02)]
							\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xEF)+$_RSTR(1) )
					ELSE[]
							\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$_RSTR(1) )
					IFEND[]
							\LOG.W2( $es.VOICE.FILE(1), $es.VOICE.FILE(2), $es.VOICE.FILE(3), $es.VOICE.FILE(4), $es.VOICE.FILE(5), $es.VOICE.FILE(6), $es.VOICE.FILE(7), $es.VOICE.FILE(8), $es.VOICE.FILE(9), $es.VOICE.FILE(10) )
							\LOG.WRITE

/*						//ログ書込
						\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$TX.LOG )
						\LOG.W2( $es.VOICE.FILE(1), $es.VOICE.FILE(2), $es.VOICE.FILE(3), $es.VOICE.FILE(4), $es.VOICE.FILE(5), $es.VOICE.FILE(6), $es.VOICE.FILE(7), $es.VOICE.FILE(8), $es.VOICE.FILE(9), $es.VOICE.FILE(10) )
						\LOG.WRITE
*/
						//暫定処置としてボイスだけ書込
						IF[$es.VOICE.FILE(1)+$es.VOICE.FILE(2)+$es.VOICE.FILE(3)+$es.VOICE.FILE(4)+$es.VOICE.FILE(5)+$es.VOICE.FILE(6)+$es.VOICE.FILE(7)+$es.VOICE.FILE(8)+$es.VOICE.FILE(9)+$es.VOICE.FILE(10)!=""]
//\_dmes($es.VOICE.FILE(1)+$es.VOICE.FILE(2)+$es.VOICE.FILE(3)+$es.VOICE.FILE(4)+$es.VOICE.FILE(5)+$es.VOICE.FILE(6)+$es.VOICE.FILE(7)+$es.VOICE.FILE(8)+$es.VOICE.FILE(9)+$es.VOICE.FILE(10))
					//		\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$TX.LOG )
					IF[@es.LSD(035,02)]
							\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xEF)+$TX.LOG )
					ELSE[]
							\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$TX.LOG )
					IFEND[]
							\LOG.W2( $es.VOICE.FILE(1), $es.VOICE.FILE(2), $es.VOICE.FILE(3), $es.VOICE.FILE(4), $es.VOICE.FILE(5), $es.VOICE.FILE(6), $es.VOICE.FILE(7), $es.VOICE.FILE(8), $es.VOICE.FILE(9), $es.VOICE.FILE(10) )
							\LOG.WRITE
						IFEND[]

						GOSUB[#=es.TX.OUTPUT.LINEEND]
					}
					ELSE[$str=="Z"]
					{
//\_dmes("行末Ｚ")
						GOSUB[#=es.TX.OUTPUT.Z] @TX.STATE=950;LOOPBREAK[]
					}
					IFEND[] // 行末2


				//------------------------------------------------------------
				// タスク読込位置の移動
				//------------------------------------------------------------
					@TX.TASK.POS+=1

					IFCONTINUE[]

			}
			IFEND[]

			@TX.STATE=4

	}
	LOOPEND[]

	return[]
}



//============================================================================
//
//■一文字描画
//
//============================================================================
#=es.TX.OUTPUT.ONE
{

@es.TXSTART=1

	//------------------------------------------------------------
	// 待ち時間を設定
	//------------------------------------------------------------
		@TX.WaitTime.Next += @TX.BUF.SPD(@TX.POS) / (3-@_PINT(1))

	//------------------------------------------------------------
	// １文字分抽出
	//------------------------------------------------------------
		\_strmid($TX, @TX.POS, 1)
		STR[$one = $_RSTR(1)]

	//------------------------------------------------------------
	// ボタン座標取得
	//------------------------------------------------------------
		GOSUB[#=es.BT.XY.GET pstr="ES.GAMEMAIN.TIP.MESW.TX" pint2=0]

		INT[@TX.X=@_RINT(1)]
		INT[@TX.Y=@_RINT(2)]
	//	INT[@TX.X=4]
	//	INT[@TX.Y=4]

	//------------------------------------------------------------
	// ログ用に記録
	//------------------------------------------------------------
		\LOG.ONE( $one )

//	//	\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$_RSTR(1) )
//	IF[@es.LSD(035,02)]
//		\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xEF)+$_RSTR(1) )
//	ELSE[]
//		\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$_RSTR(1) )
//	IFEND[]
//	//	\LOG.W2( $es.VOICE.FILE(1), $es.VOICE.FILE(2), $es.VOICE.FILE(3), $es.VOICE.FILE(4), $es.VOICE.FILE(5), $es.VOICE.FILE(6), $es.VOICE.FILE(7), $es.VOICE.FILE(8) )
//	//	\LOG.W3( $es.VOICE.FILE(9), $es.VOICE.FILE(10) )
//	//	\LOG.WRITE

	//------------------------------------------------------------
	// 文字を描画
	//------------------------------------------------------------

		IF[@TX.BUF.TCFLAG(@TX.POS)] //文字色変更時
		{
			\FONT.COLOR( @TX.BUF.COLOR(@TX.POS) )
			IF[@es.GSD(115,15)==1] \FONT.COLOR( @TX.BUF.COLOR(@TX.POS), @TX.BUF.COLOR2(@TX.POS) ) IFEND[]
		}
		ELSE[] //通常時
		{
			IF[@es.KIDOKUCOLORFLAG]	//既読色か
				\FONT.COLOR( @T(36,16) )
				IF[@es.GSD(115,15)==1] \FONT.COLOR( @T(36,16), @T(36,17) ) IFEND[]
			ELSE[]					//否か
				\FONT.COLOR( @TX.COLOR )
				IF[@es.GSD(115,15)==1] \FONT.COLOR( @TX.COLOR, @TX.COLOR2 ) IFEND[]
			IFEND[]
		}
		IFEND[]

		\FONT.SIZE( @TX.BUF.SB(@TX.POS), @TX.BUF.SY(@TX.POS) )
//		\FONT.SIZE( @TX.BUF.SX(@TX.POS), @TX.BUF.SY(@TX.POS) )
		\FONT.XY( (4)+@TX.BUF.X(@TX.POS), (4)+@TX.BUF.Y(@TX.POS) )
		IF[@es.GSD(115,14)==1] \FONT.BOLD( 1 )											IFEND[]
		IF[@es.GSD(115,09)==1] \FONT.SHADE( @TX.SHADE.X, @TX.SHADE.Y, @TX.SHADE.COLOR )	IFEND[]
		IF[@es.GSD(115,08)==1] \FONT.OUTLINE( @TX.OUTLINE.COLOR ) IFEND[]
		\BT.FONT.DRAW("ES.GAMEMAIN.TIP.MESW.TX",, $one)

		INT[@icx=@TX.X+(4)+@TX.BUF.X(@TX.POS)+@TX.BUF.SX(@TX.POS)]
		INT[@icy=@TX.Y+(4)+@TX.BUF.Y(@TX.POS)]
		GOSUB[#=es.TX.ICON.XY2.SET pint=@icx pint2=@icy]


	//------------------------------------------------------------
	// ルビ描画処理
	//------------------------------------------------------------
		INT[@chkX]

		IF[@T(36,21)]
		{
			//------------------------------------------------------------
			// ルビバッファがあれば描画
			//------------------------------------------------------------
				IF[@TX.BUF.RUBY( @TX.POS ) > 0]
				{
					//------------------------------------------------------------
					// ルビ表示位置を算出
					//------------------------------------------------------------
						\_strlen( $TX.BUF.RUBY.STR(@TX.BUF.RUBY(@TX.POS)) )
						INT[@len1 = @_RINT(1)]
						INT[@len2 = @TX.BUF.RUBY.SRCLEN(@TX.BUF.RUBY(@TX.POS))]
						INT[@sx1  = (@TX.RUBY.SX * @len1) + (@T(36,23) * (@len1-1))]   //ルビ文字の幅
						INT[@sx2  = (@TX.BUF.SX(@TX.POS) * @len2) + (@T(36,19) * (@len2-1))] //ルビ振られる文字の幅
						INT[@posx = (@sx2 - @sx1) / 2]

///tri
/*ルビはみだしチェック
					@chkX=(4)+@TX.BUF.X(@TX.POS)+@posx
					IF[@chkX<(203) || @chkX+@sx1>(700)]
						\_log($_TEXT)
					IFEND[]
*/

					//------------------------------------------------------------
					// 描画
					//------------------------------------------------------------
						LOOP[SET=@len1]
						{
							IF[@TX.BUF.TCFLAG(@TX.POS)] //文字色変更時
							{
								\FONT.COLOR( @TX.BUF.COLOR(@TX.POS) )
								IF[@es.GSD(115,15)==1] \FONT.COLOR( @TX.BUF.COLOR(@TX.POS), @TX.BUF.COLOR2(@TX.POS) ) IFEND[]
							}
							ELSE[] //通常時
							{
								//色セット
								IF[@es.KIDOKUCOLORFLAG]
									\FONT.COLOR( @T(36,16) )
									IF[@es.GSD(115,15)==1] \FONT.COLOR( @T(36,16), @T(36,17) ) IFEND[]
								ELSE[]
									\FONT.COLOR( @TX.RUBY.COLOR )
									IF[@es.GSD(115,15)==1] \FONT.COLOR( @TX.RUBY.COLOR, @TX.RUBY.COLOR2 ) IFEND[]
								IFEND[]
							}
							IFEND[]

							\FONT.SIZE( @TX.RUBY.SX, @TX.RUBY.SY )
							\FONT.XY( (4)+@TX.BUF.X(@TX.POS)+@posx + ((@TX.RUBY.SX+@T(36,23))*(@_LC-1)) , (4)+@TX.BUF.Y(@TX.POS)-@TX.RUBY.SY-@T(36,24) )
							\FONT.BOLD( 1 )
							\FONT.SHADE( @TX.RUBY.SHADE.X, @TX.RUBY.SHADE.Y, @TX.RUBY.SHADE.COLOR )
							\FONT.OUTLINE( @TX.RUBY.OUTLINE.COLOR )

							\_strmid($TX.BUF.RUBY.STR(@TX.BUF.RUBY(@TX.POS)), @_LC, 1)
							\BT.FONT.DRAW("ES.GAMEMAIN.TIP.MESW.TX",, $_RSTR(1))
						}
						LOOPEND[]
				}
				IFEND[]

		}
		IFEND[]


//	IFEND[]

	//------------------------------------------------------------
	// テキスト読込位置の移動
	//------------------------------------------------------------
		@TX.POS += 1
		@TX.LOG.POS += 1


	return[]
}



//============================================================================
//
//■クリック待ち
//
//============================================================================
#=es.TX.CLICK.PRE
{

//\_dmes($TX.TASK)

	//----------------------------------------------------------------
	// その時点までのログを書込
	//----------------------------------------------------------------
		\_strmid($TX.LOG, 1, @TX.LOG.POS-1)

//		\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$_RSTR(1) )
	IF[@es.LSD(035,02)]
		\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xEF)+$_RSTR(1) )
	ELSE[]
		\LOG.W1( $TXN.NAME.TEXT+$_CHR(0xEF)+$_CHR(0xF0)+$_RSTR(1) )
	IFEND[]
		\LOG.W2( $es.VOICE.FILE(1), $es.VOICE.FILE(2), $es.VOICE.FILE(3), $es.VOICE.FILE(4), $es.VOICE.FILE(5), $es.VOICE.FILE(6), $es.VOICE.FILE(7), $es.VOICE.FILE(8), $es.VOICE.FILE(9), $es.VOICE.FILE(10) )
		\LOG.WRITE

//	\_strmid($TX.LOG, 1, @TX.LOG.POS-1)
//	\_dmes("[es.TX.CLICK]"+$TXN.NAME.TEXT+$_RSTR(1)+",POS="+$@TX.LOG.POS)

	//----------------------------------------------------------------
	// テキスト文末停止時間初期化
	//----------------------------------------------------------------
		@TX.LineEndTime = 0

	//----------------------------------------------------------------
	// テキスト文末停止時間セット
	//----------------------------------------------------------------
		IF[@TX.LineEndTime==0]
		{
			@TX.LineEndTime = @_OS_TIME(1)
		}
		IFEND[]

	//----------------------------------------------------------------
	// 未読スキップ防止処理
	//----------------------------------------------------------------
		\_task.info($es.ScenarioTaskID, 1)
		INT[@mFNo=@_RINT(2)]
		INT[@mTLine=@_RINT(4)]
		\KIDOKU.CHECK(@mFNo, @mTLine)
		@es.KIDOKUFLAG = @_RINT(1)

		IF[@es.GSD(110,04)==1] // 未読スキップ設定なら
		{
			IF[@es.gSKIP==0] @es.gSKIP=1 IFEND[]
		}
		ELSE[] // 未読で止まる設定
		{
			IF[@es.KIDOKUFLAG==0]
			{
				IF[@es.gSKIP==1] @es.gSKIP=0 IFEND[]
				@es.TX.SKIP=0
			}
			IFEND[]
		}
		IFEND[]


	//----------------------------------------------------------------
	// フラグ立てる
	//----------------------------------------------------------------
		@es.TX.CWAIT = 1


/*
	//----------------------------------------------------------------
	// CTRLスキップ処理
	//----------------------------------------------------------------
		//IF[@es.gSKIP]
		{
			IF[@es.SCENARIOSTOP==0]
			{
				//----------------------------------------------------------------
				// 強制オートモードかつスキップ不許可ならCTRL認識させない
				//----------------------------------------------------------------
				IF[\es.SuperAutoPlayMode==0 || \es.SuperAutoPlayTimeTextSk==1]
				{
					IF[@es.TX.CSKIP] @es.TX.CWAIT=0 IFEND[]	//手動スキップ
				}
				IFEND[]
			}
			IFEND[]
		}
		//IFEND[]
*/

	return[]
}

#=es.TX.CLICK.101
{
	IF[@es.TX.CWAIT==0] @TX.STATE=201 IFEND[]
	return[]
}
#=es.TX.CLICK.102
{
	IF[@es.TX.CWAIT==0] @TX.STATE=202 IFEND[]
	return[]
}
#=es.TX.CLICK.103
{
	IF[@es.TX.CWAIT==0] @TX.STATE=203 IFEND[]
	return[]
}
#=es.TX.CLICK.104
{
	IF[@es.TX.CWAIT==0] @TX.STATE=204 IFEND[]
	return[]
}

#=es.TX.CLICK.201
{
	@es.TX.ICON.TYPE=0

	//テキスト読込位置の移動
	@TX.POS += 1
	@TX.LOG.POS += 1

	// タスク読込位置の移動
	@TX.TASK.POS+=1

	return[]
}
#=es.TX.CLICK.202
{
/*
	@TX.PrevLine.X = 0
	@TX.PrevLine.Y += @TX.SY.MAX + @T(36,20)
	IF[@T(36,21)] @TX.PrevLine.Y += @TX.RUBY.SY + @T(36,24) IFEND[]
*/
	// テキスト読込位置の移動
	@TX.POS += 1
	@TX.LOG.POS += 1

///xTOC
	\LOG.ONE($_CHR(0xEF))
	\LOG.ONE($_CHR(0xF0))

	// タスク読込位置の移動
	@TX.TASK.POS+=1

	return[]
}
#=es.TX.CLICK.203
{
	@es.TX.ICON.TYPE=0

/*
//	IF[@TX.AUTOCLICK.L==0]
		@es.TX.ICON.TYPE=0
		@TX.STATE=13
//	IFEND[]

	GOSUB[#=es.Mes.Clear]
	//表示位置初期化
	@TX.PrevLine.X=0;@TX.PrevLine.Y=0

	//ログ書込
	\LOG.WRITE($TXN.NAME.TEXT+$TX.LOG, $es.VOICE.FILE(1), $es.VOICE.FILE(2), $es.VOICE.FILE(3), $es.VOICE.FILE(4) )
	\LOG.NUM.PLUS.FLAG
//	\LOG.NUM.PLUS

	$TX=""
	$TX.LOG=""
*/
	// テキスト読込位置の移動
	@TX.POS += 1
	@TX.LOG.POS += 1

	// タスク読込位置の移動
	@TX.TASK.POS+=1

	return[]
}
#=es.TX.CLICK.204
{
	@es.TX.ICON.TYPE=0

	// タスク読込位置の移動
	@TX.TASK.POS+=1

	return[]
}

#=es.TX.TIMEINIT
{
	//----------------------------------------------------------------
	// 
	//----------------------------------------------------------------
		@TX.WaitTime.Start = @_OS_TIME(1)
		@TX.WaitTime.First = 1
		@TX.WaitTime.Next  = 0

	return[]
}


//--------------------------------------------------------------------
//■クリック待ち処理
//--------------------------------------------------------------------
#=es.TX.CLICKWAIT.MAIN
{
	IF[@es.TX.CWAIT==0]
	{
		IF[@es.WA.MODE==0] //これ入れないと \WA 中の CLICK スキップが効かない
			@es.TEXT.TIPCLICK = 0 //初期化される
		IFEND[]
	}
	ELSE[]
//	IF[1]
	{

		LOOP[SET=1]
		{

			//----------------------------------------------------------------
			// デバッグ機能 Tキーで現在のテキストをコピー
			//----------------------------------------------------------------
			/*	IF[@_DEBUGMODE>=0 && @_KEY_T==1]
				{
					//$_CHR(f0)系をあらかじめ処理
					//
					STR[$t=$TX]
					\_strlen($t)
					LOOP[]
					{
						//
						//
						//
						LOOPBREAK[]
					}
					LOOPEND[]

					CLIPACT[TEXT=1 SET=$TX]
				}
				IFEND[]
			*/


			//スキップ速度の調整
			//
			INT[@mSKIPTIME = @es.GSD(120,04)]
			  IF[@mSKIPTIME>=192] @mSKIPTIME = @es.GSD(120,04)*4
			ELSE[@mSKIPTIME>=128] @mSKIPTIME = @es.GSD(120,04)*2
			ELSE[@mSKIPTIME>=064] @mSKIPTIME = @es.GSD(120,04)*1.5
			IFEND[]


			//----------------------------------------------------------------
			// スキップ停止処理
			//----------------------------------------------------------------
			IF[@es.TX.SKIP]
			{
				IF[@_KEYLAST  >0] @_KEYLAST  =0;@es.TX.SKIP=0 IFBREAK[LV=2] IFEND[]
				IF[@_MOUSELAST>0] @_MOUSELAST=0;@es.TX.SKIP=0 IFBREAK[LV=2] IFEND[]

				IF[@_OS_TIME(1) - @SKIPTIME >= @mSKIPTIME]
				{
					GOSUB[#=es.VOICE.DEL] //強制的にボイス切る

					@SKIPTIME = @_OS_TIME(1)

					@es.TX.CWAIT=0

					LOOPBREAK[]
				}
				IFEND[]

			}
			IFEND[]


			{
				//----------------------------------------------------------------
				// テキスト文末停止時間チェック
				//----------------------------------------------------------------
					GOSUB[#=TextLineEndTime_Check]

					IF[@_RINT(1)] @es.TX.CWAIT=0;LOOPBREAK[] IFEND[]

				//----------------------------------------------------------------
				// 読み進める
				//----------------------------------------------------------------
					//----------------------------------------------------------------
					// 強制オートモードかつクリック不許可なら認識させない
					//----------------------------------------------------------------
IF[@es.SELMODE==0] ///x暫定的
{
						IF[\es.SuperAutoPlayMode==0 || \es.SuperAutoPlayTimeTextCl==1]
						{
							IF[@es.TEXT.TIPCLICK]
							{
								@es.TEXT.TIPCLICK=0
								@es.TX.CWAIT=0;@es.KEYOP.THRU.COUNT=5;LOOPBREAK[]
							}
							IFEND[]
						}
						IFEND[]


				//----------------------------------------------------------------
				// CTRLスキップ処理
				//----------------------------------------------------------------
					//IF[@es.gSKIP]
					{
						//----------------------------------------------------------------
						// 強制オートモードかつスキップ不許可ならCTRL認識させない
						//----------------------------------------------------------------
						IF[\es.SuperAutoPlayMode==0 || \es.SuperAutoPlayTimeTextSk==1]
						{
							IF[@_OS_TIME(1) - @SKIPTIME >= @mSKIPTIME]
							{

								IF[(@es.KIDOKUFLAG==1 || (@es.KIDOKUFLAG==0 && @es.GSD(110,05)==1)) && @es.TX.CSKIP>0]
								{
									GOSUB[#=es.VOICE.DEL] //CTRL押したなら強制的にボイス切る

									@SKIPTIME = @_OS_TIME(1)

									@es.TX.CWAIT=0

									LOOPBREAK[]
								}
								IFEND[]	//手動スキップ

							}
							IFEND[]
						}
						IFEND[]
					}
					//IFEND[]
}
IFEND[]

			}
//			IFEND[]


		}
		LOOPEND[]

	}
	IFEND[]


	/*
	@fl=0
	IF[@es.MG.AUTO]
	{
		@es.TX.SKIP=0
		@es.TX.AUTO=0

		IF[@es.MG.AUTONO==01 && @es.GSD(093,01)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==02 && @es.GSD(093,02)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==03 && @es.GSD(093,03)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==04 && @es.GSD(093,04)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==05 && @es.GSD(093,05)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==06 && @es.GSD(093,06)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==07 && @es.GSD(093,07)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==08 && @es.GSD(093,08)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==09 && @es.GSD(093,09)==1] @fl=1 IFEND[]
		IF[@es.MG.AUTONO==10 && @es.GSD(093,10)==1] @fl=1 IFEND[]

		IF[@fl]
		{
			IF[@_MOUSE_L==1 || @_MOUSE_L==2 || @_MOUSE_R==1 || @_MOUSE_R==2 || @es.TX.CSKIP>0]
			{
				@_MOUSE_L=0
				@_MOUSE_R=0
				@es.MG.AUTOSKIP=1
				//\_dmes("AUTOSKIP")
			}
			IFEND[]
		}
		IFEND[]
	}
	IFEND[]
	*/

	return[]
}




//-------------------------------------------------------------------------
//■行末処理
//-------------------------------------------------------------------------
#=es.TX.OUTPUT.LINEEND
{
	//------------------------------------------------------------
	// 行末の手動改行、手動改頁、手動自動クリック待ち有無を調べる
	//------------------------------------------------------------
		INT[@cf]INT[@rf]INT[@pf]
		INT[@pos]
		LOOP[]
		{
			\_strmid($TX.TASK, @TX.TASK.LEN-@_LC+1, 1)
			IF[$_RSTR(1)=="E"] LOOPCONTINUE[] IFEND[]
			IF[$_RSTR(1)=="2"]
			{
				\_strmid($TX, @TX.LEN-@pos, 1)
				@pos+=1
				IF[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF3)] @cf|=1; LOOPCONTINUE[] IFEND[] //c
				IF[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF5)] @cf|=1; LOOPCONTINUE[] IFEND[] //c(CP用)
				IF[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF0)] @rf|=1; LOOPCONTINUE[] IFEND[] //r
				IF[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF2)] @pf|=1; LOOPCONTINUE[] IFEND[] //p
			}
			IFEND[]
			LOOPBREAK[]
		}
		LOOPEND[]

	//------------------------------------------------------------
	// 自動改行、自動改頁、自動クリック待ち処理挿入
	//------------------------------------------------------------
//\_dmes("[BEFORE]"+$_CHR(13)+"$TX="+$TX+$_CHR(13)+"$TX.TASK="+$TX.TASK+"  @TX.TASK.LEN="+$(@TX.TASK.LEN)+$_CHR(13)+"crp="+$(@cf)+$(@rf)+$(@pf))

		IF[@TX.AUTOCLICK.N ==0 && @TX.AUTOCLICK.L ==1] //自動クリック待ち
			  IF[@cf] 
			ELSE[@rf] \_strleft($TX.TASK, @TX.TASK.LEN-0); $TX.TASK=$_RSTR(1)+"CR"; @TX.TASK.LEN+=2
			ELSE[@pf] \_strleft($TX.TASK, @TX.TASK.LEN-0); $TX.TASK=$_RSTR(1)+"CP"; @TX.TASK.LEN+=2
			ELSE[]                                         $TX.TASK+="C";           @TX.TASK.LEN+=1
			IFEND[]
		IFEND[]
		IF[@TX.AUTORETURN.N==0 && @TX.AUTORETURN.L==1] //自動改行
			  IF[@rf] 
			ELSE[@pf] \_strleft($TX.TASK, @TX.TASK.LEN-0); $TX.TASK=$_RSTR(1)+"RP"; @TX.TASK.LEN+=2
			ELSE[]                                         $TX.TASK+="R";           @TX.TASK.LEN+=1
			IFEND[]
		IFEND[] //自動改行
		IF[@TX.AUTOPAGE.N  ==0 && @TX.AUTOPAGE.L  ==1] //自動改頁
			$TX.TASK+="P";@TX.TASK.LEN+=1
		IFEND[]

//		@TX.AUTOCLICK.N  = 0
//		@TX.AUTORETURN.N = 0
//		@TX.AUTOPAGE.N   = 0

//\_dmes("[AFTER] "+$_CHR(13)+"$TX="+$TX+$_CHR(13)+"$TX.TASK="+$TX.TASK+"  @TX.TASK.LEN="+$(@TX.TASK.LEN)+$_CHR(13)+"crp="+$(@cf)+$(@rf)+$(@pf))

	//------------------------------------------------------------
	// 行末２挿入
	//------------------------------------------------------------
		$TX.TASK+="Z";@TX.TASK.LEN+=1

	//------------------------------------------------------------
	// (暫定処理)次の制御コードはノータイムに
	// (次のテキスト時に名前ウィンドウが一瞬チラつくのを防ぐため)
	//------------------------------------------------------------
		@TX.WaitTime.First=2

	return[]
}


//-------------------------------------------------------------------------
//■行末処理２
//-------------------------------------------------------------------------
#=es.TX.OUTPUT.Z
{

//	IF[@TX.AUTOCLICK.L]
	IF[1]
	{
		//------------------------------------------------------------
		// テキスト読込位置の初期化
		//------------------------------------------------------------
			@TX.POS = 1
		//	@TX.LOG.POS = 1
			@TX.TASK.POS = 1

	}
	IFEND[]

	//------------------------------------------------------------
	// 色情報格納位置の初期化
	//------------------------------------------------------------
		@TX.ColorWritePos = 1

	//------------------------------------------------------------
	// サイズ情報格納位置の初期化
	//------------------------------------------------------------
		@TX.SizeWritePos = 1

	//------------------------------------------------------------
	// 速度情報格納位置の初期化
	//------------------------------------------------------------
		@TX.WaitTimeWritePos = 1

	//------------------------------------------------------------
	// 
	//------------------------------------------------------------
		GOSUB[#=es.TX.TIMEINIT]

	//------------------------------------------------------------
	// 全タスク終了したら、ウェイトかけずにもう一度全タスクを実行
	//------------------------------------------------------------
//		WAIT[FRAME=1]
		TASK[RESTART=1]

	return[]
}



#=es.TextPageAfter2
{
	//------------------------------------------------------------
	// 文字情報初期化
	//------------------------------------------------------------
		IF[1] ///x 設定可能にする.
		{
			$TX.DEFSTR = $T(36,18)
			GOSUB[#=es.TDDEF.SEARCH pstr=$TX.DEFSTR]
			@TX.SX = @_RINT(1) / 65536
			@TX.SY = @_RINT(1) % 65536
			@TX.COLOR  = @_RINT(2)
			@TX.COLOR2 = @_RINT(3)
			@TX.SHADE.X = @_RINT(5) / 65536
			@TX.SHADE.Y = @_RINT(5) % 65536
			@TX.SHADE.COLOR = @_RINT(6)
			@TX.OUTLINE.COLOR = @_RINT(7)

			$TXN.DEFSTR = $T(36,31)
			GOSUB[#=es.TDDEF.SEARCH pstr=$TXN.DEFSTR]
			@TXN.SX = @_RINT(1) / 65536
			@TXN.SY = @_RINT(1) % 65536
			@TXN.COLOR  = @_RINT(2)
			@TXN.COLOR2 = @_RINT(3)
			@TXN.SHADE.X = @_RINT(5) / 65536
			@TXN.SHADE.Y = @_RINT(5) % 65536
			@TXN.SHADE.COLOR = @_RINT(6)
			@TXN.OUTLINE.COLOR = @_RINT(7)

			$TX.RUBY.DEFSTR = $T(36,22)
			GOSUB[#=es.TDDEF.SEARCH pstr=$TX.RUBY.DEFSTR]
			@TX.RUBY.SX = @_RINT(1) / 65536
			@TX.RUBY.SY = @_RINT(1) % 65536
			@TX.RUBY.COLOR  = @_RINT(2)
			@TX.RUBY.COLOR2 = @_RINT(3)
			@TX.RUBY.SHADE.X = @_RINT(5) / 65536
			@TX.RUBY.SHADE.Y = @_RINT(5) % 65536
			@TX.RUBY.SHADE.COLOR = @_RINT(6)
			@TX.RUBY.OUTLINE.COLOR = @_RINT(7)

			@TX.TCFLAG = 0
		}
		IFEND[]


	//------------------------------------------------------------
	// 
	//------------------------------------------------------------
		GOSUB[#=es.TX.TIMEINIT]


	//------------------------------------------------------------
	// テキスト一括表示フラグの初期化
	//------------------------------------------------------------
		@es.TX.IKKATSU = 0


	//------------------------------------------------------------
	// 自動空白挿入機能オンに戻す
	//------------------------------------------------------------
		@es.LSD(035,01)=0
		@es.LSD(035,02)=0

///xLUN
	//------------------------------------------------------------
	// オートモード進行バー画像初期化
	//------------------------------------------------------------
		//


	//------------------------------------------------------------
	// テキストカウント用
	//------------------------------------------------------------
		IF[@es.LSD(091,04)>0]
		{
			@es.LSD(091,04)-=1
			IF[@es.LSD(091,04)<=0]
			{
				//初期化
				@es.LSD(091,06)=0
			}
			IFEND[]
		}
		IFEND[]
		IF[@es.LSD(091,03)>0]
		{
			@es.LSD(091,03)-=1
			IF[@es.LSD(091,03)<=0]
			{
				//初期化
				@es.LSD(091,06)=0
			}
			IFEND[]
		}
		IFEND[]


	//------------------------------------------------------------
	// 名前 or 名前画像表示されていたらクリア
	// ※スキップ高速化のため名前があった時だけ処理する
	//------------------------------------------------------------
		IF[@TXN.EXIST]
		{
			@TXN.EXIST=0
			GOSUB[#=es.NAMEW.CLEAR]
		}
		IFEND[]

	//------------------------------------------------------------
	// 名前初期化
	//------------------------------------------------------------
		GOSUB[#=es.TX.NAMEINIT]


	return[]
}


//============================================================================
//
//■テキスト文末停止時間チェック
//
//============================================================================
#=TextLineEndTime_Check
{

	INT[@playflag]
	INT[@c]INT[@b]
	INT[@Ret]

	INT[@tx_per]
	INT[@vo_per]

	//----------------------------------------------------------------
	// 強制オートモードON
	//----------------------------------------------------------------
		IF[\es.SuperAutoPlayMode]
		{
			//テキスト
			IF[@_OS_TIME(1) - @TX.LineEndTime > \es.SuperAutoPlayTimeTextSt]
			{
				@tx_per = 100
			}
			ELSE[]
			{
				@tx_per = (@_OS_TIME(1) - @TX.LineEndTime) * 100.0 / ((@es.GSD(120,02)+25)*20)
			}
			IFEND[]

				@es.AUTO.PER = @tx_per
				GOSUB[#=es.BT.TR.SET pstr="ES.GAMEMAIN.TIP.AUTOGAUGE" pint2=2 pint3=@es.AUTO.PER*256/100]

			//ボイス
			LOOP[SET=(10)]
			{
				\VO.PCHK(@_LC);@c=@_RINT(2);@b=@_LC

				//ミュート設定の場合は再生していないものと認識させる
				@playflag += @_RINT(1) * @es.GSD(010,@c)*@es.GSD(012,@c)*@es.LSD(010,@c)*@es.LSD(012,@c) * @es.GSD(005,50+@b)*@es.GSD(008,50+@b)*@es.LSD(005,50+@b)*@es.LSD(008,50+@b)
			}
			LOOPEND[]
			IF[@playflag==0] @vo_per=100 IFEND[]

			IF[@tx_per==100 && @vo_per==100] @Ret=1 IFEND[]

		}
	//----------------------------------------------------------------
	// 強制オートモードOFF
	//----------------------------------------------------------------
		ELSE[]
		{
			IF[@es.TX.AUTO]
			{
				//テキスト
				IF[@_OS_TIME(1) - @TX.LineEndTime > (@es.GSD(120,02)+25)*20] //500〜5620ms
				{
					@tx_per = 100
				}
				ELSE[]
				{
					@tx_per = (@_OS_TIME(1) - @TX.LineEndTime) * 100.0 / ((@es.GSD(120,02)+25)*20)
				}
				IFEND[]

					@es.AUTO.PER = @tx_per
					GOSUB[#=es.BT.TR.SET pstr="ES.GAMEMAIN.TIP.AUTOGAUGE" pint2=2 pint3=@es.AUTO.PER*256/100]

				//ボイス
				IF[@es.GSD(111,01)==0] //ボイス終了まで待たない
				{
					@vo_per=100
				}
				ELSE[]                //ボイス終了まで待つ
				{
					LOOP[SET=(10)]
					{
						\VO.PCHK(@_LC);@c=@_RINT(2);@b=@_LC

						//ミュート設定の場合は再生していないものと認識させる
						@playflag += @_RINT(1) * @es.GSD(010,@c)*@es.GSD(012,@c)*@es.LSD(010,@c)*@es.LSD(012,@c) * @es.GSD(005,50+@b)*@es.GSD(008,50+@b)*@es.LSD(005,50+@b)*@es.LSD(008,50+@b)
					}
					LOOPEND[]

					IF[@playflag==0] @vo_per=100 IFEND[]
				}
				IFEND[]

				IF[@tx_per==100 && @vo_per==100] @Ret=1 IFEND[]
			}
			IFEND[]
		}
		IFEND[]

	return[RINT=@Ret]
}


//============================================================================
//
//■テキストからルビ抜き出し
//
//============================================================================
#=es.TX.RUBY.CHK
{

	STR[$mFN]
	STR[$mKANAStr]
	INT[@mNUM]
	INT[@mRMode]
	INT[@mStartPos]
	INT[@mEndPos]

	//------------------------------------------------------------
	// 変数初期化
	//------------------------------------------------------------
		LOOP[SET=\.TX.MAX] @TX.BUF.RUBY(@_LC)=0 LOOPEND[] // ルビ情報バッファ
		@mRMode = 0 //ルビモード
		@mNUM = 1 //ルビ数
		@TX.RUBY.AnalyzePos = 0 // 解析位置

	//------------------------------------------------------------
	// 文字数を調べる
	//------------------------------------------------------------
		\_strlen($TX)
		@TX.RUBY.AnalyzeLen = @_RINT(1)

	//------------------------------------------------------------
	// 文字列を順にチェックする
	//------------------------------------------------------------
		STR[$one]

		LOOP[]
		{

			//------------------------------------------------------------
			// 全文字列チェック終わったら抜ける.
			//------------------------------------------------------------
				@TX.RUBY.AnalyzePos+=1
				IF[@TX.RUBY.AnalyzePos > @TX.RUBY.AnalyzeLen] LOOPBREAK[] IFEND[]

			//------------------------------------------------------------
			// １文字分抽出
			//------------------------------------------------------------
				\_strmid($TX, @TX.RUBY.AnalyzePos, 1)
				$one = $_RSTR(1)

			//------------------------------------------------------------
			// ルビ開始文字チェック
			//------------------------------------------------------------
				IF[$one==$TX.RubyStartStr]
				{

					//------------------------------------------------------------
					// ルビ振り記述エラーチェック
					//------------------------------------------------------------
						IF[@mRMode!=0]
						{
							\_task.info($es.ScenarioTaskID, 1);$mFN=$_RSTR(1)
							\_inttostr(@_RINT(3))
							\_mes( "[エラー] "+$mFN+" "+$_RSTR(1)+"行目 ルビ記述エラーです。" )
							END[]
						}
						IFEND[]

					//------------------------------------------------------------
					// ルビモード１へ
					//------------------------------------------------------------
						@mRMode = 1

					//------------------------------------------------------------
					// テキストを削除
					//------------------------------------------------------------
						GOSUB[#=es.TX.RUBY.CUTTEXT]

					//------------------------------------------------------------
					// ルビ振り開始文字位置格納
					//------------------------------------------------------------
						@mStartPos = @TX.RUBY.AnalyzePos + 1

					//------------------------------------------------------------
					// ルビ格納文字列初期化
					//------------------------------------------------------------
						$mKANAStr = ""

						LOOPCONTINUE[]

				}
				IFEND[]


			//------------------------------------------------------------
			// ルビ中間区切り文字チェック
			// ルビ設定内でのみ検出させる.それ以外は普通に出力文字扱い.
			//------------------------------------------------------------
				IF[$one==$TX.RubyCenterStr && @mRMode==1]
				{

					//------------------------------------------------------------
					// ルビモード２へ
					//------------------------------------------------------------
						@mRMode = 2

					//------------------------------------------------------------
					// テキストを削除
					//------------------------------------------------------------
						GOSUB[#=es.TX.RUBY.CUTTEXT]

					//------------------------------------------------------------
					// ルビ振り終了文字位置格納
					//------------------------------------------------------------
						@mEndPos = @TX.RUBY.AnalyzePos

					//------------------------------------------------------------
					// ルビ振り記述エラーチェック
					//------------------------------------------------------------
						IF[@mEndPos < @mStartPos]
						{
							\_task.info($es.ScenarioTaskID, 1);$mFN=$_RSTR(1)
							\_inttostr(@_RINT(3))
							\_mes( "[エラー] "+$mFN+" "+$_RSTR(1)+"行目 ルビ記述エラーです。" )
							END[]
						}
						IFEND[]


						//VARACT[SET=@mStartPos TYPE=1 LET=$Msg] \_dmes("StartPos = "+$Msg)
						//VARACT[SET=@mEndPos   TYPE=1 LET=$Msg] \_dmes("EndPos   = "+$Msg)


						LOOPCONTINUE[]

				}
				IFEND[]


			//------------------------------------------------------------
			// ルビ終了文字チェック
			//------------------------------------------------------------
				IF[$one==$TX.RubyEndStr]
				{

					//------------------------------------------------------------
					// ルビ振り記述エラーチェック
					//------------------------------------------------------------
						IF[@mRMode!=2]
						{
							\_task.info($es.ScenarioTaskID, 1);$mFN=$_RSTR(1)
							\_inttostr(@_RINT(3))
							\_mes( "[エラー] "+$mFN+" "+$_RSTR(1)+"行目 ルビ記述エラーです。" )
							END[]
						}
						IFEND[]

					//------------------------------------------------------------
					// ルビモード０へ
					//------------------------------------------------------------
						@mRMode = 0

					//------------------------------------------------------------
					// テキストを削除
					//------------------------------------------------------------
						GOSUB[#=es.TX.RUBY.CUTTEXT]

						//\_dmes("ふりがな = "+$mKANAStr)

					//------------------------------------------------------------
					// ルビ振りデータをバッファへセット
					//------------------------------------------------------------
						IF[$mKANAStr != ""]
						{
							// ルビ番号をセット
							@TX.BUF.RUBY( @mStartPos ) = @mNUM

							// ルビ文字をセット
							$TX.BUF.RUBY.STR( @mNUM ) = $mKANAStr

							// ルビを振られる方の文字数をセット
							@TX.BUF.RUBY.SRCLEN( @mNUM ) = @mEndPos - @mStartPos + 1

							// ルビ番号を＋１
							@mNUM += 1

							IF[@mNUM >= 64]
							{
								\_task.info($es.ScenarioTaskID, 1);$mFN=$_RSTR(1)
								\_inttostr(@_RINT(3))
								\_mes( "[エラー] "+$mFN+" "+$_RSTR(1)+"行目 ルビ指定が多すぎます。" )
							}
							IFEND[]
						}
						IFEND[]


						LOOPCONTINUE[]

				}
				IFEND[]

			//------------------------------------------------------------
			// ふりがな文字チェック
			//------------------------------------------------------------
				IF[@mRMode==2]
				{
					$mKANAStr += $one // ふりがな文字連結

					GOSUB[#=es.TX.RUBY.CUTTEXT] // １文字分カット

					LOOPCONTINUE[]
				}
				IFEND[]

		}
		LOOPEND[]


	//------------------------------------------------------------
	// ルビ設定モードが終了していなかったらエラー.
	//------------------------------------------------------------
		IF[@mRMode>0]
		{
			\_task.info($es.ScenarioTaskID, 1);$mFN=$_RSTR(1)
			\_inttostr(@_RINT(3))
			\_mes( "[エラー] "+$mFN+" "+$_RSTR(1)+"行目 ルビ記述エラーです。" )
		}
		IFEND[]


	return[]
}



//------------------------------------------------------------
//■テキストを削除
//------------------------------------------------------------
#=es.TX.RUBY.CUTTEXT
{

	//------------------------------------------------------------
	// 各種バッファを前にずらす.
	//------------------------------------------------------------
		\_strlen($TX)
		INT[@mLen=@_RINT(1)]
		INT[@mI]
		IF[@mLen-@TX.RUBY.AnalyzePos-(1)>0]
		{
			LOOP[SET=@mLen-@TX.RUBY.AnalyzePos-(1)]
			{
				@mI = @TX.RUBY.AnalyzePos+@_LC-1
				@TX.BUF.X(@mI)      = @TX.BUF.X(@mI+1)
				@TX.BUF.Y(@mI)      = @TX.BUF.Y(@mI+1)
				@TX.BUF.SB(@mI)     = @TX.BUF.SB(@mI+1)
				@TX.BUF.SX(@mI)     = @TX.BUF.SX(@mI+1)
				@TX.BUF.SY(@mI)     = @TX.BUF.SY(@mI+1)
				@TX.BUF.COLOR(@mI)  = @TX.BUF.COLOR(@mI+1)
				@TX.BUF.COLOR2(@mI) = @TX.BUF.COLOR2(@mI+1)
				@TX.BUF.TCFLAG(@mI) = @TX.BUF.TCFLAG(@mI+1)
				@TX.BUF.SPD(@mI)    = @TX.BUF.SPD(@mI+1)
				@TX.BUF.RUBY(@mI)   = @TX.BUF.RUBY(@mI+1)
			}
			LOOPEND[]
		}
		IFEND[]

	//------------------------------------------------------------
	// テキストを削除
	//------------------------------------------------------------
		VARACT[CUT=1 SET=$TX POS=@TX.RUBY.AnalyzePos LENGTH=1]

	//------------------------------------------------------------
	// テキストタスクを削除
	//------------------------------------------------------------
		//VARACT[CUT=1 SET=$TX.TASK POS=@TX.RUBY.AnalyzePos LENGTH=1]

		INT[@mC]
		INT[@mPos]
		LOOP[]

			\_strmid($TX.TASK, @_LC, 1)

			IF[$_RSTR(1)=="1" || $_RSTR(1)=="2"] @mC+=1 IFEND[]

			IF[@mC==@TX.RUBY.AnalyzePos] @mPos=@_LC LOOPBREAK[] IFEND[]

		LOOPEND[]

		VARACT[CUT=1 SET=$TX.TASK POS=@mPos LENGTH=1]

	@TX.RUBY.AnalyzePos-=1
	@TX.RUBY.AnalyzeLen-=1

//	@TX.ColorWritePos-=1
//	@TX.SizeWritePos-=1

	return[]
}



//============================================================================
//
//■テキストサイズ変更
//
//============================================================================
#=es.TextSizeChange
{
	//------------------------------------------------------------
	// この時点までのサイズ情報をバッファに格納する
	//------------------------------------------------------------
		GOSUB[#=es.TX.BUFSET.SIZE]

	//------------------------------------------------------------
	// 新しいサイズを設定する
	//------------------------------------------------------------
//		$TX.DEFSTR = $_PSTR(1)
//		GOSUB[#=es.TDDEF.SEARCH pstr=$TX.DEFSTR]
//		@TX.SX = @_RINT(1) / 65536
//		@TX.SY = @_RINT(1) % 65536
		@TX.SX = @_PINT(1)
		@TX.SY = @_PINT(2)
		IF[@TX.SX==-1] @TX.SX=(22);@TX.SY=(22) IFEND[]
		IF[@TX.SY==-1] @TX.SY=@TX.SX IFEND[]

		IF[@TX.SX<=0 || @TX.SY<=0] \_mes("文字サイズ指定が不適切です。") END[] IFEND[]

	return[]
}


//============================================================================
//
//■テキスト色変更
//
//============================================================================
#=es.TextColorChange
{
	//------------------------------------------------------------
	// この時点での色情報をバッファに格納する
	//------------------------------------------------------------
		GOSUB[#=es.TX.BUFSET.COL]

	//------------------------------------------------------------
	// 色を設定
	//------------------------------------------------------------
		IF[@_PINT(1)!=-1]	//新しい色にセット.
		{
			@TX.COLOR  = @_PINT(1)
			@TX.COLOR2 = @_PINT(2)
			@TX.TCFLAG = 1

			IF[@TX.COLOR < 0 || @TX.COLOR>0xFFFFFF] \_mes("文字色指定が不適切です。") END[] IFEND[]
			IF[@TX.COLOR2<-1 || @TX.COLOR>0xFFFFFF] \_mes("文字色指定が不適切です。") END[] IFEND[]
		}
		ELSE[]				//色を元に戻す
		{
			GOSUB[#=es.TDDEF.SEARCH pstr=$TX.DEFSTR]
			@TX.COLOR  = @_RINT(2)
			@TX.COLOR2 = @_RINT(3)
			@TX.TCFLAG = 0
		}
		IFEND[]

	return[]
}


//============================================================================
//
//■テキスト情報変更
//
//============================================================================
#=es.TextDefineChange
{
	//------------------------------------------------------------
	// この時点での色情報をバッファに格納する
	//------------------------------------------------------------
		GOSUB[#=es.TX.BUFSET.COL]
		GOSUB[#=es.TX.BUFSET.SIZE]

	//------------------------------------------------------------
	// 新しい色を設定する
	//------------------------------------------------------------
	//	$TX.DEFSTR = $_PSTR(1)
	//	GOSUB[#=es.TDDEF.SEARCH pstr=$TX.DEFSTR]
		GOSUB[#=es.TDDEF.SEARCH pstr=$_PSTR(1)]
		@TX.SX = @_RINT(1) / 65536
		@TX.SY = @_RINT(1) % 65536
		@TX.COLOR  = @_RINT(2)
		@TX.COLOR2 = @_RINT(3)
		@TX.SHADE.X = @_RINT(5) / 65536
		@TX.SHADE.Y = @_RINT(5) % 65536
		@TX.SHADE.COLOR = @_RINT(6)
		@TX.OUTLINE.COLOR = @_RINT(7)

		IF[@TX.SX==-1] @TX.SX=(22);@TX.SY=(22) IFEND[]
		IF[@TX.SY==-1] @TX.SY=@TX.SX IFEND[]

		IF[@TX.SX<=0 || @TX.SY<=0] \_mes("文字サイズ指定が不適切です。") END[] IFEND[]

		IF[@TX.COLOR < 0 || @TX.COLOR>0xFFFFFF] \_mes("文字色指定が不適切です。") END[] IFEND[]
		IF[@TX.COLOR2<-1 || @TX.COLOR>0xFFFFFF] \_mes("文字色指定が不適切です。") END[] IFEND[]

	return[]
}


//============================================================================
//
//■テキスト速度変更
//
//============================================================================
#=es.TextWaitTimeChange
{
	//------------------------------------------------------------
	// この時点での速度情報をバッファに格納する
	//------------------------------------------------------------
		GOSUB[#=es.TX.BUFSET.SPD]

	//------------------------------------------------------------
	// 速度情報を変更する
	//------------------------------------------------------------
		@TX.SPD = @_PINT(1)

	return[]
}


//-------------------------------------------------------------------------
//■サイズ情報をバッファに格納する
//-------------------------------------------------------------------------
#=es.TX.BUFSET.SIZE
{
	STR[$str]
	INT[@num]
	INT[@pos]

	\_strlen($_TEXT)
	INT[@mLen=@_RINT(1)]
	IF[@mLen>0]
	{
		@num = (@mLen - @TX.SizeWritePos + 1) //何文字分格納か
		@pos = @TX.SizeWritePos //文字タスク情報の読み取り位置
IF[@TX.SizeWritePos<0] \_mes("TX.SizeWritePos Error.");END[] IFEND[]
		LOOP[]
		{
			\_strmid($_TEXT_FLAG, @pos, 1)
			$str = $_RSTR(1)
			IF[$str=="1"]
			{
				@TX.BUF.SB(@TX.SizeWritePos) = @TX.SX
				@TX.BUF.SX(@TX.SizeWritePos) = @TX.SX/2
				@TX.BUF.SY(@TX.SizeWritePos) = @TX.SY
				@TX.SizeWritePos += 1
				@num-=1
			}
			ELSE[$str=="2"]
			{
				@TX.BUF.SB(@TX.SizeWritePos) = @TX.SX
				@TX.BUF.SX(@TX.SizeWritePos) = @TX.SX
				@TX.BUF.SY(@TX.SizeWritePos) = @TX.SY
				@TX.SizeWritePos += 1
				@num-=1
			}
			IFEND[]

			IF[@num==0] LOOPBREAK[] IFEND[]

			@pos+=1
			IF[@pos>\.TX.MAX]
			{
				\_mes("テキスト内部エラーです。テキストサイズ情報を正しく格納できませんでした。")
				END[]
			}
			IFEND[]

		}
		LOOPEND[]
	}
	IFEND[]

	return[]
}


//-------------------------------------------------------------------------
//■色情報をバッファに格納する
//-------------------------------------------------------------------------
#=es.TX.BUFSET.COL
{
	\_strlen($_TEXT)
	INT[@mLen=@_RINT(1)]
	IF[@mLen>0]
	{
//\_dmes("COL="+$@TX.ColorWritePos)
		LOOP[SET=(@mLen - @TX.ColorWritePos + 1)]
		{
			@TX.BUF.COLOR(@TX.ColorWritePos)  = @TX.COLOR
			@TX.BUF.COLOR2(@TX.ColorWritePos) = @TX.COLOR2
			@TX.BUF.TCFLAG(@TX.ColorWritePos) = @TX.TCFLAG
			@TX.ColorWritePos += 1
		}
		LOOPEND[]
	}
	IFEND[]

	return[]
}

//-------------------------------------------------------------------------
//■速度情報をバッファに格納する
//-------------------------------------------------------------------------
#=es.TX.BUFSET.SPD
{
	\_strlen($_TEXT)
	INT[@mLen=@_RINT(1)]
	IF[@mLen>0]
	{
		LOOP[SET=(@mLen - @TX.WaitTimeWritePos + 1)]
		{
			@TX.BUF.SPD(@TX.WaitTimeWritePos) = @TX.SPD * 100 / 256

			IF[\es.SuperAutoPlayMode] @TX.BUF.SPD(@TX.WaitTimeWritePos) = \es.SuperAutoPlayTimeTextSp IFEND[]

			@TX.WaitTimeWritePos += 1
		}
		LOOPEND[]
	}
	IFEND[]

	return[]
}


//============================================================================
//
//■表示位置情報をバッファに格納（禁則処理付）
//
//============================================================================
#=es.TX.BUFSET.XY
{
	INT[@mX]
	INT[@mY]
	INT[@mLineStartPos]
	INT[@mLineEndPos]
	INT[@mSY.MAX]
	STR[$mTX]
	STR[$mTX.Task]

	INT[@mPos=1]     //テキスト解析位置
	INT[@mTASKPos=1] //テキストタスク解析位置

	INT[@mReturnFlag] //改行フラグ
	INT[@mRepageFlag] //改頁フラグ


	@mY = @TX.PrevLine.Y // Y初期位置(前のテキストからの足し分.自動改行無効時など)
	IF[@T(36,21)] @mY += @TX.RUBY.SY + @T(36,24) IFEND[]


///x暫定処置.はみ出した文字は全て-99999が入るよう、あらかじめその値で初期化しておく
	\_strlen($TX)
	LOOP[SET=@_RINT(1)+1]
	{
		@TX.BUF.X(@_LC-1) = 99999
		@TX.BUF.Y(@_LC-1) = 99999
	}
	LOOPEND[]


	//ボタンサイズ取得
	GOSUB[#=es.BT.SXY.GET pstr="ES.GAMEMAIN.TIP.MESW.TX" pint2=0]
	INT[@mesw_sx=@_RINT(1)]
	INT[@mesw_sy=@_RINT(2)]

	LOOP[]
	{
		//----------------------------------------------------------------
		// １行の頭とお尻の位置を算出する.
		//----------------------------------------------------------------
			@mLineStartPos = @mPos // 行頭位置取得

			@mX = @TX.PrevLine.X // X初期位置(前のテキストからの足し分.自動改行無効時など)

			LOOP[]
			{

				\_strmid($TX, @mPos, 1);$mTX=$_RSTR(1)
				\_strmid($TX.TASK, @mTASKPos, 1);$mTX.Task=$_RSTR(1)

				  IF[$mTX.Task=="2" && $mTX==$_CHR(0xEF)+$_CHR(0xF0)] //R
				{
					@mPos+=1;@mTASKPos+=1;@mReturnFlag=1;LOOPBREAK[]
				}
				ELSE[$mTX.Task=="2" && $mTX==$_CHR(0xEF)+$_CHR(0xF2)] //P
				{
					@mPos+=1;@mTASKPos+=1;@mRepageFlag=1;
					IF[@TX.AUTOCLICK.L==0] @TX.SCRIPTSAVEFLAG=1 IFEND[]
					LOOPBREAK[]
				}
				ELSE[$mTX.Task=="2" && $mTX==$_CHR(0xEF)+$_CHR(0xF3)] //C
				{
					@mPos+=1;@mTASKPos+=1;LOOPCONTINUE[]
				}
				ELSE[$mTX.Task=="2" && $mTX==$_CHR(0xEF)+$_CHR(0xF4)] //CR
				{
					@mPos+=1;@mTASKPos+=1;@mReturnFlag=1;LOOPBREAK[]
				}
				ELSE[$mTX.Task=="2" && $mTX==$_CHR(0xEF)+$_CHR(0xF5)] //CP
				{
					@mPos+=1;@mTASKPos+=1;@mRepageFlag=1;LOOPCONTINUE[]
				}
				ELSE[$mTX.Task=="2" || $mTX.Task=="1"] //文字ならば
				{
					IF[(@mX + @TX.StartPosX) + @TX.BUF.SX(@mPos)*2 + @T(36,19) >= @mesw_sx - 1] @mReturnFlag=1;LOOPBREAK[] IFEND[]
					@mX += @TX.BUF.SX(@mPos) + @T(36,19)
					@mPos+=1
				//	IF[@mPos > @TX.LEN] LOOPBREAK[] IFEND[]

				}
				IFEND[]

				@mTASKPos += 1
				IF[@mTASKPos > @TX.TASK.LEN] LOOPBREAK[] IFEND[]

			}
			LOOPEND[]

			@mLineEndPos = @mPos - 1 // 行末位置取得


			//----------------------------------------------------------------
			// １行に１文字以上あった.
			//----------------------------------------------------------------
				IF[@mLineEndPos >= @mLineStartPos]
				{

					//----------------------------------------------------------------
					// 禁則処理 (その文字列配置で正しいか否かをチェック)
					//----------------------------------------------------------------

						//行頭禁則チェック ///x
						//

						//行末禁則チェック ///x
						//

						//ぶら下げ文字チェック
						//
						\_strmid($TX, @mLineEndPos+1, 1)
					//	IF[$_RSTR(1)=="、" || $_RSTR(1)=="。" || $_RSTR(1)=="，" || $_RSTR(1)=="．"]
						IF[$_RSTR(1)=="、" || $_RSTR(1)=="。" || $_RSTR(1)=="，" || $_RSTR(1)=="．" || $_RSTR(1)=="」" || $_RSTR(1)=="』" || $_RSTR(1)=="）"] ///x後ろ３つ暫定.いずれ行頭禁則へ.
						{
							@mPos += 1
							@mTASKPos += 1
							@mLineEndPos = @mPos - 1
						}
						IFEND[]


					//----------------------------------------------------------------
					// 頭からお尻までの範囲の中で一番高さのある文字を取得.
					//----------------------------------------------------------------
						@mSY.MAX = 0
						LOOP[SET=@mLineEndPos-@mLineStartPos+1]
						{
							IF[@mSY.MAX < @TX.BUF.SY(@mLineStartPos+@_LC-1)]
								@mSY.MAX = @TX.BUF.SY(@mLineStartPos+@_LC-1)
							IFEND[]
						}
						LOOPEND[]
						@TX.SY.MAX = @mSY.MAX

					//----------------------------------------------------------------
					// 表示位置情報をバッファに格納していく.
					//----------------------------------------------------------------
						@mX = @TX.PrevLine.X // X初期位置(前のテキストからの足し分.自動改行無効時など)
						LOOP[SET=@mLineEndPos-@mLineStartPos+1]
						{
							@TX.BUF.X(@mLineStartPos+@_LC-1) = @TX.StartPosX + @mX
							@TX.BUF.Y(@mLineStartPos+@_LC-1) = @TX.StartPosY + @mY + ( @mSY.MAX - @TX.BUF.SY(@mLineStartPos+@_LC-1) )

							\_strmid($TX, @mLineStartPos+@_LC-1, 1)
							  IF[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF0)] //R
							ELSE[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF2)] //P
							ELSE[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF3)] //C
							ELSE[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF4)] //CR
							ELSE[$_RSTR(1)==$_CHR(0xEF)+$_CHR(0xF5)] //CP
							ELSE[]
							{
								@mX += @TX.BUF.SX(@mLineStartPos+@_LC-1) + @T(36,19)
								@TX.PrevLine.X = @mX
							}
							IFEND[]

						}
						LOOPEND[]

				}
			//----------------------------------------------------------------
			// １行に１文字もなかった.(改行だけ等)
			//----------------------------------------------------------------
				ELSE[]
				{
					@mSY.MAX = @TX.BUF.SY(@mPos)
				}
				IFEND[]


		//----------------------------------------------------------------
		// １行分の処理が終了.次の行へ.
		//----------------------------------------------------------------
			IF[@mReturnFlag]
			{
				@mReturnFlag = 0
				@TX.PrevLine.X = 0

				@mY += @mSY.MAX + @T(36,20)
				@TX.PrevLine.Y = @mY
				IF[@T(36,21)] @mY += @TX.RUBY.SY + @T(36,24) IFEND[]

///xTOC
IF[@es.LSD(035,01)==0] //自動空白挿入機能オンならば
{
		//	IF[@TXN.EXIST==1]
			IF[$TXN.NAME.CG!="" || $TXN.NAME.TEXT!=""]
			{
				@TX.PrevLine.X += @TX.BUF.SX(@mLineStartPos) + @T(36,19)
			}
			IFEND[]
}
IFEND[]

				//@mY = 0  // 初期位置
				//IF[@T(36,21)] @mY += @TX.RUBY.SY + @T(36,24) IFEND[]
			}
			IFEND[]

			IF[@mRepageFlag]
			{
				@mRepageFlag = 0
				@TX.PrevLine.X = 0
				@TX.PrevLine.Y = 0
				@mY = 0  // 初期位置
				IF[@T(36,21)] @mY += @TX.RUBY.SY + @T(36,24) IFEND[]
			}
			IFEND[]

		//----------------------------------------------------------------
		// 表示可能範囲超えたらループ抜ける.
		//----------------------------------------------------------------
			IF[@mY + @TX.StartPosY >= @mesw_sy] LOOPBREAK[] IFEND[]

		//----------------------------------------------------------------
		// 全文字列分終わったらループ抜ける.
		//----------------------------------------------------------------
		//	IF[@mPos > @TX.LEN] LOOPBREAK[] IFEND[]
			IF[@mTASKPos > @TX.TASK.LEN] LOOPBREAK[] IFEND[]

	}
	LOOPEND[]


	return[]
}



//============================================================================
//
//■テキストからキャラ名抜き出し
//
//============================================================================
#=es.TX.CHARNAME.CHK
{
	INT[@CharNo]
	INT[@lenA]
	INT[@lenB]

	IF[@TX.PrevLine.X==0 && @TX.PrevLine.Y==0]
//	IF[@TX.PrevLine.X==0 && @TX.PrevLine.Y==0 && $TXN.NAME.TEXT==""]
	{
		//------------------------------------------------------------
		// テキストを検索
		//   $TX に キャラ名「〜」という表記があるかどうか
		//------------------------------------------------------------
			GOSUB[#=es.CHAR.NAME.SEARCH PSTR=$TX]
			@CharNo        = @_RINT(1)
			@lenA          = @_RINT(2)
			$TXN.NAME.TEXT = $_RSTR(3)
			$TXN.NAME.CG   = $_RSTR(4)
			@lenB          = @_RINT(5)

		IF[@CharNo>0] //あったなら
		{
			//------------------------------------------------------------
			// テキストを削除
			//   $TX から名前文字列を削除する
			//------------------------------------------------------------
				VARACT[CUT=1 SET=$TX POS=1 LENGTH=@lenA]

			//------------------------------------------------------------
			// テキストタスクを削除
			//   文字タスク「1」or「2」の最初に現れる位置を探す
			//------------------------------------------------------------
				INT[@mC]
				INT[@mPos]
				LOOP[]
				{
					\_strmid($TX.TASK, @_LC, 1)

					IF[$_RSTR(1)=="1" || $_RSTR(1)=="2"] @mC+=1 IFEND[]

					IF[@mC==1] @mPos=@_LC LOOPBREAK[] IFEND[]
				}
				LOOPEND[]

				VARACT[CUT=1 SET=$TX.TASK POS=@mPos LENGTH=@lenA]

			//------------------------------------------------------------
			// 各種バッファを前にずらす.
			//------------------------------------------------------------
				LOOP[SET=\.TX.MAX-@lenA]
				{
					@TX.BUF.X(@_LC)      = @TX.BUF.X(@_LC+@lenA)
					@TX.BUF.Y(@_LC)      = @TX.BUF.Y(@_LC+@lenA)
					@TX.BUF.SB(@_LC)     = @TX.BUF.SB(@_LC+@lenA)
					@TX.BUF.SX(@_LC)     = @TX.BUF.SX(@_LC+@lenA)
					@TX.BUF.SY(@_LC)     = @TX.BUF.SY(@_LC+@lenA)
					@TX.BUF.COLOR(@_LC)  = @TX.BUF.COLOR(@_LC+@lenA)
					@TX.BUF.COLOR2(@_LC) = @TX.BUF.COLOR2(@_LC+@lenA)
					@TX.BUF.TCFLAG(@_LC) = @TX.BUF.TCFLAG(@_LC+@lenA)
					@TX.BUF.SPD(@_LC)    = @TX.BUF.SPD(@_LC+@lenA)
					@TX.BUF.RUBY(@_LC)   = @TX.BUF.RUBY(@_LC+@lenA)
				}
				LOOPEND[]

///xFSM
//\_dmes("@lenB="+$(@lenB))
//	LOOP[SET=@lenA]
	LOOP[SET=@lenB]
	{
		\_strmid($TXN.NAME.TEXT, @_LC, 1)
		\LOG.ONE($_RSTR(1))
	}
	LOOPEND[]

///xLUN
IF[@es.LSD(035,01)==0] //自動空白挿入機能オンならば
	\LOG.ONE($_CHR(0xEF)) //名前存在フラグ
	\LOG.ONE($_CHR(0xEF)) //名前存在フラグ
	@es.LSD(035,02)=1
ELSE[]
	\LOG.ONE($_CHR(0xEF))
	\LOG.ONE($_CHR(0xED))
IFEND[]
		}
		ELSE[]
		{

///xTOC
	\LOG.ONE($_CHR(0xEF))
	\LOG.ONE($_CHR(0xF0))

		}
		IFEND[]
	}
	IFEND[]

	return[]
}


//============================================================================
//
//■名前ウィンドウ表示
//
//============================================================================
#=es.NameSet
{
	INT[@namew_sx]
	INT[@namew_sy]

	//-----------------------------------------------------------
	// キャラ名画像表示
	//-----------------------------------------------------------
	IF[$TXN.NAME.CG!=""]
	{
		@TXN.EXIST=1

		//-----------------------------------------------------------
		// 名前描画
		//-----------------------------------------------------------
			//ボタンサイズ取得
			GOSUB[#=es.BT.SXY.GET pstr="ES.GAMEMAIN.TIP.NAMEW.TX" pint2=0]
			@namew_sx=@_RINT(1)
			@namew_sy=@_RINT(2)

			CG[ID="_NAMETMP" Z=1 E=1 FILE=$T(38,08)+$TXN.NAME.CG]
			INT[@mSX]CGINFO[ID="_NAMETMP" SX=1 LET=@mSX]
			INT[@mSY]CGINFO[ID="_NAMETMP" SY=1 LET=@mSY]

			INT[@mTXNCGX = 2]
			INT[@mTXNCGY = (@namew_sy - @mSY) / 2]

			IF[@T(36,33)==1] // 中央揃え
				@mTXNCGX += (@namew_sx - @mSX) / 2
			IFEND[]

			GOSUB[#=es.BT.ID.OFF.GET pstr="ES.GAMEMAIN.TIP.NAMEW.TX" pint2=0]
			CGACT[ID="_NAMETMP" ID2=$_RSTR(1) MERGE2=1 X=@mTXNCGX Y=@mTXNCGY]
			CGEND[ID="_NAMETMP"]

	}
	//-----------------------------------------------------------
	// キャラ名テキスト表示
	//-----------------------------------------------------------
	ELSE[$TXN.NAME.TEXT!=""]
	{
		@TXN.EXIST=1

		//-----------------------------------------------------------
		// 名前描画
		//-----------------------------------------------------------
			//ボタンサイズ取得
			GOSUB[#=es.BT.SXY.GET pstr="ES.GAMEMAIN.TIP.NAMEW.TX" pint2=0]
			@namew_sx=@_RINT(1)
			@namew_sy=@_RINT(2)

			INT[@mTXNX=2]
			INT[@mTXNY=2]

			IF[@T(36,33)==1] // 中央揃え
				\_strlen($TXN.NAME.TEXT)
				@mTXNX = ((@namew_sx / 2) - (@_RINT(1) * (@TXN.SX / 2)))
			IFEND[]

			@mTXNY = (@namew_sy - @TXN.SX) / 2

			// テキスト色設定
			IF[@es.KIDOKUCOLORFLAG]
				\FONT.COLOR( @T(36,16) )
				IF[@es.GSD(115,15)==1] \FONT.COLOR( @T(36,16), @T(36,17) ) IFEND[]
			ELSE[]
				\FONT.COLOR( @TXN.COLOR )
				IF[@es.GSD(115,15)==1] \FONT.COLOR( @TXN.COLOR, @TXN.COLOR2 ) IFEND[]
			IFEND[]

			\FONT.SIZE( @TXN.SX, @TXN.SY )
			\FONT.XY( @mTXNX, @mTXNY )

			IF[@es.GSD(115,14)==1] \FONT.BOLD( 1 ) IFEND[]
			IF[@es.GSD(115,09)==1] \FONT.SHADE( @TXN.SHADE.X, @TXN.SHADE.Y, @TXN.SHADE.COLOR ) IFEND[]
			IF[@es.GSD(115,08)==1] \FONT.OUTLINE( @TXN.OUTLINE.COLOR ) IFEND[]

			\BT.FONT.DRAW("ES.GAMEMAIN.TIP.NAMEW.TX",, $TXN.NAME.TEXT)

	}
	IFEND[]

	return[]
}


//--------------------------------------------------------------------
//■名前初期化
//--------------------------------------------------------------------
#=es.TX.NAMEINIT
{
	$TXN.NAME.TEXT = ""
	$TXN.NAME.CG = ""
	@TXN.EXIST = 0
	return[]
}


//S_INT[@PPP]
//--------------------------------------------------------------------
//■既読フラグＯＮ(63bitずつ処理)
//--------------------------------------------------------------------
#=es.TX.KIDOKU.ON
{
	IF[@_PINT(2) > 10000]
	{
		\_mes("テキスト行だけで 10000 行を超えました。別のシナリオスクリプトにジャンプさせてください。", "エラー") END[]
	}
	IFEND[]

	IF[(@es.KMD( @_PINT(1) , @_PINT(2)/63 ) & @es.POW2( @_PINT(2)%63 ))==0]
	{
		@es.KMD.FLAG=1
		@es.KMD( @_PINT(1) , @_PINT(2)/63 ) |= @es.POW2( @_PINT(2)%63 ) //特定bitに1を立てる
	}
	IFEND[]

	//@PPP+=1
	//\_dmesval(@PPP)
	//\_dmesval( @es.KMD( @_PINT(1) , @_PINT(2)/63 ) )

	return[]
}


//--------------------------------------------------------------------
//■既読フラグチェック
//--------------------------------------------------------------------
#=es.TX.KIDOKU.CHECK
{
	//\_dmesval( @_PINT(2) )

	IF[@_PINT(2) > 10000]
	{
		\_mes("テキスト行だけで 10000 行を超えました。別のシナリオスクリプトにジャンプさせてください。", "エラー") END[]
	}
	IFEND[]

	INT[@r = (( @es.KMD( @_PINT(1) , @_PINT(2)/63 ) & @es.POW2( @_PINT(2)%63 ) ) != 0)]

	return[rint=@r]
}


//--------------------------------------------------------------------
//■既読率取得
//--------------------------------------------------------------------
#=es.TX.KIDOKU.PER.GET
{
	INT[@KMD_NUM]
	INT[@mFNo]
	INT[@mLine]

	LOOP[SET=(255)]
	{
		@mFNo = @_LC-1
		@mLine=0

		LOOP[]
		{
			IF[@mLine>10000] LOOPBREAK[] IFEND[]

			IF[@es.KMD(@mFNo, @mLine/63)]
			{
				LOOP[SET=63]
				{
					\KIDOKU.CHECK(@mFNo, @mLine)
					@KMD_NUM += @_RINT(1)
					@mLine+=1
				}
				LOOPEND[]
			}
			ELSE[]
			{
				@mLine+=63
			}
			IFEND[]
		}
		LOOPEND[]
	}
	LOOPEND[]

	INT[@mPer = @KMD_NUM * 100 / (@_TEXT_NUM-1)]
	IF[@mPer<  0] @mPer=  0 IFEND[]
	IF[@mPer>100] @mPer=100 IFEND[]

	return[rint=@mPer]
}


//============================================================================
//■強制オートプレイモード ON/OFF
//============================================================================
#=es.SetSuperAutoPlayMode
{
	@es.TX.SKIP = 0  // スキップ状態を強制的に切る.

	\es.SuperAutoPlayMode = 1
	\es.SuperAutoPlayTimeTextSp = @_PINT(1) // オートモード時のテキスト速度
	\es.SuperAutoPlayTimeTextSt = @_PINT(2) // オートモード時の文末停止時間
	\es.SuperAutoPlayTimeTextCl = @_PINT(3) // オートモード時のクリック許可
	\es.SuperAutoPlayTimeTextSk = @_PINT(4) // オートモード時のスキップ許可

	return[]
}

#=es.SetSuperAutoPlayModeOFF
{
	\es.SuperAutoPlayMode = 0
	\es.SuperAutoPlayTimeTextSp = 0 // オートモード時のテキスト速度
	\es.SuperAutoPlayTimeTextSt = 0 // オートモード時の文末停止時間
	\es.SuperAutoPlayTimeTextCl = 0 // オートモード時のクリック許可
	\es.SuperAutoPlayTimeTextSk = 0 // オートモード時のスキップ許可

	return[]
}


//////

/*
//△文字情報 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.DEFSTR.GET
{
	return[rstr=$TX.DEFSTR]
}
*/

//△文字色 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.COLOR.GET { return[rint=@TX.COLOR rint2=@TX.COLOR2] }

//△キャラ名 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TXN.NAME.GET { return[rstr=$TXN.NAME.TEXT] }

//△自動改行設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ARF.GET { return[rint=@TX.AUTORETURN.F] }

//△自動改頁設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.APF.GET { return[rint=@TX.AUTOPAGE.F] }

//△自動クリック待ち設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ACF.GET { return[rint=@TX.AUTOCLICK.F] }

//△自動改行設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ARL.GET { return[rint=@TX.AUTORETURN.L] }

//△自動改頁設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.APL.GET { return[rint=@TX.AUTOPAGE.L] }

//△自動クリック待ち設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ACL.GET { return[rint=@TX.AUTOCLICK.L] }

//△一時的改行無効設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ARN.GET { return[rint=@TX.AUTORETURN.N] }

//△一時的改頁無効設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.APN.GET { return[rint=@TX.AUTOPAGE.N] }

//△一時的クリック待ち無効設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ACN.GET { return[rint=@TX.AUTOCLICK.N] }

//△ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.LEN.GET { return[rint=@TX.POS] }

#=es.TXN.EX.GET { return[rint=@TXN.EXIST] }


//////


//▼ルビ設定文字 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.RUBY.STR.SET
{
	$TX.RubyStartStr  = $_PSTR(1)
	$TX.RubyCenterStr = $_PSTR(2)
	$TX.RubyEndStr    = $_PSTR(3)


	// ルビ設定文字が１文字でない場合
	//
		\_strlen($TX.RubyStartStr)
		IF[@_RINT(1) != 1]
		{
			\_mes("ルビ設定開始文字が不正です。") END[]
		}
		IFEND[]

		\_strlen($TX.RubyCenterStr)
		IF[@_RINT(1) != 1]
		{
			\_mes("ルビ中間区切り文字が不正です。") END[]
		}
		IFEND[]

		\_strlen($TX.RubyEndStr)
		IF[@_RINT(1) != 1]
		{
			\_mes("ルビ設定終了文字が不正です。") END[]
		}
		IFEND[]


	// ルビ設定文字に同じ文字がないかチェック.
	//
		IF[$TX.RubyStartStr==$TX.RubyCenterStr]
		{
			\_mes("ルビ設定文字が重複しています。") END[]
		}
		IFEND[]

		IF[$TX.RubyStartStr==$TX.RubyEndStr]
		{
			\_mes("ルビ設定文字が重複しています。") END[]
		}
		IFEND[]

		IF[$TX.RubyCenterStr==$TX.RubyEndStr]
		{
			\_mes("ルビ設定文字が重複しています。") END[]
		}
		IFEND[]

	return[]
}


//▼文字表示速度 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.SPD.SET { @TX.SPD = @_PINT(1); return[] }

//▼自動改行設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ARF.SET { @TX.AUTORETURN.F = @_PINT(1); return[] }

//▼自動改頁設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.APF.SET { @TX.AUTOPAGE.F = @_PINT(1); return[] }

//▼自動クリック待ち設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ACF.SET { @TX.AUTOCLICK.F = @_PINT(1); return[] }

//▼自動改行設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ARL.SET { @TX.AUTORETURN.L = @_PINT(1); return[] }

//▼自動改頁設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.APL.SET { @TX.AUTOPAGE.L = @_PINT(1); return[] }

//▼自動クリック待ち設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ACL.SET { @TX.AUTOCLICK.L = @_PINT(1); return[] }

//▼一時的改行無効設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ARN.SET { @TX.AUTORETURN.N = @_PINT(1); return[] }

//▼一時的改頁無効設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.APN.SET { @TX.AUTOPAGE.N = @_PINT(1); return[] }

//▼一時的クリック待ち無効設定 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
#=es.TX.ACN.SET { @TX.AUTOCLICK.N = @_PINT(1); return[] }


