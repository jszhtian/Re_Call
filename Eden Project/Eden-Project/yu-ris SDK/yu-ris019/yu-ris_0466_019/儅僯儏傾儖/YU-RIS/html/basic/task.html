<HTML><HEAD><TITLE>YU-RIS マニュアル</TITLE><LINK REL=STYLESHEET TYPE="text/css" HREF="../css/ysstyle.css"></HEAD>
<BODY STYLE="margin:0pt 0pt 0pt 0pt" BGCOLOR=#000000>

<TABLE CELLSPACING=0 CELLPADDING=0 HEIGHT=20 CLASS=MAX>
<TR><TD BGCOLOR=#303060 CLASS=t30>
<B CLASS=t30>■<A HREF="../top.html">TOP</A>＞<A HREF="./top.html">概要</A>＞タスク</B>
</TD></TR></TABLE>

<TABLE CELLSPACING=0 CELLPADDING=0 HEIGHT=40 CLASS=MAX>
<TR><TD BGCOLOR=#606080 CLASS=t20>
　<A HREF="./basic.html">[基本文法]</A>
　<A HREF="./variable.html">[変数]</A>
　<A HREF="./svariable.html">[システム変数]</A>
　<A HREF="./macro.html">[マクロ]</A>
　<A HREF="./layer.html">[ＣＧレイヤ]</A>
　<A HREF="./task.html">[タスク]</A>
　<A HREF="./input.html">[入力]</A>
</TD></TR></TABLE>

<PRE>
<FONT CLASS=t70>■タスク</FONT>
<FONT CLASS=t20>

YU-RIS における「タスク」について説明します。

タスクは簡単な言い方をすれば、「スクリプトを実行する者」です。
（正確には意味合いが違いますが、分かりやすいよう説明します）

YU-RIS を起動させると、１個のタスクが生成されます。
このタスクというものが、スクリプトファイル上の命令を次々に実行し、
画像を表示したり変数を計算したりしていくわけです。

この、起動時に生成されるタスクをシステムタスクと呼び、
「SYSTEM」というIDが名づけられています。

システムタスクは、「system.yst」ファイルから実行を開始し、
スクリプトファイルの終端に達すると終了します。


■■マルチタスク


YU-RIS では、この自動で生成されるシステムタスクの他に、
意図的にタスクを増やす（生成する）ことができます。
そして、システムタスクと一緒に（同時に）実行させることが出来ます。

「スクリプトを実行する者」を増やすと、当然スクリプトを複数人で処理することになります。
複数人に増やすことで、どういうメリットがあるのかと言うと、
具体例で言えば、ノベルの場合なら、シナリオテキストを次々と表示しながら
クリック待ちアイコンをアニメーションさせたり、雪や雨を降らせたりする演出をする場合に
利用できます。

この場合、システムタスクが「シナリオテキストを次々と表示させる」係、
別途生成したタスクＡが「クリック待ちアイコンをアニメーションさせる」係、
また別途生成したタスクＢが「雪や雨を降らせたりする」係になったりします。

つまり、YU-RIS 上においてマルチタスクというのは、
スクリプト処理の仕組上タスク１つ（１人）では難しかったり不可能だったりする処理を、
別のタスクで助ける（実現させる）ための機能、というものになります。


次に、YU-RIS 上でタスクがどのように動いているのか、説明します。


■■タスクの動き


基本的にタスクは、「ウェイト命令」か「表示テキスト」のどちらかが実行されるまで、
一切休憩せずにノンストップで実行し続けます。

「ウェイト命令」か「表示テキスト」が来ると、タスクはそれを実行したあと、一旦休憩します(約0.016秒)。
YU-RIS は、(全ての)タスクが休憩している間に『画面を描画』することになります。
※逆に言えばタスクが実行され続けている間は、一切画面描画されません。

画面描画が終了し、0.016秒の休憩時間が過ぎると、タスクは再び実行され始めます。
これがタスクの基本的な動作になります。

では、タスクが複数存在した場合の動作について、

先ほど、タスクが複数あると同時に実行されると記述しましたが、実際には違って、
基本的に『ある瞬間に実行できるタスクは必ず１つだけ』になります。
正確には、「同時に実行されているように見えるくらい、複数のタスクが高速に
入れ替わり実行されている」のです。
例えば「タスクＡ」と「タスクＢ」の２つのタスクが生成されていたとすると、
まずタスクＡが動作し、ウェイト命令か表示テキストが来て休憩に入ります。
するとその瞬間、間髪入れずに次のタスクＢが動き始めます。
そしてやはり、同様にウェイト命令か表示テキストが来るとその後休憩に入ります。
２つのタスクの実行が終わったので、その次の瞬間に、システムが画面の描画を始めます。

動作をまとめると、

    (1)タスクＡ実行開始
        ↓
    (2)「ウェイト命令」or「テキスト文字」現る
        ↓
    (3)タスクＡ休憩
        ↓
    (4)タスクＢ実行開始
        ↓
    (5)「ウェイト命令」or「テキスト文字」現る
        ↓
    (6)タスクＢ休憩
        ↓
    (7)システム画面描画
        ↓
    (8)0.016秒の休憩が過ぎたら、(1)へ戻る


このような感じになります。

また、例えばタスクＡで１秒待つウェイト命令が実行された場合は、
タスクＡは１秒経つまでの間は、実行開始(1)しても何もせずにすぐに休憩状態(3)となり、
タスクＢにバトンを渡します(4)。つまり１秒間はタスクＢだけしか動かない状態になります。

ひとつ注意として、ウェイト命令を入れ忘れたりすると、
タスクはいつまで経っても休憩することが出来なくなり、CPU使用率が100％になったまま、
YU-RIS が応答無しの状態になってしまいます。


    LOOP[SET=タスク実行回数]

        演出

        ウェイト命令

    LOOPEND[]


演出の基本は、たいてい上の形になります。
具体的に書くと、下のようになります。


    LOOP[SET=60]

        CG[ID=ABC X-=2] //ここを通る度にレイヤ「ABC」のＸ座標を２減らす

        WAIT[FRAME=1]   //１フレーム分ウェイト。タスクを１回休憩させる(画面を描画させる)

    LOOPEND[]



■■タスクの優先順位


タスクが複数存在する場合、タスクが実行される順番という概念が生まれてきます。
ＣＧレイヤと同様、タスクにもそれぞれ優先度(Z値)を付けることができ、
その優先度の高い順から実行されます。

例えばタスクＡの優先度が 100 で、タスクＢの優先度が 300 だった場合、
タスクＢ→タスクＡ→システム描画→タスクＢ→タスクＡ→……　という順番で実行されます。
※優先度の値が同じだった場合の実行順序は不確定となります。

ちなみに、起動時に自動的に生成されるシステムタスクはデフォルトで「100」となっています。
この値より大きい値を付ければシステムタスクより先に、小さい値を付ければシステムタスクより後に
毎回タスクが実行されることになります。



</FONT></B>
</FONT>


</BODY></HTML>
