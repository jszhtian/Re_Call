# 查找CxEncryption密钥的基本方法

本文以游戏`ATRI -My Dear Moments-`为例，该游戏引擎为`KirikiriZ`最新版。

在IDA中载入游戏主程序。

使用文本搜索功能找到`tTVPXP3ArchiveStream`类的虚函数表，其中第2项就是`tTVPXP3ArchiveStream::Read`函数。

为了使动态调试时，镜像基址与IDA中相同，需要禁止镜像随机基址。

使用`Detect It Easy`工具勾选`RELOCS_STRIPPED`即可。

![20200620032918](images/20200620032918.png)

使用`x32dbg`调试游戏主程序，在`tTVPXP3ArchiveStream::Read`函数下一个断点。

按`F9`运行程序，程序会停在这个函数，先按`Ctrl+F9`运行到该函数返回，再按`F8`跳出这个函数，执行到这里。

![20200620033323](images/20200620033323.png)

继续按`Ctrl+F9`、`F8`跳出`sub_425E30`这个函数，然后发现`EIP`已经不在主程序里了。

![20200620033435](images/20200620033435.png)

这时我们不用继续跟踪了，先把这块代码Dump出来，并记住这块代码的地址`0x10000000`。

![20200620033549](images/20200620033549.png)

使用IDA载入Dump出来的代码，选择`Binary File`进行分析。

![20200620033857](images/20200620033857.png)

选择`Yes`，因为是`32-bit`的代码。

![20200620033944](images/20200620033944.png)

先进行`Rebase`以还原镜像基址。

![20200620034124](images/20200620034124.png)

选择`Address of the first segment`模式，并输入基址`0x10000000`，执行Rebase。

![20200620034328](images/20200620034328.png)

这样我们就在IDA中得到了与x32dbg中相同的代码，方便接下来的分析。

![20200620034717](images/20200620034717.png)

由于IDA并没有正确分析到这个函数，所以我们向上找到这个函数的开头，按下`P`使IDA分析这个函数。

![20200620035007](images/20200620035007.png)

现在可以按`F5`反编译这个函数了。

![20200620035115](images/20200620035115.png)

回到x32dbg中，继续往下执行到一个call的地方。

![20200620035324](images/20200620035324.png)

该函数即为解密文件数据的函数。

![20200620035506](images/20200620035506.png)

按`F7`跟进这个函数。

![20200620035700](images/20200620035700.png)

此处的`sub_10001150`即为`CxEncrypt`的解密函数。

![20200620040010](images/20200620040010.png)

> `CxEncrypt`是`Kirikiri`专用的加密算法，它通过输入一个`Key`来生成两个函数的`ShellCode`，然后执行这个两个函数，生成两个`Key`，再用这两个`Key`来解密数据。

以`GARbro`中的实现为例，该算法需要如下参数：

```csharp
uint Mask;
uint Offset;
byte[3] PrologOrder;
byte[6] OddBranchOrder;
byte[8] EvenBranchOrder;
uint[] ControlBlock;
// 在 kirikiricx.cs 文件中
```

我们先找`Mask`和`Offset`这两个，只需要在IDA左边的函数列表中随意翻找即可找到。

![20200620041347](images/20200620041347.png)

> 如果IDA没有自动分析该函数，那就需要在ASM代码中查找了。

然后查找`ControlBlock`的数据。回到上面的`sub_10001150`函数，跟进`sub_10008920`函数里。

![20200620041940](images/20200620041940.png)

你会看到一个没有参数的函数`sub_10001250`的调用。

![20200620042033](images/20200620042033.png)

该数值是一个内存地址，我们直接在x32dbg中找到它。

![20200620042111](images/20200620042111.png)

从此地址开始，`4096`个字节的数据，即为`ControlBlock`的数据。

最后找三组order。跟进`sub_10008EF0`这个函数，里面只有一个函数调用，继续跟进。

![20200620042409](images/20200620042409.png)

![20200620042642](images/20200620042642.png)

这个函数一般情况下都无法F5反编译的，它会告诉你这个switch分析不了。

![20200620042802](images/20200620042802.png)

可以尝试修复一下，如果不行，那就只能人力反编译了。

双击`jmp`后面的`off_10008DBC`来到这里。

这里是一个`switch`跳转表，它应该是几个整数的跳转地址。

![20200620042842](images/20200620042842.png)

把光标移到`10008DC0`，然后按`D`调整数据类型。

![20200620043053](images/20200620043053.png)

随便选中一个分支过去看看，都没有识别成代码。

![20200620043116](images/20200620043116.png)

只需要按`C`让IDA分析它就行了。

![20200620043207](images/20200620043207.png)

这样就可以读了，其它分支也用相同的方法处理一下。

![20200620043324](images/20200620043324.png)

回到刚才的`switch jmp`尝试`F5`还是不行，所以干脆就放弃了。
有这个`switch`就够了，不需要看反编译代码，继续看这个`switch jump`。

![20200620043509](images/20200620043509.png)

它有`6`个分支，对应的是`OddBranchOrder`这一组。

![20200620043629](images/20200620043629.png)

morkt已经把关键数字标出来了。我们需要做的就是找到对应关系。

![20200620043848](images/20200620043848.png)

把光标放到第一个分支上，此时IDA会弹出这个分支处的反汇编代码，然后可以滚动鼠标滚轮往下翻。
对比上面两张图，很容易就会发现IDA中的这个`分支0`会对应源码中的`分支0`。
所以我们记录下来：

![20200620044141](images/20200620044141.png)

然后看下一个。

![20200620043848](images/20200620044222.png)

对应源码中的`分支4`，所以接着记录。

![20200620044338](images/20200620044338.png)

重复上述步骤就可以把这一组`6`个数字找完了。

由于这个函数不能`F5`反编译，所以只能手动找其它组的`switch`了。
回到`sub_10008BA0`函数头，向下查找，就能找到`call sub_10008F30`

![20200620044713](images/20200620044713.png)

跟进这个函数，往下翻，就会发现非常相似的代码。

![20200620044812](images/20200620044812.png)

按照同样的方式处理即可。

![20200620044932](images/20200620044932.png)

这里有`8`个分支，所以对应的是：

![20200620045011](images/20200620045011.png)

然后就跟上面一样找对应关系，并且记录下来就可以完成这一组数字了。

![20200620045813](images/20200620045813.png)

再次回到`sub_10008BA0`函数头部，往下一点的地方可以找到`call sub_1008DE0`。

![20200620045217](images/20200620045217.png)

跟进去之后发现是可以`F5`反编译的。

![20200620045607](images/20200620045607.png)

![20200620045624](images/20200620045624.png)

可以看到有`3`个分支，所以这里对应：

![20200620045925](images/20200620045925.png)

分支识别出来之后，还是按照上面的方式，找对应关系。
找完`3`个数字即可。

> 注意：`GARbro`里用到的`ControlBlock`每个字节都经过位取反。

![20200620051001](images/20200620051001.png)